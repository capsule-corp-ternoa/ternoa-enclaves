# [allow (dead_code , unused_imports , non_camel_case_types)] pub mod api { use super :: api as root_mod ; pub static PALLETS : [& str ; 34usize] = ["System" , "Scheduler" , "Babe" , "Timestamp" , "Balances" , "TransactionPayment" , "Authorship" , "Offences" , "Historical" , "Session" , "Grandpa" , "ImOnline" , "AuthorityDiscovery" , "Council" , "PhragmenElection" , "Democracy" , "Staking" , "StakingRewards" , "ElectionProviderMultiPhase" , "BagsList" , "TechnicalCommittee" , "TechnicalMembership" , "Mandate" , "Treasury" , "Utility" , "Preimage" , "Bridge" , "Multisig" , "Identity" , "NFT" , "Marketplace" , "Assets" , "Auction" , "Rent" ,] ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Event { # [codec (index = 0)] System (system :: Event) , # [codec (index = 1)] Scheduler (scheduler :: Event) , # [codec (index = 4)] Balances (balances :: Event) , # [codec (index = 5)] TransactionPayment (transaction_payment :: Event) , # [codec (index = 7)] Offences (offences :: Event) , # [codec (index = 9)] Session (session :: Event) , # [codec (index = 10)] Grandpa (grandpa :: Event) , # [codec (index = 11)] ImOnline (im_online :: Event) , # [codec (index = 24)] Council (council :: Event) , # [codec (index = 25)] PhragmenElection (phragmen_election :: Event) , # [codec (index = 26)] Democracy (democracy :: Event) , # [codec (index = 13)] Staking (staking :: Event) , # [codec (index = 14)] StakingRewards (staking_rewards :: Event) , # [codec (index = 15)] ElectionProviderMultiPhase (election_provider_multi_phase :: Event) , # [codec (index = 16)] BagsList (bags_list :: Event) , # [codec (index = 17)] TechnicalCommittee (technical_committee :: Event) , # [codec (index = 18)] TechnicalMembership (technical_membership :: Event) , # [codec (index = 19)] Mandate (mandate :: Event) , # [codec (index = 20)] Treasury (treasury :: Event) , # [codec (index = 21)] Utility (utility :: Event) , # [codec (index = 22)] Preimage (preimage :: Event) , # [codec (index = 23)] Bridge (bridge :: Event) , # [codec (index = 27)] Multisig (multisig :: Event) , # [codec (index = 28)] Identity (identity :: Event) , # [codec (index = 29)] NFT (nft :: Event) , # [codec (index = 30)] Marketplace (marketplace :: Event) , # [codec (index = 31)] Assets (assets :: Event) , # [codec (index = 32)] Auction (auction :: Event) , # [codec (index = 33)] Rent (rent :: Event) , } pub mod system { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct FillBlock { pub ratio : runtime_types :: sp_arithmetic :: per_things :: Perbill , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Remark { pub remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetHeapPages { pub pages : :: core :: primitive :: u64 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetCode { pub code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetCodeWithoutChecks { pub code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetStorage { pub items : :: std :: vec :: Vec < (:: std :: vec :: Vec < :: core :: primitive :: u8 > , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct KillStorage { pub keys : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct KillPrefix { pub prefix : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub subkeys : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RemarkWithEvent { pub remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } pub struct TransactionApi ; impl TransactionApi { # [doc = "A dispatch that will fill the block weight up to the given ratio."] pub fn fill_block (& self , ratio : runtime_types :: sp_arithmetic :: per_things :: Perbill ,) -> :: subxt :: tx :: StaticTxPayload < FillBlock > { :: subxt :: tx :: StaticTxPayload :: new ("System" , "fill_block" , FillBlock { ratio , } , [48u8 , 18u8 , 205u8 , 90u8 , 222u8 , 4u8 , 20u8 , 251u8 , 173u8 , 76u8 , 167u8 , 4u8 , 83u8 , 203u8 , 160u8 , 89u8 , 132u8 , 218u8 , 191u8 , 145u8 , 130u8 , 245u8 , 177u8 , 201u8 , 169u8 , 129u8 , 173u8 , 105u8 , 88u8 , 45u8 , 136u8 , 191u8 ,]) } # [doc = "Make some on-chain remark."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)`"] # [doc = "# </weight>"] pub fn remark (& self , remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: StaticTxPayload < Remark > { :: subxt :: tx :: StaticTxPayload :: new ("System" , "remark" , Remark { remark , } , [101u8 , 80u8 , 195u8 , 226u8 , 224u8 , 247u8 , 60u8 , 128u8 , 3u8 , 101u8 , 51u8 , 147u8 , 96u8 , 126u8 , 76u8 , 230u8 , 194u8 , 227u8 , 191u8 , 73u8 , 160u8 , 146u8 , 87u8 , 147u8 , 243u8 , 28u8 , 228u8 , 116u8 , 224u8 , 181u8 , 129u8 , 160u8 ,]) } # [doc = "Set the number of pages in the WebAssembly environment's heap."] pub fn set_heap_pages (& self , pages : :: core :: primitive :: u64 ,) -> :: subxt :: tx :: StaticTxPayload < SetHeapPages > { :: subxt :: tx :: StaticTxPayload :: new ("System" , "set_heap_pages" , SetHeapPages { pages , } , [43u8 , 103u8 , 128u8 , 49u8 , 156u8 , 136u8 , 11u8 , 204u8 , 80u8 , 6u8 , 244u8 , 86u8 , 171u8 , 44u8 , 140u8 , 225u8 , 142u8 , 198u8 , 43u8 , 87u8 , 26u8 , 45u8 , 125u8 , 222u8 , 165u8 , 254u8 , 172u8 , 158u8 , 39u8 , 178u8 , 86u8 , 87u8 ,]) } # [doc = "Set the new runtime code."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`"] # [doc = "- 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is"] # [doc = "  expensive)."] # [doc = "- 1 storage write (codec `O(C)`)."] # [doc = "- 1 digest item."] # [doc = "- 1 event."] # [doc = "The weight of this function is dependent on the runtime, but generally this is very"] # [doc = "expensive. We will treat this as a full block."] # [doc = "# </weight>"] pub fn set_code (& self , code : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: StaticTxPayload < SetCode > { :: subxt :: tx :: StaticTxPayload :: new ("System" , "set_code" , SetCode { code , } , [27u8 , 104u8 , 244u8 , 205u8 , 188u8 , 254u8 , 121u8 , 13u8 , 106u8 , 120u8 , 244u8 , 108u8 , 97u8 , 84u8 , 100u8 , 68u8 , 26u8 , 69u8 , 93u8 , 128u8 , 107u8 , 4u8 , 3u8 , 142u8 , 13u8 , 134u8 , 196u8 , 62u8 , 113u8 , 181u8 , 14u8 , 40u8 ,]) } # [doc = "Set the new runtime code without doing any checks of the given `code`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(C)` where `C` length of `code`"] # [doc = "- 1 storage write (codec `O(C)`)."] # [doc = "- 1 digest item."] # [doc = "- 1 event."] # [doc = "The weight of this function is dependent on the runtime. We will treat this as a full"] # [doc = "block. # </weight>"] pub fn set_code_without_checks (& self , code : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: StaticTxPayload < SetCodeWithoutChecks > { :: subxt :: tx :: StaticTxPayload :: new ("System" , "set_code_without_checks" , SetCodeWithoutChecks { code , } , [102u8 , 160u8 , 125u8 , 235u8 , 30u8 , 23u8 , 45u8 , 239u8 , 112u8 , 148u8 , 159u8 , 158u8 , 42u8 , 93u8 , 206u8 , 94u8 , 80u8 , 250u8 , 66u8 , 195u8 , 60u8 , 40u8 , 142u8 , 169u8 , 183u8 , 80u8 , 80u8 , 96u8 , 3u8 , 231u8 , 99u8 , 216u8 ,]) } # [doc = "Set some items of storage."] pub fn set_storage (& self , items : :: std :: vec :: Vec < (:: std :: vec :: Vec < :: core :: primitive :: u8 > , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) > ,) -> :: subxt :: tx :: StaticTxPayload < SetStorage > { :: subxt :: tx :: StaticTxPayload :: new ("System" , "set_storage" , SetStorage { items , } , [74u8 , 43u8 , 106u8 , 255u8 , 50u8 , 151u8 , 192u8 , 155u8 , 14u8 , 90u8 , 19u8 , 45u8 , 165u8 , 16u8 , 235u8 , 242u8 , 21u8 , 131u8 , 33u8 , 172u8 , 119u8 , 78u8 , 140u8 , 10u8 , 107u8 , 202u8 , 122u8 , 235u8 , 181u8 , 191u8 , 22u8 , 116u8 ,]) } # [doc = "Kill some items from storage."] pub fn kill_storage (& self , keys : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > ,) -> :: subxt :: tx :: StaticTxPayload < KillStorage > { :: subxt :: tx :: StaticTxPayload :: new ("System" , "kill_storage" , KillStorage { keys , } , [174u8 , 174u8 , 13u8 , 174u8 , 75u8 , 138u8 , 128u8 , 235u8 , 222u8 , 216u8 , 85u8 , 18u8 , 198u8 , 1u8 , 138u8 , 70u8 , 19u8 , 108u8 , 209u8 , 41u8 , 228u8 , 67u8 , 130u8 , 230u8 , 160u8 , 207u8 , 11u8 , 180u8 , 139u8 , 242u8 , 41u8 , 15u8 ,]) } # [doc = "Kill all storage items with a key that starts with the given prefix."] # [doc = ""] # [doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"] # [doc = "the prefix we are removing to accurately calculate the weight of this function."] pub fn kill_prefix (& self , prefix : :: std :: vec :: Vec < :: core :: primitive :: u8 > , subkeys : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < KillPrefix > { :: subxt :: tx :: StaticTxPayload :: new ("System" , "kill_prefix" , KillPrefix { prefix , subkeys , } , [203u8 , 116u8 , 217u8 , 42u8 , 154u8 , 215u8 , 77u8 , 217u8 , 13u8 , 22u8 , 193u8 , 2u8 , 128u8 , 115u8 , 179u8 , 115u8 , 187u8 , 218u8 , 129u8 , 34u8 , 80u8 , 4u8 , 173u8 , 120u8 , 92u8 , 35u8 , 237u8 , 112u8 , 201u8 , 207u8 , 200u8 , 48u8 ,]) } # [doc = "Make some on-chain remark and emit event."] pub fn remark_with_event (& self , remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: StaticTxPayload < RemarkWithEvent > { :: subxt :: tx :: StaticTxPayload :: new ("System" , "remark_with_event" , RemarkWithEvent { remark , } , [123u8 , 225u8 , 180u8 , 179u8 , 144u8 , 74u8 , 27u8 , 85u8 , 101u8 , 75u8 , 134u8 , 44u8 , 181u8 , 25u8 , 183u8 , 158u8 , 14u8 , 213u8 , 56u8 , 225u8 , 136u8 , 88u8 , 26u8 , 114u8 , 178u8 , 43u8 , 176u8 , 43u8 , 240u8 , 84u8 , 116u8 , 46u8 ,]) } } } # [doc = "Event for the System pallet."] pub type Event = runtime_types :: frame_system :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An extrinsic completed successfully."] pub struct ExtrinsicSuccess { pub dispatch_info : runtime_types :: frame_support :: dispatch :: DispatchInfo , } impl :: subxt :: events :: StaticEvent for ExtrinsicSuccess { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "ExtrinsicSuccess" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An extrinsic failed."] pub struct ExtrinsicFailed { pub dispatch_error : runtime_types :: sp_runtime :: DispatchError , pub dispatch_info : runtime_types :: frame_support :: dispatch :: DispatchInfo , } impl :: subxt :: events :: StaticEvent for ExtrinsicFailed { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "ExtrinsicFailed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "`:code` was updated."] pub struct CodeUpdated ; impl :: subxt :: events :: StaticEvent for CodeUpdated { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "CodeUpdated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A new account was created."] pub struct NewAccount { pub account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for NewAccount { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "NewAccount" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An account was reaped."] pub struct KilledAccount { pub account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for KilledAccount { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "KilledAccount" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "On on-chain remark happened."] pub struct Remarked { pub sender : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub hash : :: subxt :: ext :: sp_core :: H256 , } impl :: subxt :: events :: StaticEvent for Remarked { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "Remarked" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The full account information for a particular account ID."] pub fn account (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: frame_system :: AccountInfo < :: core :: primitive :: u32 , runtime_types :: pallet_balances :: AccountData < :: core :: primitive :: u128 > > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "Account" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [176u8 , 187u8 , 21u8 , 220u8 , 159u8 , 204u8 , 127u8 , 14u8 , 21u8 , 69u8 , 77u8 , 114u8 , 230u8 , 141u8 , 107u8 , 79u8 , 23u8 , 16u8 , 174u8 , 243u8 , 252u8 , 42u8 , 65u8 , 120u8 , 229u8 , 38u8 , 210u8 , 255u8 , 22u8 , 40u8 , 109u8 , 223u8 ,]) } # [doc = " The full account information for a particular account ID."] pub fn account_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: frame_system :: AccountInfo < :: core :: primitive :: u32 , runtime_types :: pallet_balances :: AccountData < :: core :: primitive :: u128 > > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "Account" , Vec :: new () , [176u8 , 187u8 , 21u8 , 220u8 , 159u8 , 204u8 , 127u8 , 14u8 , 21u8 , 69u8 , 77u8 , 114u8 , 230u8 , 141u8 , 107u8 , 79u8 , 23u8 , 16u8 , 174u8 , 243u8 , 252u8 , 42u8 , 65u8 , 120u8 , 229u8 , 38u8 , 210u8 , 255u8 , 22u8 , 40u8 , 109u8 , 223u8 ,]) } # [doc = " Total extrinsics count for the current block."] pub fn extrinsic_count (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "ExtrinsicCount" , vec ! [] , [223u8 , 60u8 , 201u8 , 120u8 , 36u8 , 44u8 , 180u8 , 210u8 , 242u8 , 53u8 , 222u8 , 154u8 , 123u8 , 176u8 , 249u8 , 8u8 , 225u8 , 28u8 , 232u8 , 4u8 , 136u8 , 41u8 , 151u8 , 82u8 , 189u8 , 149u8 , 49u8 , 166u8 , 139u8 , 9u8 , 163u8 , 231u8 ,]) } # [doc = " The current weight for the block."] pub fn block_weight (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: frame_support :: dispatch :: PerDispatchClass < runtime_types :: sp_weights :: weight_v2 :: Weight > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "BlockWeight" , vec ! [] , [120u8 , 67u8 , 71u8 , 163u8 , 36u8 , 202u8 , 52u8 , 106u8 , 143u8 , 155u8 , 144u8 , 87u8 , 142u8 , 241u8 , 232u8 , 183u8 , 56u8 , 235u8 , 27u8 , 237u8 , 20u8 , 202u8 , 33u8 , 85u8 , 189u8 , 0u8 , 28u8 , 52u8 , 198u8 , 40u8 , 219u8 , 54u8 ,]) } # [doc = " Total length (in bytes) for all extrinsics put together, for the current block."] pub fn all_extrinsics_len (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "AllExtrinsicsLen" , vec ! [] , [202u8 , 145u8 , 209u8 , 225u8 , 40u8 , 220u8 , 174u8 , 74u8 , 93u8 , 164u8 , 254u8 , 248u8 , 254u8 , 192u8 , 32u8 , 117u8 , 96u8 , 149u8 , 53u8 , 145u8 , 219u8 , 64u8 , 234u8 , 18u8 , 217u8 , 200u8 , 203u8 , 141u8 , 145u8 , 28u8 , 134u8 , 60u8 ,]) } # [doc = " Map of block numbers to block hashes."] pub fn block_hash (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: subxt :: ext :: sp_core :: H256 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "BlockHash" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [50u8 , 112u8 , 176u8 , 239u8 , 175u8 , 18u8 , 205u8 , 20u8 , 241u8 , 195u8 , 21u8 , 228u8 , 186u8 , 57u8 , 200u8 , 25u8 , 38u8 , 44u8 , 106u8 , 20u8 , 168u8 , 80u8 , 76u8 , 235u8 , 12u8 , 51u8 , 137u8 , 149u8 , 200u8 , 4u8 , 220u8 , 237u8 ,]) } # [doc = " Map of block numbers to block hashes."] pub fn block_hash_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: subxt :: ext :: sp_core :: H256 > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "BlockHash" , Vec :: new () , [50u8 , 112u8 , 176u8 , 239u8 , 175u8 , 18u8 , 205u8 , 20u8 , 241u8 , 195u8 , 21u8 , 228u8 , 186u8 , 57u8 , 200u8 , 25u8 , 38u8 , 44u8 , 106u8 , 20u8 , 168u8 , 80u8 , 76u8 , 235u8 , 12u8 , 51u8 , 137u8 , 149u8 , 200u8 , 4u8 , 220u8 , 237u8 ,]) } # [doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."] pub fn extrinsic_data (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "ExtrinsicData" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [210u8 , 224u8 , 211u8 , 186u8 , 118u8 , 210u8 , 185u8 , 194u8 , 238u8 , 211u8 , 254u8 , 73u8 , 67u8 , 184u8 , 31u8 , 229u8 , 168u8 , 125u8 , 98u8 , 23u8 , 241u8 , 59u8 , 49u8 , 86u8 , 126u8 , 9u8 , 114u8 , 163u8 , 160u8 , 62u8 , 50u8 , 67u8 ,]) } # [doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."] pub fn extrinsic_data_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "ExtrinsicData" , Vec :: new () , [210u8 , 224u8 , 211u8 , 186u8 , 118u8 , 210u8 , 185u8 , 194u8 , 238u8 , 211u8 , 254u8 , 73u8 , 67u8 , 184u8 , 31u8 , 229u8 , 168u8 , 125u8 , 98u8 , 23u8 , 241u8 , 59u8 , 49u8 , 86u8 , 126u8 , 9u8 , 114u8 , 163u8 , 160u8 , 62u8 , 50u8 , 67u8 ,]) } # [doc = " The current block number being processed. Set by `execute_block`."] pub fn number (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "Number" , vec ! [] , [228u8 , 96u8 , 102u8 , 190u8 , 252u8 , 130u8 , 239u8 , 172u8 , 126u8 , 235u8 , 246u8 , 139u8 , 208u8 , 15u8 , 88u8 , 245u8 , 141u8 , 232u8 , 43u8 , 204u8 , 36u8 , 87u8 , 211u8 , 141u8 , 187u8 , 68u8 , 236u8 , 70u8 , 193u8 , 235u8 , 164u8 , 191u8 ,]) } # [doc = " Hash of the previous block."] pub fn parent_hash (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: subxt :: ext :: sp_core :: H256 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "ParentHash" , vec ! [] , [232u8 , 206u8 , 177u8 , 119u8 , 38u8 , 57u8 , 233u8 , 50u8 , 225u8 , 49u8 , 169u8 , 176u8 , 210u8 , 51u8 , 231u8 , 176u8 , 234u8 , 186u8 , 188u8 , 112u8 , 15u8 , 152u8 , 195u8 , 232u8 , 201u8 , 97u8 , 208u8 , 249u8 , 9u8 , 163u8 , 69u8 , 36u8 ,]) } # [doc = " Digest of the current block, also part of the block header."] pub fn digest (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_runtime :: generic :: digest :: Digest > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "Digest" , vec ! [] , [83u8 , 141u8 , 200u8 , 132u8 , 182u8 , 55u8 , 197u8 , 122u8 , 13u8 , 159u8 , 31u8 , 42u8 , 60u8 , 191u8 , 89u8 , 221u8 , 242u8 , 47u8 , 199u8 , 213u8 , 48u8 , 216u8 , 131u8 , 168u8 , 245u8 , 82u8 , 56u8 , 190u8 , 62u8 , 69u8 , 96u8 , 37u8 ,]) } # [doc = " Events deposited for the current block."] # [doc = ""] # [doc = " NOTE: The item is unbound and should therefore never be read on chain."] # [doc = " It could otherwise inflate the PoV size of a block."] # [doc = ""] # [doc = " Events have a large in-memory size. Box the events to not go out-of-memory"] # [doc = " just in case someone still reads them from within the runtime."] pub fn events (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < runtime_types :: frame_system :: EventRecord < runtime_types :: alphanet_runtime :: RuntimeEvent , :: subxt :: ext :: sp_core :: H256 > > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "Events" , vec ! [] , [186u8 , 136u8 , 37u8 , 255u8 , 101u8 , 199u8 , 231u8 , 173u8 , 73u8 , 0u8 , 85u8 , 105u8 , 9u8 , 40u8 , 117u8 , 178u8 , 177u8 , 213u8 , 7u8 , 31u8 , 224u8 , 247u8 , 190u8 , 173u8 , 141u8 , 232u8 , 207u8 , 62u8 , 70u8 , 7u8 , 151u8 , 104u8 ,]) } # [doc = " The number of events in the `Events<T>` list."] pub fn event_count (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "EventCount" , vec ! [] , [236u8 , 93u8 , 90u8 , 177u8 , 250u8 , 211u8 , 138u8 , 187u8 , 26u8 , 208u8 , 203u8 , 113u8 , 221u8 , 233u8 , 227u8 , 9u8 , 249u8 , 25u8 , 202u8 , 185u8 , 161u8 , 144u8 , 167u8 , 104u8 , 127u8 , 187u8 , 38u8 , 18u8 , 52u8 , 61u8 , 66u8 , 112u8 ,]) } # [doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"] # [doc = " of events in the `<Events<T>>` list."] # [doc = ""] # [doc = " All topic vectors have deterministic storage locations depending on the topic. This"] # [doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"] # [doc = " in case of changes fetch the list of events of interest."] # [doc = ""] # [doc = " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just"] # [doc = " the `EventIndex` then in case if the topic has the same contents on the next block"] # [doc = " no notification will be triggered thus the event might be lost."] pub fn event_topics (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: H256 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "EventTopics" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [205u8 , 90u8 , 142u8 , 190u8 , 176u8 , 37u8 , 94u8 , 82u8 , 98u8 , 1u8 , 129u8 , 63u8 , 246u8 , 101u8 , 130u8 , 58u8 , 216u8 , 16u8 , 139u8 , 196u8 , 154u8 , 111u8 , 110u8 , 178u8 , 24u8 , 44u8 , 183u8 , 176u8 , 232u8 , 82u8 , 223u8 , 38u8 ,]) } # [doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"] # [doc = " of events in the `<Events<T>>` list."] # [doc = ""] # [doc = " All topic vectors have deterministic storage locations depending on the topic. This"] # [doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"] # [doc = " in case of changes fetch the list of events of interest."] # [doc = ""] # [doc = " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just"] # [doc = " the `EventIndex` then in case if the topic has the same contents on the next block"] # [doc = " no notification will be triggered thus the event might be lost."] pub fn event_topics_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "EventTopics" , Vec :: new () , [205u8 , 90u8 , 142u8 , 190u8 , 176u8 , 37u8 , 94u8 , 82u8 , 98u8 , 1u8 , 129u8 , 63u8 , 246u8 , 101u8 , 130u8 , 58u8 , 216u8 , 16u8 , 139u8 , 196u8 , 154u8 , 111u8 , 110u8 , 178u8 , 24u8 , 44u8 , 183u8 , 176u8 , 232u8 , 82u8 , 223u8 , 38u8 ,]) } # [doc = " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."] pub fn last_runtime_upgrade (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: frame_system :: LastRuntimeUpgradeInfo > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "LastRuntimeUpgrade" , vec ! [] , [52u8 , 37u8 , 117u8 , 111u8 , 57u8 , 130u8 , 196u8 , 14u8 , 99u8 , 77u8 , 91u8 , 126u8 , 178u8 , 249u8 , 78u8 , 34u8 , 9u8 , 194u8 , 92u8 , 105u8 , 113u8 , 81u8 , 185u8 , 127u8 , 245u8 , 184u8 , 60u8 , 29u8 , 234u8 , 182u8 , 96u8 , 196u8 ,]) } # [doc = " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."] pub fn upgraded_to_u32_ref_count (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: bool > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "UpgradedToU32RefCount" , vec ! [] , [171u8 , 88u8 , 244u8 , 92u8 , 122u8 , 67u8 , 27u8 , 18u8 , 59u8 , 175u8 , 175u8 , 178u8 , 20u8 , 150u8 , 213u8 , 59u8 , 222u8 , 141u8 , 32u8 , 107u8 , 3u8 , 114u8 , 83u8 , 250u8 , 180u8 , 233u8 , 152u8 , 54u8 , 187u8 , 99u8 , 131u8 , 204u8 ,]) } # [doc = " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False"] # [doc = " (default) if not."] pub fn upgraded_to_triple_ref_count (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: bool > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "UpgradedToTripleRefCount" , vec ! [] , [90u8 , 33u8 , 56u8 , 86u8 , 90u8 , 101u8 , 89u8 , 133u8 , 203u8 , 56u8 , 201u8 , 210u8 , 244u8 , 232u8 , 150u8 , 18u8 , 51u8 , 105u8 , 14u8 , 230u8 , 103u8 , 155u8 , 246u8 , 99u8 , 53u8 , 207u8 , 225u8 , 128u8 , 186u8 , 76u8 , 40u8 , 185u8 ,]) } # [doc = " The execution phase of the block."] pub fn execution_phase (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: frame_system :: Phase > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("System" , "ExecutionPhase" , vec ! [] , [230u8 , 183u8 , 221u8 , 135u8 , 226u8 , 223u8 , 55u8 , 104u8 , 138u8 , 224u8 , 103u8 , 156u8 , 222u8 , 99u8 , 203u8 , 199u8 , 164u8 , 168u8 , 193u8 , 133u8 , 201u8 , 155u8 , 63u8 , 95u8 , 17u8 , 206u8 , 165u8 , 123u8 , 161u8 , 33u8 , 172u8 , 93u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Block & extrinsics weights: base values and limits."] pub fn block_weights (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < runtime_types :: frame_system :: limits :: BlockWeights >> { :: subxt :: constants :: StaticConstantAddress :: new ("System" , "BlockWeights" , [118u8 , 253u8 , 239u8 , 217u8 , 145u8 , 115u8 , 85u8 , 86u8 , 172u8 , 248u8 , 139u8 , 32u8 , 158u8 , 126u8 , 172u8 , 188u8 , 197u8 , 105u8 , 145u8 , 235u8 , 171u8 , 50u8 , 31u8 , 225u8 , 167u8 , 187u8 , 241u8 , 87u8 , 6u8 , 17u8 , 234u8 , 185u8 ,]) } # [doc = " The maximum length of a block (in bytes)."] pub fn block_length (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < runtime_types :: frame_system :: limits :: BlockLength >> { :: subxt :: constants :: StaticConstantAddress :: new ("System" , "BlockLength" , [116u8 , 184u8 , 225u8 , 228u8 , 207u8 , 203u8 , 4u8 , 220u8 , 234u8 , 198u8 , 150u8 , 108u8 , 205u8 , 87u8 , 194u8 , 131u8 , 229u8 , 51u8 , 140u8 , 4u8 , 47u8 , 12u8 , 200u8 , 144u8 , 153u8 , 62u8 , 51u8 , 39u8 , 138u8 , 205u8 , 203u8 , 236u8 ,]) } # [doc = " Maximum number of block number to block hash mappings to keep (oldest pruned first)."] pub fn block_hash_count (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("System" , "BlockHashCount" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The weight of runtime database operations the runtime can invoke."] pub fn db_weight (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_weights :: RuntimeDbWeight >> { :: subxt :: constants :: StaticConstantAddress :: new ("System" , "DbWeight" , [124u8 , 162u8 , 190u8 , 149u8 , 49u8 , 177u8 , 162u8 , 231u8 , 62u8 , 167u8 , 199u8 , 181u8 , 43u8 , 232u8 , 185u8 , 116u8 , 195u8 , 51u8 , 233u8 , 223u8 , 20u8 , 129u8 , 246u8 , 13u8 , 65u8 , 180u8 , 64u8 , 9u8 , 157u8 , 59u8 , 245u8 , 118u8 ,]) } # [doc = " Get the chain's current version."] pub fn version (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_version :: RuntimeVersion >> { :: subxt :: constants :: StaticConstantAddress :: new ("System" , "Version" , [93u8 , 98u8 , 57u8 , 243u8 , 229u8 , 8u8 , 234u8 , 231u8 , 72u8 , 230u8 , 139u8 , 47u8 , 63u8 , 181u8 , 17u8 , 2u8 , 220u8 , 231u8 , 104u8 , 237u8 , 185u8 , 143u8 , 165u8 , 253u8 , 188u8 , 76u8 , 147u8 , 12u8 , 170u8 , 26u8 , 74u8 , 200u8 ,]) } # [doc = " The designated SS58 prefix of this chain."] # [doc = ""] # [doc = " This replaces the \"ss58Format\" property declared in the chain spec. Reason is"] # [doc = " that the runtime should know about the prefix in order to make use of it as"] # [doc = " an identifier of the chain."] pub fn ss58_prefix (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u16 >> { :: subxt :: constants :: StaticConstantAddress :: new ("System" , "SS58Prefix" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } } } } pub mod scheduler { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Schedule { pub when : :: core :: primitive :: u32 , pub maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , pub priority : :: core :: primitive :: u8 , pub call : :: std :: boxed :: Box < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: alphanet_runtime :: RuntimeCall , :: subxt :: ext :: sp_core :: H256 > > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Cancel { pub when : :: core :: primitive :: u32 , pub index : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ScheduleNamed { pub id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub when : :: core :: primitive :: u32 , pub maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , pub priority : :: core :: primitive :: u8 , pub call : :: std :: boxed :: Box < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: alphanet_runtime :: RuntimeCall , :: subxt :: ext :: sp_core :: H256 > > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CancelNamed { pub id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ScheduleAfter { pub after : :: core :: primitive :: u32 , pub maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , pub priority : :: core :: primitive :: u8 , pub call : :: std :: boxed :: Box < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: alphanet_runtime :: RuntimeCall , :: subxt :: ext :: sp_core :: H256 > > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ScheduleNamedAfter { pub id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub after : :: core :: primitive :: u32 , pub maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , pub priority : :: core :: primitive :: u8 , pub call : :: std :: boxed :: Box < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: alphanet_runtime :: RuntimeCall , :: subxt :: ext :: sp_core :: H256 > > , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Anonymously schedule a task."] pub fn schedule (& self , when : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: alphanet_runtime :: RuntimeCall , :: subxt :: ext :: sp_core :: H256 > ,) -> :: subxt :: tx :: StaticTxPayload < Schedule > { :: subxt :: tx :: StaticTxPayload :: new ("Scheduler" , "schedule" , Schedule { when , maybe_periodic , priority , call : :: std :: boxed :: Box :: new (call) , } , [139u8 , 35u8 , 232u8 , 131u8 , 178u8 , 109u8 , 81u8 , 114u8 , 47u8 , 171u8 , 110u8 , 228u8 , 170u8 , 158u8 , 80u8 , 209u8 , 141u8 , 145u8 , 240u8 , 241u8 , 102u8 , 55u8 , 21u8 , 57u8 , 47u8 , 210u8 , 32u8 , 218u8 , 121u8 , 47u8 , 14u8 , 76u8 ,]) } # [doc = "Cancel an anonymously scheduled task."] pub fn cancel (& self , when : :: core :: primitive :: u32 , index : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < Cancel > { :: subxt :: tx :: StaticTxPayload :: new ("Scheduler" , "cancel" , Cancel { when , index , } , [81u8 , 251u8 , 234u8 , 17u8 , 214u8 , 75u8 , 19u8 , 59u8 , 19u8 , 30u8 , 89u8 , 74u8 , 6u8 , 216u8 , 238u8 , 165u8 , 7u8 , 19u8 , 153u8 , 253u8 , 161u8 , 103u8 , 178u8 , 227u8 , 152u8 , 180u8 , 80u8 , 156u8 , 82u8 , 126u8 , 132u8 , 120u8 ,]) } # [doc = "Schedule a named task."] pub fn schedule_named (& self , id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , when : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: alphanet_runtime :: RuntimeCall , :: subxt :: ext :: sp_core :: H256 > ,) -> :: subxt :: tx :: StaticTxPayload < ScheduleNamed > { :: subxt :: tx :: StaticTxPayload :: new ("Scheduler" , "schedule_named" , ScheduleNamed { id , when , maybe_periodic , priority , call : :: std :: boxed :: Box :: new (call) , } , [70u8 , 191u8 , 153u8 , 9u8 , 139u8 , 74u8 , 146u8 , 196u8 , 21u8 , 173u8 , 209u8 , 249u8 , 86u8 , 226u8 , 145u8 , 187u8 , 156u8 , 161u8 , 96u8 , 195u8 , 253u8 , 210u8 , 206u8 , 93u8 , 106u8 , 106u8 , 196u8 , 212u8 , 18u8 , 123u8 , 157u8 , 95u8 ,]) } # [doc = "Cancel a named scheduled task."] pub fn cancel_named (& self , id : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: StaticTxPayload < CancelNamed > { :: subxt :: tx :: StaticTxPayload :: new ("Scheduler" , "cancel_named" , CancelNamed { id , } , [42u8 , 232u8 , 92u8 , 167u8 , 113u8 , 136u8 , 7u8 , 215u8 , 88u8 , 117u8 , 74u8 , 26u8 , 225u8 , 230u8 , 244u8 , 106u8 , 150u8 , 112u8 , 46u8 , 228u8 , 96u8 , 252u8 , 78u8 , 126u8 , 39u8 , 207u8 , 36u8 , 110u8 , 83u8 , 62u8 , 84u8 , 241u8 ,]) } # [doc = "Anonymously schedule a task after a delay."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Same as [`schedule`]."] # [doc = "# </weight>"] pub fn schedule_after (& self , after : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: alphanet_runtime :: RuntimeCall , :: subxt :: ext :: sp_core :: H256 > ,) -> :: subxt :: tx :: StaticTxPayload < ScheduleAfter > { :: subxt :: tx :: StaticTxPayload :: new ("Scheduler" , "schedule_after" , ScheduleAfter { after , maybe_periodic , priority , call : :: std :: boxed :: Box :: new (call) , } , [10u8 , 61u8 , 10u8 , 43u8 , 95u8 , 38u8 , 40u8 , 30u8 , 80u8 , 88u8 , 93u8 , 126u8 , 62u8 , 28u8 , 60u8 , 223u8 , 215u8 , 250u8 , 242u8 , 38u8 , 128u8 , 5u8 , 119u8 , 165u8 , 156u8 , 127u8 , 25u8 , 147u8 , 253u8 , 93u8 , 213u8 , 137u8 ,]) } # [doc = "Schedule a named task after a delay."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Same as [`schedule_named`](Self::schedule_named)."] # [doc = "# </weight>"] pub fn schedule_named_after (& self , id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , after : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: alphanet_runtime :: RuntimeCall , :: subxt :: ext :: sp_core :: H256 > ,) -> :: subxt :: tx :: StaticTxPayload < ScheduleNamedAfter > { :: subxt :: tx :: StaticTxPayload :: new ("Scheduler" , "schedule_named_after" , ScheduleNamedAfter { id , after , maybe_periodic , priority , call : :: std :: boxed :: Box :: new (call) , } , [128u8 , 116u8 , 103u8 , 170u8 , 41u8 , 17u8 , 153u8 , 111u8 , 201u8 , 122u8 , 112u8 , 112u8 , 19u8 , 146u8 , 203u8 , 56u8 , 129u8 , 174u8 , 91u8 , 212u8 , 50u8 , 90u8 , 206u8 , 93u8 , 22u8 , 246u8 , 195u8 , 103u8 , 80u8 , 230u8 , 232u8 , 218u8 ,]) } } } # [doc = "Events type."] pub type Event = runtime_types :: pallet_scheduler :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Scheduled some task."] pub struct Scheduled { pub when : :: core :: primitive :: u32 , pub index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for Scheduled { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "Scheduled" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Canceled some task."] pub struct Canceled { pub when : :: core :: primitive :: u32 , pub index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for Canceled { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "Canceled" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Dispatched some task."] pub struct Dispatched { pub task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , pub id : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , pub result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: events :: StaticEvent for Dispatched { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "Dispatched" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "The call for the provided hash was not found so the task has been aborted."] pub struct CallLookupFailed { pub task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , pub id : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , pub error : runtime_types :: frame_support :: traits :: schedule :: LookupError , } impl :: subxt :: events :: StaticEvent for CallLookupFailed { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "CallLookupFailed" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Items to be executed, indexed by the block number that they should be executed on."] pub fn agenda (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < :: core :: option :: Option < runtime_types :: pallet_scheduler :: ScheduledV3 < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: alphanet_runtime :: RuntimeCall , :: subxt :: ext :: sp_core :: H256 > , :: core :: primitive :: u32 , runtime_types :: alphanet_runtime :: OriginCaller , :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Scheduler" , "Agenda" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [229u8 , 57u8 , 34u8 , 100u8 , 185u8 , 238u8 , 65u8 , 160u8 , 129u8 , 202u8 , 242u8 , 9u8 , 169u8 , 69u8 , 133u8 , 101u8 , 54u8 , 108u8 , 32u8 , 81u8 , 51u8 , 81u8 , 29u8 , 182u8 , 26u8 , 94u8 , 147u8 , 98u8 , 69u8 , 200u8 , 96u8 , 76u8 ,]) } # [doc = " Items to be executed, indexed by the block number that they should be executed on."] pub fn agenda_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < :: core :: option :: Option < runtime_types :: pallet_scheduler :: ScheduledV3 < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: alphanet_runtime :: RuntimeCall , :: subxt :: ext :: sp_core :: H256 > , :: core :: primitive :: u32 , runtime_types :: alphanet_runtime :: OriginCaller , :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Scheduler" , "Agenda" , Vec :: new () , [229u8 , 57u8 , 34u8 , 100u8 , 185u8 , 238u8 , 65u8 , 160u8 , 129u8 , 202u8 , 242u8 , 9u8 , 169u8 , 69u8 , 133u8 , 101u8 , 54u8 , 108u8 , 32u8 , 81u8 , 51u8 , 81u8 , 29u8 , 182u8 , 26u8 , 94u8 , 147u8 , 98u8 , 69u8 , 200u8 , 96u8 , 76u8 ,]) } # [doc = " Lookup from identity to the block number and index of the task."] pub fn lookup (& self , _0 : impl :: std :: borrow :: Borrow < [:: core :: primitive :: u8] > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Scheduler" , "Lookup" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [56u8 , 105u8 , 156u8 , 110u8 , 251u8 , 141u8 , 219u8 , 56u8 , 131u8 , 57u8 , 180u8 , 33u8 , 48u8 , 30u8 , 193u8 , 194u8 , 169u8 , 182u8 , 168u8 , 43u8 , 36u8 , 202u8 , 222u8 , 182u8 , 41u8 , 216u8 , 222u8 , 1u8 , 72u8 , 165u8 , 62u8 , 166u8 ,]) } # [doc = " Lookup from identity to the block number and index of the task."] pub fn lookup_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Scheduler" , "Lookup" , Vec :: new () , [56u8 , 105u8 , 156u8 , 110u8 , 251u8 , 141u8 , 219u8 , 56u8 , 131u8 , 57u8 , 180u8 , 33u8 , 48u8 , 30u8 , 193u8 , 194u8 , 169u8 , 182u8 , 168u8 , 43u8 , 36u8 , 202u8 , 222u8 , 182u8 , 41u8 , 216u8 , 222u8 , 1u8 , 72u8 , 165u8 , 62u8 , 166u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The maximum weight that may be scheduled per block for any dispatchables of less"] # [doc = " priority than `schedule::HARD_DEADLINE`."] pub fn maximum_weight (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_weights :: weight_v2 :: Weight >> { :: subxt :: constants :: StaticConstantAddress :: new ("Scheduler" , "MaximumWeight" , [206u8 , 61u8 , 253u8 , 247u8 , 163u8 , 40u8 , 161u8 , 52u8 , 134u8 , 140u8 , 206u8 , 83u8 , 44u8 , 166u8 , 226u8 , 115u8 , 181u8 , 14u8 , 227u8 , 130u8 , 210u8 , 32u8 , 85u8 , 29u8 , 230u8 , 97u8 , 130u8 , 165u8 , 147u8 , 134u8 , 106u8 , 76u8 ,]) } # [doc = " The maximum number of scheduled calls in the queue for a single block."] # [doc = " Not strictly enforced, but used for weight estimation."] pub fn max_scheduled_per_block (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Scheduler" , "MaxScheduledPerBlock" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod babe { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ReportEquivocation { pub equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_consensus_slots :: EquivocationProof < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , runtime_types :: sp_consensus_babe :: app :: Public > > , pub key_owner_proof : runtime_types :: sp_session :: MembershipProof , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ReportEquivocationUnsigned { pub equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_consensus_slots :: EquivocationProof < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , runtime_types :: sp_consensus_babe :: app :: Public > > , pub key_owner_proof : runtime_types :: sp_session :: MembershipProof , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct PlanConfigChange { pub config : runtime_types :: sp_consensus_babe :: digests :: NextConfigDescriptor , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Report authority equivocation/misbehavior. This method will verify"] # [doc = "the equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence will"] # [doc = "be reported."] pub fn report_equivocation (& self , equivocation_proof : runtime_types :: sp_consensus_slots :: EquivocationProof < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , runtime_types :: sp_consensus_babe :: app :: Public > , key_owner_proof : runtime_types :: sp_session :: MembershipProof ,) -> :: subxt :: tx :: StaticTxPayload < ReportEquivocation > { :: subxt :: tx :: StaticTxPayload :: new ("Babe" , "report_equivocation" , ReportEquivocation { equivocation_proof : :: std :: boxed :: Box :: new (equivocation_proof) , key_owner_proof , } , [177u8 , 237u8 , 107u8 , 138u8 , 237u8 , 233u8 , 30u8 , 195u8 , 112u8 , 176u8 , 185u8 , 113u8 , 157u8 , 221u8 , 134u8 , 151u8 , 62u8 , 151u8 , 64u8 , 164u8 , 254u8 , 112u8 , 2u8 , 94u8 , 175u8 , 79u8 , 160u8 , 3u8 , 72u8 , 145u8 , 244u8 , 137u8 ,]) } # [doc = "Report authority equivocation/misbehavior. This method will verify"] # [doc = "the equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence will"] # [doc = "be reported."] # [doc = "This extrinsic must be called unsigned and it is expected that only"] # [doc = "block authors will call it (validated in `ValidateUnsigned`), as such"] # [doc = "if the block author is defined it will be defined as the equivocation"] # [doc = "reporter."] pub fn report_equivocation_unsigned (& self , equivocation_proof : runtime_types :: sp_consensus_slots :: EquivocationProof < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , runtime_types :: sp_consensus_babe :: app :: Public > , key_owner_proof : runtime_types :: sp_session :: MembershipProof ,) -> :: subxt :: tx :: StaticTxPayload < ReportEquivocationUnsigned > { :: subxt :: tx :: StaticTxPayload :: new ("Babe" , "report_equivocation_unsigned" , ReportEquivocationUnsigned { equivocation_proof : :: std :: boxed :: Box :: new (equivocation_proof) , key_owner_proof , } , [56u8 , 103u8 , 238u8 , 118u8 , 61u8 , 192u8 , 222u8 , 87u8 , 254u8 , 24u8 , 138u8 , 219u8 , 210u8 , 85u8 , 201u8 , 147u8 , 128u8 , 49u8 , 199u8 , 144u8 , 46u8 , 158u8 , 163u8 , 31u8 , 101u8 , 224u8 , 72u8 , 98u8 , 68u8 , 120u8 , 215u8 , 19u8 ,]) } # [doc = "Plan an epoch config change. The epoch config change is recorded and will be enacted on"] # [doc = "the next call to `enact_epoch_change`. The config will be activated one epoch after."] # [doc = "Multiple calls to this method will replace any existing planned config change that had"] # [doc = "not been enacted yet."] pub fn plan_config_change (& self , config : runtime_types :: sp_consensus_babe :: digests :: NextConfigDescriptor ,) -> :: subxt :: tx :: StaticTxPayload < PlanConfigChange > { :: subxt :: tx :: StaticTxPayload :: new ("Babe" , "plan_config_change" , PlanConfigChange { config , } , [229u8 , 157u8 , 41u8 , 58u8 , 56u8 , 4u8 , 52u8 , 107u8 , 104u8 , 20u8 , 42u8 , 110u8 , 1u8 , 17u8 , 45u8 , 196u8 , 30u8 , 135u8 , 63u8 , 46u8 , 40u8 , 137u8 , 209u8 , 37u8 , 24u8 , 108u8 , 251u8 , 189u8 , 77u8 , 208u8 , 74u8 , 32u8 ,]) } } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Current epoch index."] pub fn epoch_index (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u64 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "EpochIndex" , vec ! [] , [51u8 , 27u8 , 91u8 , 156u8 , 118u8 , 99u8 , 46u8 , 219u8 , 190u8 , 147u8 , 205u8 , 23u8 , 106u8 , 169u8 , 121u8 , 218u8 , 208u8 , 235u8 , 135u8 , 127u8 , 243u8 , 41u8 , 55u8 , 243u8 , 235u8 , 122u8 , 57u8 , 86u8 , 37u8 , 90u8 , 208u8 , 71u8 ,]) } # [doc = " Current epoch authorities."] pub fn authorities (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: weak_bounded_vec :: WeakBoundedVec < (runtime_types :: sp_consensus_babe :: app :: Public , :: core :: primitive :: u64 ,) > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "Authorities" , vec ! [] , [61u8 , 8u8 , 133u8 , 111u8 , 169u8 , 120u8 , 0u8 , 213u8 , 31u8 , 159u8 , 204u8 , 212u8 , 18u8 , 205u8 , 93u8 , 84u8 , 140u8 , 108u8 , 136u8 , 209u8 , 234u8 , 107u8 , 145u8 , 9u8 , 204u8 , 224u8 , 105u8 , 9u8 , 238u8 , 241u8 , 65u8 , 30u8 ,]) } # [doc = " The slot at which the first epoch actually started. This is 0"] # [doc = " until the first block of the chain."] pub fn genesis_slot (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_consensus_slots :: Slot > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "GenesisSlot" , vec ! [] , [234u8 , 127u8 , 243u8 , 100u8 , 124u8 , 160u8 , 66u8 , 248u8 , 48u8 , 218u8 , 61u8 , 52u8 , 54u8 , 142u8 , 158u8 , 77u8 , 32u8 , 63u8 , 156u8 , 39u8 , 94u8 , 255u8 , 192u8 , 238u8 , 170u8 , 118u8 , 58u8 , 42u8 , 199u8 , 61u8 , 199u8 , 77u8 ,]) } # [doc = " Current slot number."] pub fn current_slot (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_consensus_slots :: Slot > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "CurrentSlot" , vec ! [] , [139u8 , 237u8 , 185u8 , 137u8 , 251u8 , 179u8 , 69u8 , 167u8 , 133u8 , 168u8 , 204u8 , 64u8 , 178u8 , 123u8 , 92u8 , 250u8 , 119u8 , 190u8 , 208u8 , 178u8 , 208u8 , 176u8 , 124u8 , 187u8 , 74u8 , 165u8 , 33u8 , 78u8 , 161u8 , 206u8 , 8u8 , 108u8 ,]) } # [doc = " The epoch randomness for the *current* epoch."] # [doc = ""] # [doc = " # Security"] # [doc = ""] # [doc = " This MUST NOT be used for gambling, as it can be influenced by a"] # [doc = " malicious validator in the short term. It MAY be used in many"] # [doc = " cryptographic protocols, however, so long as one remembers that this"] # [doc = " (like everything else on-chain) it is public. For example, it can be"] # [doc = " used where a number is needed that cannot have been chosen by an"] # [doc = " adversary, for purposes such as public-coin zero-knowledge proofs."] pub fn randomness (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < [:: core :: primitive :: u8 ; 32usize] > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "Randomness" , vec ! [] , [191u8 , 197u8 , 25u8 , 164u8 , 104u8 , 248u8 , 247u8 , 193u8 , 244u8 , 60u8 , 181u8 , 195u8 , 248u8 , 90u8 , 41u8 , 199u8 , 82u8 , 123u8 , 72u8 , 126u8 , 18u8 , 17u8 , 128u8 , 215u8 , 34u8 , 251u8 , 227u8 , 70u8 , 166u8 , 10u8 , 104u8 , 140u8 ,]) } # [doc = " Pending epoch configuration change that will be applied when the next epoch is enacted."] pub fn pending_epoch_config_change (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_consensus_babe :: digests :: NextConfigDescriptor > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "PendingEpochConfigChange" , vec ! [] , [4u8 , 201u8 , 0u8 , 204u8 , 47u8 , 246u8 , 4u8 , 185u8 , 163u8 , 242u8 , 242u8 , 152u8 , 29u8 , 222u8 , 71u8 , 127u8 , 49u8 , 203u8 , 206u8 , 180u8 , 244u8 , 50u8 , 80u8 , 49u8 , 199u8 , 97u8 , 3u8 , 170u8 , 156u8 , 139u8 , 106u8 , 113u8 ,]) } # [doc = " Next epoch randomness."] pub fn next_randomness (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < [:: core :: primitive :: u8 ; 32usize] > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "NextRandomness" , vec ! [] , [185u8 , 98u8 , 45u8 , 109u8 , 253u8 , 38u8 , 238u8 , 221u8 , 240u8 , 29u8 , 38u8 , 107u8 , 118u8 , 117u8 , 131u8 , 115u8 , 21u8 , 255u8 , 203u8 , 81u8 , 243u8 , 251u8 , 91u8 , 60u8 , 163u8 , 202u8 , 125u8 , 193u8 , 173u8 , 234u8 , 166u8 , 92u8 ,]) } # [doc = " Next epoch authorities."] pub fn next_authorities (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: weak_bounded_vec :: WeakBoundedVec < (runtime_types :: sp_consensus_babe :: app :: Public , :: core :: primitive :: u64 ,) > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "NextAuthorities" , vec ! [] , [201u8 , 193u8 , 164u8 , 18u8 , 155u8 , 253u8 , 124u8 , 163u8 , 143u8 , 73u8 , 212u8 , 20u8 , 241u8 , 108u8 , 110u8 , 5u8 , 171u8 , 66u8 , 224u8 , 208u8 , 10u8 , 65u8 , 148u8 , 164u8 , 1u8 , 12u8 , 216u8 , 83u8 , 20u8 , 226u8 , 254u8 , 183u8 ,]) } # [doc = " Randomness under construction."] # [doc = ""] # [doc = " We make a trade-off between storage accesses and list length."] # [doc = " We store the under-construction randomness in segments of up to"] # [doc = " `UNDER_CONSTRUCTION_SEGMENT_LENGTH`."] # [doc = ""] # [doc = " Once a segment reaches this length, we begin the next one."] # [doc = " We reset all segments and return to `0` at the beginning of every"] # [doc = " epoch."] pub fn segment_index (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "SegmentIndex" , vec ! [] , [128u8 , 45u8 , 87u8 , 58u8 , 174u8 , 152u8 , 241u8 , 156u8 , 56u8 , 192u8 , 19u8 , 45u8 , 75u8 , 160u8 , 35u8 , 253u8 , 145u8 , 11u8 , 178u8 , 81u8 , 114u8 , 117u8 , 112u8 , 107u8 , 163u8 , 208u8 , 240u8 , 151u8 , 102u8 , 176u8 , 246u8 , 5u8 ,]) } # [doc = " TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay."] pub fn under_construction (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < [:: core :: primitive :: u8 ; 32usize] > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "UnderConstruction" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [180u8 , 4u8 , 149u8 , 245u8 , 231u8 , 92u8 , 99u8 , 170u8 , 254u8 , 172u8 , 182u8 , 3u8 , 152u8 , 156u8 , 132u8 , 196u8 , 140u8 , 97u8 , 7u8 , 84u8 , 220u8 , 89u8 , 195u8 , 177u8 , 235u8 , 51u8 , 98u8 , 144u8 , 73u8 , 238u8 , 59u8 , 164u8 ,]) } # [doc = " TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay."] pub fn under_construction_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < [:: core :: primitive :: u8 ; 32usize] > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "UnderConstruction" , Vec :: new () , [180u8 , 4u8 , 149u8 , 245u8 , 231u8 , 92u8 , 99u8 , 170u8 , 254u8 , 172u8 , 182u8 , 3u8 , 152u8 , 156u8 , 132u8 , 196u8 , 140u8 , 97u8 , 7u8 , 84u8 , 220u8 , 89u8 , 195u8 , 177u8 , 235u8 , 51u8 , 98u8 , 144u8 , 73u8 , 238u8 , 59u8 , 164u8 ,]) } # [doc = " Temporary value (cleared at block finalization) which is `Some`"] # [doc = " if per-block initialization has already been called for current block."] pub fn initialized (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: option :: Option < runtime_types :: sp_consensus_babe :: digests :: PreDigest > > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "Initialized" , vec ! [] , [142u8 , 101u8 , 250u8 , 113u8 , 93u8 , 201u8 , 157u8 , 18u8 , 166u8 , 153u8 , 59u8 , 197u8 , 107u8 , 247u8 , 124u8 , 110u8 , 202u8 , 67u8 , 62u8 , 57u8 , 186u8 , 134u8 , 49u8 , 182u8 , 149u8 , 44u8 , 255u8 , 85u8 , 87u8 , 177u8 , 149u8 , 121u8 ,]) } # [doc = " This field should always be populated during block processing unless"] # [doc = " secondary plain slots are enabled (which don't contain a VRF output)."] # [doc = ""] # [doc = " It is set in `on_finalize`, before it will contain the value from the last block."] pub fn author_vrf_randomness (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "AuthorVrfRandomness" , vec ! [] , [66u8 , 235u8 , 74u8 , 252u8 , 222u8 , 135u8 , 19u8 , 28u8 , 74u8 , 191u8 , 170u8 , 197u8 , 207u8 , 127u8 , 77u8 , 121u8 , 138u8 , 138u8 , 110u8 , 187u8 , 34u8 , 14u8 , 230u8 , 43u8 , 241u8 , 241u8 , 63u8 , 163u8 , 53u8 , 179u8 , 250u8 , 247u8 ,]) } # [doc = " The block numbers when the last and current epoch have started, respectively `N-1` and"] # [doc = " `N`."] # [doc = " NOTE: We track this is in order to annotate the block number when a given pool of"] # [doc = " entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in"] # [doc = " slots, which may be skipped, the block numbers may not line up with the slot numbers."] pub fn epoch_start (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "EpochStart" , vec ! [] , [196u8 , 39u8 , 241u8 , 20u8 , 150u8 , 180u8 , 136u8 , 4u8 , 195u8 , 205u8 , 218u8 , 10u8 , 130u8 , 131u8 , 168u8 , 243u8 , 207u8 , 249u8 , 58u8 , 195u8 , 177u8 , 119u8 , 110u8 , 243u8 , 241u8 , 3u8 , 245u8 , 56u8 , 157u8 , 5u8 , 68u8 , 60u8 ,]) } # [doc = " How late the current block is compared to its parent."] # [doc = ""] # [doc = " This entry is populated as part of block execution and is cleaned up"] # [doc = " on block finalization. Querying this storage entry outside of block"] # [doc = " execution context should always yield zero."] pub fn lateness (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "Lateness" , vec ! [] , [229u8 , 230u8 , 224u8 , 89u8 , 49u8 , 213u8 , 198u8 , 236u8 , 144u8 , 56u8 , 193u8 , 234u8 , 62u8 , 242u8 , 191u8 , 199u8 , 105u8 , 131u8 , 74u8 , 63u8 , 75u8 , 1u8 , 210u8 , 49u8 , 3u8 , 128u8 , 18u8 , 77u8 , 219u8 , 146u8 , 60u8 , 88u8 ,]) } # [doc = " The configuration for the current epoch. Should never be `None` as it is initialized in"] # [doc = " genesis."] pub fn epoch_config (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_consensus_babe :: BabeEpochConfiguration > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "EpochConfig" , vec ! [] , [41u8 , 118u8 , 141u8 , 244u8 , 72u8 , 17u8 , 125u8 , 203u8 , 43u8 , 153u8 , 203u8 , 119u8 , 117u8 , 223u8 , 123u8 , 133u8 , 73u8 , 235u8 , 130u8 , 21u8 , 160u8 , 167u8 , 16u8 , 173u8 , 177u8 , 35u8 , 117u8 , 97u8 , 149u8 , 49u8 , 220u8 , 24u8 ,]) } # [doc = " The configuration for the next epoch, `None` if the config will not change"] # [doc = " (you can fallback to `EpochConfig` instead in that case)."] pub fn next_epoch_config (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_consensus_babe :: BabeEpochConfiguration > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Babe" , "NextEpochConfig" , vec ! [] , [111u8 , 182u8 , 144u8 , 180u8 , 92u8 , 146u8 , 102u8 , 249u8 , 196u8 , 229u8 , 226u8 , 30u8 , 25u8 , 198u8 , 133u8 , 9u8 , 136u8 , 95u8 , 11u8 , 151u8 , 139u8 , 156u8 , 105u8 , 228u8 , 181u8 , 12u8 , 175u8 , 148u8 , 174u8 , 33u8 , 233u8 , 228u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The amount of time, in slots, that each epoch should last."] # [doc = " NOTE: Currently it is not possible to change the epoch duration after"] # [doc = " the chain has started. Attempting to do so will brick block production."] pub fn epoch_duration (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u64 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Babe" , "EpochDuration" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " The expected average block time at which BABE should be creating"] # [doc = " blocks. Since BABE is probabilistic it is not trivial to figure out"] # [doc = " what the expected average block time should be based on the slot"] # [doc = " duration and the security parameter `c` (where `1 - c` represents"] # [doc = " the probability of a slot being empty)."] pub fn expected_block_time (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u64 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Babe" , "ExpectedBlockTime" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Max number of authorities allowed"] pub fn max_authorities (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Babe" , "MaxAuthorities" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod timestamp { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Set { # [codec (compact)] pub now : :: core :: primitive :: u64 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Set the current time."] # [doc = ""] # [doc = "This call should be invoked exactly once per block. It will panic at the finalization"] # [doc = "phase, if this call hasn't been invoked by that time."] # [doc = ""] # [doc = "The timestamp should be greater than the previous one by the amount specified by"] # [doc = "`MinimumPeriod`."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Inherent`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"] # [doc = "- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in"] # [doc = "  `on_finalize`)"] # [doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."] # [doc = "# </weight>"] pub fn set (& self , now : :: core :: primitive :: u64 ,) -> :: subxt :: tx :: StaticTxPayload < Set > { :: subxt :: tx :: StaticTxPayload :: new ("Timestamp" , "set" , Set { now , } , [6u8 , 97u8 , 172u8 , 236u8 , 118u8 , 238u8 , 228u8 , 114u8 , 15u8 , 115u8 , 102u8 , 85u8 , 66u8 , 151u8 , 16u8 , 33u8 , 187u8 , 17u8 , 166u8 , 88u8 , 127u8 , 214u8 , 182u8 , 51u8 , 168u8 , 88u8 , 43u8 , 101u8 , 185u8 , 8u8 , 1u8 , 28u8 ,]) } } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Current time for the current block."] pub fn now (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u64 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Timestamp" , "Now" , vec ! [] , [148u8 , 53u8 , 50u8 , 54u8 , 13u8 , 161u8 , 57u8 , 150u8 , 16u8 , 83u8 , 144u8 , 221u8 , 59u8 , 75u8 , 158u8 , 130u8 , 39u8 , 123u8 , 106u8 , 134u8 , 202u8 , 185u8 , 83u8 , 85u8 , 60u8 , 41u8 , 120u8 , 96u8 , 210u8 , 34u8 , 2u8 , 250u8 ,]) } # [doc = " Did the timestamp get updated in this block?"] pub fn did_update (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: bool > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Timestamp" , "DidUpdate" , vec ! [] , [70u8 , 13u8 , 92u8 , 186u8 , 80u8 , 151u8 , 167u8 , 90u8 , 158u8 , 232u8 , 175u8 , 13u8 , 103u8 , 135u8 , 2u8 , 78u8 , 16u8 , 6u8 , 39u8 , 158u8 , 167u8 , 85u8 , 27u8 , 47u8 , 122u8 , 73u8 , 127u8 , 26u8 , 35u8 , 168u8 , 72u8 , 204u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The minimum period between blocks. Beware that this is different to the *expected*"] # [doc = " period that the block production apparatus provides. Your chosen consensus system will"] # [doc = " generally work with this to determine a sensible block time. e.g. For Aura, it will be"] # [doc = " double this period on default settings."] pub fn minimum_period (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u64 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Timestamp" , "MinimumPeriod" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } } } } pub mod balances { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Transfer { pub dest : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] pub value : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetBalance { pub who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] pub new_free : :: core :: primitive :: u128 , # [codec (compact)] pub new_reserved : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ForceTransfer { pub source : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub dest : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] pub value : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct TransferKeepAlive { pub dest : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] pub value : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct TransferAll { pub dest : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub keep_alive : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ForceUnreserve { pub who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub amount : :: core :: primitive :: u128 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Transfer some liquid free balance to another account."] # [doc = ""] # [doc = "`transfer` will set the `FreeBalance` of the sender and receiver."] # [doc = "If the sender's account is below the existential deposit as a result"] # [doc = "of the transfer, the account will be reaped."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the transactor."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Dependent on arguments but not critical, given proper implementations for input config"] # [doc = "  types. See related functions below."] # [doc = "- It contains a limited number of reads and writes internally and no complex"] # [doc = "  computation."] # [doc = ""] # [doc = "Related functions:"] # [doc = ""] # [doc = "  - `ensure_can_withdraw` is always called internally but has a bounded complexity."] # [doc = "  - Transferring balances to accounts that did not exist before will cause"] # [doc = "    `T::OnNewAccount::on_new_account` to be called."] # [doc = "  - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`."] # [doc = "  - `transfer_keep_alive` works the same way as `transfer`, but has an additional check"] # [doc = "    that the transfer will not kill the origin account."] # [doc = "---------------------------------"] # [doc = "- Origin account is already in memory, so no DB operations for them."] # [doc = "# </weight>"] pub fn transfer (& self , dest : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , value : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < Transfer > { :: subxt :: tx :: StaticTxPayload :: new ("Balances" , "transfer" , Transfer { dest , value , } , [111u8 , 222u8 , 32u8 , 56u8 , 171u8 , 77u8 , 252u8 , 29u8 , 194u8 , 155u8 , 200u8 , 192u8 , 198u8 , 81u8 , 23u8 , 115u8 , 236u8 , 91u8 , 218u8 , 114u8 , 107u8 , 141u8 , 138u8 , 100u8 , 237u8 , 21u8 , 58u8 , 172u8 , 3u8 , 20u8 , 216u8 , 38u8 ,]) } # [doc = "Set the balances of a given account."] # [doc = ""] # [doc = "This will alter `FreeBalance` and `ReservedBalance` in storage. it will"] # [doc = "also alter the total issuance of the system (`TotalIssuance`) appropriately."] # [doc = "If the new free or reserved balance is below the existential deposit,"] # [doc = "it will reset the account nonce (`frame_system::AccountNonce`)."] # [doc = ""] # [doc = "The dispatch origin for this call is `root`."] pub fn set_balance (& self , who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , new_free : :: core :: primitive :: u128 , new_reserved : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < SetBalance > { :: subxt :: tx :: StaticTxPayload :: new ("Balances" , "set_balance" , SetBalance { who , new_free , new_reserved , } , [234u8 , 215u8 , 97u8 , 98u8 , 243u8 , 199u8 , 57u8 , 76u8 , 59u8 , 161u8 , 118u8 , 207u8 , 34u8 , 197u8 , 198u8 , 61u8 , 231u8 , 210u8 , 169u8 , 235u8 , 150u8 , 137u8 , 173u8 , 49u8 , 28u8 , 77u8 , 84u8 , 149u8 , 143u8 , 210u8 , 139u8 , 193u8 ,]) } # [doc = "Exactly as `transfer`, except the origin must be root and the source account may be"] # [doc = "specified."] # [doc = "# <weight>"] # [doc = "- Same as transfer, but additional read and write because the source account is not"] # [doc = "  assumed to be in the overlay."] # [doc = "# </weight>"] pub fn force_transfer (& self , source : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , dest : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , value : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < ForceTransfer > { :: subxt :: tx :: StaticTxPayload :: new ("Balances" , "force_transfer" , ForceTransfer { source , dest , value , } , [79u8 , 174u8 , 212u8 , 108u8 , 184u8 , 33u8 , 170u8 , 29u8 , 232u8 , 254u8 , 195u8 , 218u8 , 221u8 , 134u8 , 57u8 , 99u8 , 6u8 , 70u8 , 181u8 , 227u8 , 56u8 , 239u8 , 243u8 , 158u8 , 157u8 , 245u8 , 36u8 , 162u8 , 11u8 , 237u8 , 147u8 , 15u8 ,]) } # [doc = "Same as the [`transfer`] call, but with a check that the transfer will not kill the"] # [doc = "origin account."] # [doc = ""] # [doc = "99% of the time you want [`transfer`] instead."] # [doc = ""] # [doc = "[`transfer`]: struct.Pallet.html#method.transfer"] pub fn transfer_keep_alive (& self , dest : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , value : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < TransferKeepAlive > { :: subxt :: tx :: StaticTxPayload :: new ("Balances" , "transfer_keep_alive" , TransferKeepAlive { dest , value , } , [112u8 , 179u8 , 75u8 , 168u8 , 193u8 , 221u8 , 9u8 , 82u8 , 190u8 , 113u8 , 253u8 , 13u8 , 130u8 , 134u8 , 170u8 , 216u8 , 136u8 , 111u8 , 242u8 , 220u8 , 202u8 , 112u8 , 47u8 , 79u8 , 73u8 , 244u8 , 226u8 , 59u8 , 240u8 , 188u8 , 210u8 , 208u8 ,]) } # [doc = "Transfer the entire transferable balance from the caller account."] # [doc = ""] # [doc = "NOTE: This function only attempts to transfer _transferable_ balances. This means that"] # [doc = "any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be"] # [doc = "transferred by this function. To ensure that this function results in a killed account,"] # [doc = "you might need to prepare the account by removing any reference counters, storage"] # [doc = "deposits, etc..."] # [doc = ""] # [doc = "The dispatch origin of this call must be Signed."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all"] # [doc = "  of the funds the account has, causing the sender account to be killed (false), or"] # [doc = "  transfer everything except at least the existential deposit, which will guarantee to"] # [doc = "  keep the sender account alive (true). # <weight>"] # [doc = "- O(1). Just like transfer, but reading the user's transferable balance first."] # [doc = "  #</weight>"] pub fn transfer_all (& self , dest : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , keep_alive : :: core :: primitive :: bool ,) -> :: subxt :: tx :: StaticTxPayload < TransferAll > { :: subxt :: tx :: StaticTxPayload :: new ("Balances" , "transfer_all" , TransferAll { dest , keep_alive , } , [46u8 , 129u8 , 29u8 , 177u8 , 221u8 , 107u8 , 245u8 , 69u8 , 238u8 , 126u8 , 145u8 , 26u8 , 219u8 , 208u8 , 14u8 , 80u8 , 149u8 , 1u8 , 214u8 , 63u8 , 67u8 , 201u8 , 144u8 , 45u8 , 129u8 , 145u8 , 174u8 , 71u8 , 238u8 , 113u8 , 208u8 , 34u8 ,]) } # [doc = "Unreserve some balance from a user by force."] # [doc = ""] # [doc = "Can only be called by ROOT."] pub fn force_unreserve (& self , who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , amount : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < ForceUnreserve > { :: subxt :: tx :: StaticTxPayload :: new ("Balances" , "force_unreserve" , ForceUnreserve { who , amount , } , [160u8 , 146u8 , 137u8 , 76u8 , 157u8 , 187u8 , 66u8 , 148u8 , 207u8 , 76u8 , 32u8 , 254u8 , 82u8 , 215u8 , 35u8 , 161u8 , 213u8 , 52u8 , 32u8 , 98u8 , 102u8 , 106u8 , 234u8 , 123u8 , 6u8 , 175u8 , 184u8 , 188u8 , 174u8 , 106u8 , 176u8 , 78u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_balances :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An account was created with some free balance."] pub struct Endowed { pub account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub free_balance : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Endowed { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Endowed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An account was removed whose balance was non-zero but below ExistentialDeposit,"] # [doc = "resulting in an outright loss."] pub struct DustLost { pub account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for DustLost { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "DustLost" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Transfer succeeded."] pub struct Transfer { pub from : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub to : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Transfer { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Transfer" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A balance was set by root."] pub struct BalanceSet { pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub free : :: core :: primitive :: u128 , pub reserved : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for BalanceSet { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "BalanceSet" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some balance was reserved (moved from free to reserved)."] pub struct Reserved { pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Reserved { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Reserved" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some balance was unreserved (moved from reserved to free)."] pub struct Unreserved { pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Unreserved { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Unreserved" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some balance was moved from the reserve of the first account to the second account."] # [doc = "Final argument indicates the destination balance type."] pub struct ReserveRepatriated { pub from : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub to : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , pub destination_status : runtime_types :: frame_support :: traits :: tokens :: misc :: BalanceStatus , } impl :: subxt :: events :: StaticEvent for ReserveRepatriated { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "ReserveRepatriated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some amount was deposited (e.g. for transaction fees)."] pub struct Deposit { pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Deposit { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Deposit" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some amount was withdrawn from the account (e.g. for transaction fees)."] pub struct Withdraw { pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Withdraw { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Withdraw" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some amount was removed from the account (e.g. for misbehavior)."] pub struct Slashed { pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Slashed { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Slashed" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The total units issued in the system."] pub fn total_issuance (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Balances" , "TotalIssuance" , vec ! [] , [1u8 , 206u8 , 252u8 , 237u8 , 6u8 , 30u8 , 20u8 , 232u8 , 164u8 , 115u8 , 51u8 , 156u8 , 156u8 , 206u8 , 241u8 , 187u8 , 44u8 , 84u8 , 25u8 , 164u8 , 235u8 , 20u8 , 86u8 , 242u8 , 124u8 , 23u8 , 28u8 , 140u8 , 26u8 , 73u8 , 231u8 , 51u8 ,]) } # [doc = " The Balances pallet example of storing the balance of an account."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " You can also store the balance of an account in the `System` pallet."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "   type AccountStore = System"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " But this comes with tradeoffs, storing account balances in the system pallet stores"] # [doc = " `frame_system` data alongside the account data contrary to storing account balances in the"] # [doc = " `Balances` pallet, which uses a `StorageMap` to store balances data only."] # [doc = " NOTE: This is only used in the case that this pallet is used to store balances."] pub fn account (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_balances :: AccountData < :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Balances" , "Account" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [246u8 , 154u8 , 253u8 , 71u8 , 192u8 , 192u8 , 192u8 , 236u8 , 128u8 , 80u8 , 40u8 , 252u8 , 201u8 , 43u8 , 3u8 , 131u8 , 19u8 , 49u8 , 141u8 , 240u8 , 172u8 , 217u8 , 215u8 , 109u8 , 87u8 , 135u8 , 248u8 , 57u8 , 98u8 , 185u8 , 22u8 , 4u8 ,]) } # [doc = " The Balances pallet example of storing the balance of an account."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " You can also store the balance of an account in the `System` pallet."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "   type AccountStore = System"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " But this comes with tradeoffs, storing account balances in the system pallet stores"] # [doc = " `frame_system` data alongside the account data contrary to storing account balances in the"] # [doc = " `Balances` pallet, which uses a `StorageMap` to store balances data only."] # [doc = " NOTE: This is only used in the case that this pallet is used to store balances."] pub fn account_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_balances :: AccountData < :: core :: primitive :: u128 > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Balances" , "Account" , Vec :: new () , [246u8 , 154u8 , 253u8 , 71u8 , 192u8 , 192u8 , 192u8 , 236u8 , 128u8 , 80u8 , 40u8 , 252u8 , 201u8 , 43u8 , 3u8 , 131u8 , 19u8 , 49u8 , 141u8 , 240u8 , 172u8 , 217u8 , 215u8 , 109u8 , 87u8 , 135u8 , 248u8 , 57u8 , 98u8 , 185u8 , 22u8 , 4u8 ,]) } # [doc = " Any liquidity locks on some account balances."] # [doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."] pub fn locks (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: pallet_balances :: BalanceLock < :: core :: primitive :: u128 > > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Balances" , "Locks" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [216u8 , 253u8 , 87u8 , 73u8 , 24u8 , 218u8 , 35u8 , 0u8 , 244u8 , 134u8 , 195u8 , 58u8 , 255u8 , 64u8 , 153u8 , 212u8 , 210u8 , 232u8 , 4u8 , 122u8 , 90u8 , 212u8 , 136u8 , 14u8 , 127u8 , 232u8 , 8u8 , 192u8 , 40u8 , 233u8 , 18u8 , 250u8 ,]) } # [doc = " Any liquidity locks on some account balances."] # [doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."] pub fn locks_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: pallet_balances :: BalanceLock < :: core :: primitive :: u128 > > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Balances" , "Locks" , Vec :: new () , [216u8 , 253u8 , 87u8 , 73u8 , 24u8 , 218u8 , 35u8 , 0u8 , 244u8 , 134u8 , 195u8 , 58u8 , 255u8 , 64u8 , 153u8 , 212u8 , 210u8 , 232u8 , 4u8 , 122u8 , 90u8 , 212u8 , 136u8 , 14u8 , 127u8 , 232u8 , 8u8 , 192u8 , 40u8 , 233u8 , 18u8 , 250u8 ,]) } # [doc = " Named reserves on some account balances."] pub fn reserves (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < runtime_types :: pallet_balances :: ReserveData < [:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u128 > > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Balances" , "Reserves" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [17u8 , 32u8 , 191u8 , 46u8 , 76u8 , 220u8 , 101u8 , 100u8 , 42u8 , 250u8 , 128u8 , 167u8 , 117u8 , 44u8 , 85u8 , 96u8 , 105u8 , 216u8 , 16u8 , 147u8 , 74u8 , 55u8 , 183u8 , 94u8 , 160u8 , 177u8 , 26u8 , 187u8 , 71u8 , 197u8 , 187u8 , 163u8 ,]) } # [doc = " Named reserves on some account balances."] pub fn reserves_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < runtime_types :: pallet_balances :: ReserveData < [:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u128 > > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Balances" , "Reserves" , Vec :: new () , [17u8 , 32u8 , 191u8 , 46u8 , 76u8 , 220u8 , 101u8 , 100u8 , 42u8 , 250u8 , 128u8 , 167u8 , 117u8 , 44u8 , 85u8 , 96u8 , 105u8 , 216u8 , 16u8 , 147u8 , 74u8 , 55u8 , 183u8 , 94u8 , 160u8 , 177u8 , 26u8 , 187u8 , 71u8 , 197u8 , 187u8 , 163u8 ,]) } # [doc = " Storage version of the pallet."] # [doc = ""] # [doc = " This is set to v2.0.0 for new networks."] pub fn storage_version (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_balances :: Releases > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Balances" , "StorageVersion" , vec ! [] , [135u8 , 96u8 , 28u8 , 234u8 , 124u8 , 212u8 , 56u8 , 140u8 , 40u8 , 101u8 , 235u8 , 128u8 , 136u8 , 221u8 , 182u8 , 81u8 , 17u8 , 9u8 , 184u8 , 228u8 , 174u8 , 165u8 , 200u8 , 162u8 , 214u8 , 178u8 , 227u8 , 72u8 , 34u8 , 5u8 , 173u8 , 96u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The minimum amount required to keep an account open."] pub fn existential_deposit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Balances" , "ExistentialDeposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The maximum number of locks that should exist on an account."] # [doc = " Not strictly enforced, but used for weight estimation."] pub fn max_locks (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Balances" , "MaxLocks" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of named reserves that can exist on an account."] pub fn max_reserves (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Balances" , "MaxReserves" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod transaction_payment { use super :: root_mod ; use super :: runtime_types ; # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_transaction_payment :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,"] # [doc = "has been paid by `who`."] pub struct TransactionFeePaid { pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub actual_fee : :: core :: primitive :: u128 , pub tip : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for TransactionFeePaid { const PALLET : & 'static str = "TransactionPayment" ; const EVENT : & 'static str = "TransactionFeePaid" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { pub fn next_fee_multiplier (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_arithmetic :: fixed_point :: FixedU128 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("TransactionPayment" , "NextFeeMultiplier" , vec ! [] , [210u8 , 0u8 , 206u8 , 165u8 , 183u8 , 10u8 , 206u8 , 52u8 , 14u8 , 90u8 , 218u8 , 197u8 , 189u8 , 125u8 , 113u8 , 216u8 , 52u8 , 161u8 , 45u8 , 24u8 , 245u8 , 237u8 , 121u8 , 41u8 , 106u8 , 29u8 , 45u8 , 129u8 , 250u8 , 203u8 , 206u8 , 180u8 ,]) } pub fn storage_version (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_transaction_payment :: Releases > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("TransactionPayment" , "StorageVersion" , vec ! [] , [219u8 , 243u8 , 82u8 , 176u8 , 65u8 , 5u8 , 132u8 , 114u8 , 8u8 , 82u8 , 176u8 , 200u8 , 97u8 , 150u8 , 177u8 , 164u8 , 166u8 , 11u8 , 34u8 , 12u8 , 12u8 , 198u8 , 58u8 , 191u8 , 186u8 , 221u8 , 221u8 , 119u8 , 181u8 , 253u8 , 154u8 , 228u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " A fee mulitplier for `Operational` extrinsics to compute \"virtual tip\" to boost their"] # [doc = " `priority`"] # [doc = ""] # [doc = " This value is multipled by the `final_fee` to obtain a \"virtual tip\" that is later"] # [doc = " added to a tip component in regular `priority` calculations."] # [doc = " It means that a `Normal` transaction can front-run a similarly-sized `Operational`"] # [doc = " extrinsic (with no tip), by including a tip value greater than the virtual tip."] # [doc = ""] # [doc = " ```rust,ignore"] # [doc = " // For `Normal`"] # [doc = " let priority = priority_calc(tip);"] # [doc = ""] # [doc = " // For `Operational`"] # [doc = " let virtual_tip = (inclusion_fee + tip) * OperationalFeeMultiplier;"] # [doc = " let priority = priority_calc(tip + virtual_tip);"] # [doc = " ```"] # [doc = ""] # [doc = " Note that since we use `final_fee` the multiplier applies also to the regular `tip`"] # [doc = " sent with the transaction. So, not only does the transaction get a priority bump based"] # [doc = " on the `inclusion_fee`, but we also amplify the impact of tips applied to `Operational`"] # [doc = " transactions."] pub fn operational_fee_multiplier (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u8 >> { :: subxt :: constants :: StaticConstantAddress :: new ("TransactionPayment" , "OperationalFeeMultiplier" , [141u8 , 130u8 , 11u8 , 35u8 , 226u8 , 114u8 , 92u8 , 179u8 , 168u8 , 110u8 , 28u8 , 91u8 , 221u8 , 64u8 , 4u8 , 148u8 , 201u8 , 193u8 , 185u8 , 66u8 , 226u8 , 114u8 , 97u8 , 79u8 , 62u8 , 212u8 , 202u8 , 114u8 , 237u8 , 228u8 , 183u8 , 165u8 ,]) } } } } pub mod authorship { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetUncles { pub new_uncles : :: std :: vec :: Vec < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > > , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Provide a set of uncles."] pub fn set_uncles (& self , new_uncles : :: std :: vec :: Vec < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > > ,) -> :: subxt :: tx :: StaticTxPayload < SetUncles > { :: subxt :: tx :: StaticTxPayload :: new ("Authorship" , "set_uncles" , SetUncles { new_uncles , } , [181u8 , 70u8 , 222u8 , 83u8 , 154u8 , 215u8 , 200u8 , 64u8 , 154u8 , 228u8 , 115u8 , 247u8 , 117u8 , 89u8 , 229u8 , 102u8 , 128u8 , 189u8 , 90u8 , 60u8 , 223u8 , 19u8 , 111u8 , 172u8 , 5u8 , 223u8 , 132u8 , 37u8 , 235u8 , 119u8 , 42u8 , 64u8 ,]) } } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Uncles"] pub fn uncles (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < runtime_types :: pallet_authorship :: UncleEntryItem < :: core :: primitive :: u32 , :: subxt :: ext :: sp_core :: H256 , :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Authorship" , "Uncles" , vec ! [] , [193u8 , 226u8 , 196u8 , 151u8 , 233u8 , 82u8 , 60u8 , 164u8 , 27u8 , 156u8 , 231u8 , 51u8 , 79u8 , 134u8 , 170u8 , 166u8 , 71u8 , 120u8 , 250u8 , 255u8 , 52u8 , 168u8 , 74u8 , 199u8 , 122u8 , 253u8 , 248u8 , 178u8 , 39u8 , 233u8 , 132u8 , 67u8 ,]) } # [doc = " Author of current block."] pub fn author (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Authorship" , "Author" , vec ! [] , [149u8 , 42u8 , 33u8 , 147u8 , 190u8 , 207u8 , 174u8 , 227u8 , 190u8 , 110u8 , 25u8 , 131u8 , 5u8 , 167u8 , 237u8 , 188u8 , 188u8 , 33u8 , 177u8 , 126u8 , 181u8 , 49u8 , 126u8 , 118u8 , 46u8 , 128u8 , 154u8 , 95u8 , 15u8 , 91u8 , 103u8 , 113u8 ,]) } # [doc = " Whether uncles were already set in this block."] pub fn did_set_uncles (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: bool > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Authorship" , "DidSetUncles" , vec ! [] , [64u8 , 3u8 , 208u8 , 187u8 , 50u8 , 45u8 , 37u8 , 88u8 , 163u8 , 226u8 , 37u8 , 126u8 , 232u8 , 107u8 , 156u8 , 187u8 , 29u8 , 15u8 , 53u8 , 46u8 , 28u8 , 73u8 , 83u8 , 123u8 , 14u8 , 244u8 , 243u8 , 43u8 , 245u8 , 143u8 , 15u8 , 115u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The number of blocks back we should accept uncles."] # [doc = " This means that we will deal with uncle-parents that are"] # [doc = " `UncleGenerations + 1` before `now`."] pub fn uncle_generations (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Authorship" , "UncleGenerations" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod offences { use super :: root_mod ; use super :: runtime_types ; # [doc = "Events type."] pub type Event = runtime_types :: pallet_offences :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "There is an offence reported of the given `kind` happened at the `session_index` and"] # [doc = "(kind-specific) time slot. This event is not deposited for duplicate slashes."] # [doc = "\\[kind, timeslot\\]."] pub struct Offence { pub kind : [:: core :: primitive :: u8 ; 16usize] , pub timeslot : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: events :: StaticEvent for Offence { const PALLET : & 'static str = "Offences" ; const EVENT : & 'static str = "Offence" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The primary structure that holds all offence records keyed by report identifiers."] pub fn reports (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: H256 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_staking :: offence :: OffenceDetails < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_staking :: Exposure < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > ,) > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Offences" , "Reports" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [144u8 , 30u8 , 66u8 , 199u8 , 102u8 , 236u8 , 175u8 , 201u8 , 206u8 , 170u8 , 55u8 , 162u8 , 137u8 , 120u8 , 220u8 , 213u8 , 57u8 , 252u8 , 0u8 , 88u8 , 210u8 , 68u8 , 5u8 , 25u8 , 77u8 , 114u8 , 204u8 , 23u8 , 190u8 , 32u8 , 211u8 , 30u8 ,]) } # [doc = " The primary structure that holds all offence records keyed by report identifiers."] pub fn reports_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_staking :: offence :: OffenceDetails < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_staking :: Exposure < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > ,) > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Offences" , "Reports" , Vec :: new () , [144u8 , 30u8 , 66u8 , 199u8 , 102u8 , 236u8 , 175u8 , 201u8 , 206u8 , 170u8 , 55u8 , 162u8 , 137u8 , 120u8 , 220u8 , 213u8 , 57u8 , 252u8 , 0u8 , 88u8 , 210u8 , 68u8 , 5u8 , 25u8 , 77u8 , 114u8 , 204u8 , 23u8 , 190u8 , 32u8 , 211u8 , 30u8 ,]) } # [doc = " A vector of reports of the same kind that happened at the same time slot."] pub fn concurrent_reports_index (& self , _0 : impl :: std :: borrow :: Borrow < [:: core :: primitive :: u8 ; 16usize] > , _1 : impl :: std :: borrow :: Borrow < [:: core :: primitive :: u8] > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: H256 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Offences" , "ConcurrentReportsIndex" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat) , :: subxt :: storage :: address :: StorageMapKey :: new (_1 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [106u8 , 21u8 , 104u8 , 5u8 , 4u8 , 66u8 , 28u8 , 70u8 , 161u8 , 195u8 , 238u8 , 28u8 , 69u8 , 241u8 , 221u8 , 113u8 , 140u8 , 103u8 , 181u8 , 143u8 , 60u8 , 177u8 , 13u8 , 129u8 , 224u8 , 149u8 , 77u8 , 32u8 , 75u8 , 74u8 , 101u8 , 65u8 ,]) } # [doc = " A vector of reports of the same kind that happened at the same time slot."] pub fn concurrent_reports_index_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: H256 > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Offences" , "ConcurrentReportsIndex" , Vec :: new () , [106u8 , 21u8 , 104u8 , 5u8 , 4u8 , 66u8 , 28u8 , 70u8 , 161u8 , 195u8 , 238u8 , 28u8 , 69u8 , 241u8 , 221u8 , 113u8 , 140u8 , 103u8 , 181u8 , 143u8 , 60u8 , 177u8 , 13u8 , 129u8 , 224u8 , 149u8 , 77u8 , 32u8 , 75u8 , 74u8 , 101u8 , 65u8 ,]) } # [doc = " Enumerates all reports of a kind along with the time they happened."] # [doc = ""] # [doc = " All reports are sorted by the time of offence."] # [doc = ""] # [doc = " Note that the actual type of this mapping is `Vec<u8>`, this is because values of"] # [doc = " different types are not supported at the moment so we are doing the manual serialization."] pub fn reports_by_kind_index (& self , _0 : impl :: std :: borrow :: Borrow < [:: core :: primitive :: u8 ; 16usize] > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Offences" , "ReportsByKindIndex" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [162u8 , 66u8 , 131u8 , 48u8 , 250u8 , 237u8 , 179u8 , 214u8 , 36u8 , 137u8 , 226u8 , 136u8 , 120u8 , 61u8 , 215u8 , 43u8 , 164u8 , 50u8 , 91u8 , 164u8 , 20u8 , 96u8 , 189u8 , 100u8 , 242u8 , 106u8 , 21u8 , 136u8 , 98u8 , 215u8 , 180u8 , 145u8 ,]) } # [doc = " Enumerates all reports of a kind along with the time they happened."] # [doc = ""] # [doc = " All reports are sorted by the time of offence."] # [doc = ""] # [doc = " Note that the actual type of this mapping is `Vec<u8>`, this is because values of"] # [doc = " different types are not supported at the moment so we are doing the manual serialization."] pub fn reports_by_kind_index_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Offences" , "ReportsByKindIndex" , Vec :: new () , [162u8 , 66u8 , 131u8 , 48u8 , 250u8 , 237u8 , 179u8 , 214u8 , 36u8 , 137u8 , 226u8 , 136u8 , 120u8 , 61u8 , 215u8 , 43u8 , 164u8 , 50u8 , 91u8 , 164u8 , 20u8 , 96u8 , 189u8 , 100u8 , 242u8 , 106u8 , 21u8 , 136u8 , 98u8 , 215u8 , 180u8 , 145u8 ,]) } } } } pub mod historical { use super :: root_mod ; use super :: runtime_types ; pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Mapping from historical session indices to session-data root hash and validator count."] pub fn historical_sessions (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: subxt :: ext :: sp_core :: H256 , :: core :: primitive :: u32 ,) > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Historical" , "HistoricalSessions" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [94u8 , 72u8 , 245u8 , 151u8 , 214u8 , 10u8 , 12u8 , 113u8 , 13u8 , 141u8 , 176u8 , 178u8 , 115u8 , 238u8 , 224u8 , 181u8 , 18u8 , 5u8 , 71u8 , 65u8 , 189u8 , 148u8 , 161u8 , 106u8 , 24u8 , 211u8 , 72u8 , 66u8 , 221u8 , 244u8 , 117u8 , 184u8 ,]) } # [doc = " Mapping from historical session indices to session-data root hash and validator count."] pub fn historical_sessions_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: subxt :: ext :: sp_core :: H256 , :: core :: primitive :: u32 ,) > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Historical" , "HistoricalSessions" , Vec :: new () , [94u8 , 72u8 , 245u8 , 151u8 , 214u8 , 10u8 , 12u8 , 113u8 , 13u8 , 141u8 , 176u8 , 178u8 , 115u8 , 238u8 , 224u8 , 181u8 , 18u8 , 5u8 , 71u8 , 65u8 , 189u8 , 148u8 , 161u8 , 106u8 , 24u8 , 211u8 , 72u8 , 66u8 , 221u8 , 244u8 , 117u8 , 184u8 ,]) } # [doc = " The range of historical sessions we store. [first, last)"] pub fn stored_range (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Historical" , "StoredRange" , vec ! [] , [89u8 , 239u8 , 197u8 , 93u8 , 135u8 , 62u8 , 142u8 , 237u8 , 64u8 , 200u8 , 164u8 , 4u8 , 130u8 , 233u8 , 16u8 , 238u8 , 166u8 , 206u8 , 71u8 , 42u8 , 171u8 , 84u8 , 8u8 , 245u8 , 183u8 , 216u8 , 212u8 , 16u8 , 190u8 , 3u8 , 167u8 , 189u8 ,]) } } } } pub mod session { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetKeys { pub keys : runtime_types :: alphanet_runtime :: pallets :: SessionKeys , pub proof : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct PurgeKeys ; pub struct TransactionApi ; impl TransactionApi { # [doc = "Sets the session key(s) of the function caller to `keys`."] # [doc = "Allows an account to set its session key prior to becoming a validator."] # [doc = "This doesn't take effect until the next session."] # [doc = ""] # [doc = "The dispatch origin of this function must be signed."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: `O(1)`. Actual cost depends on the number of length of"] # [doc = "  `T::Keys::key_ids()` which is fixed."] # [doc = "- DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`"] # [doc = "- DbWrites: `origin account`, `NextKeys`"] # [doc = "- DbReads per key id: `KeyOwner`"] # [doc = "- DbWrites per key id: `KeyOwner`"] # [doc = "# </weight>"] pub fn set_keys (& self , keys : runtime_types :: alphanet_runtime :: pallets :: SessionKeys , proof : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: StaticTxPayload < SetKeys > { :: subxt :: tx :: StaticTxPayload :: new ("Session" , "set_keys" , SetKeys { keys , proof , } , [19u8 , 210u8 , 111u8 , 216u8 , 235u8 , 1u8 , 119u8 , 211u8 , 79u8 , 9u8 , 91u8 , 245u8 , 109u8 , 116u8 , 95u8 , 223u8 , 233u8 , 189u8 , 185u8 , 243u8 , 46u8 , 178u8 , 10u8 , 4u8 , 231u8 , 159u8 , 217u8 , 59u8 , 45u8 , 167u8 , 207u8 , 137u8 ,]) } # [doc = "Removes any session key(s) of the function caller."] # [doc = ""] # [doc = "This doesn't take effect until the next session."] # [doc = ""] # [doc = "The dispatch origin of this function must be Signed and the account must be either be"] # [doc = "convertible to a validator ID using the chain's typical addressing system (this usually"] # [doc = "means being a controller account) or directly convertible into a validator ID (which"] # [doc = "usually means being a stash account)."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: `O(1)` in number of key types. Actual cost depends on the number of length"] # [doc = "  of `T::Keys::key_ids()` which is fixed."] # [doc = "- DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`"] # [doc = "- DbWrites: `NextKeys`, `origin account`"] # [doc = "- DbWrites per key id: `KeyOwner`"] # [doc = "# </weight>"] pub fn purge_keys (& self ,) -> :: subxt :: tx :: StaticTxPayload < PurgeKeys > { :: subxt :: tx :: StaticTxPayload :: new ("Session" , "purge_keys" , PurgeKeys { } , [200u8 , 255u8 , 4u8 , 213u8 , 188u8 , 92u8 , 99u8 , 116u8 , 163u8 , 152u8 , 29u8 , 35u8 , 133u8 , 119u8 , 246u8 , 44u8 , 91u8 , 31u8 , 145u8 , 23u8 , 213u8 , 64u8 , 71u8 , 242u8 , 207u8 , 239u8 , 231u8 , 37u8 , 61u8 , 63u8 , 190u8 , 35u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_session :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "New session has happened. Note that the argument is the session index, not the"] # [doc = "block number as the type might suggest."] pub struct NewSession { pub session_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for NewSession { const PALLET : & 'static str = "Session" ; const EVENT : & 'static str = "NewSession" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The current set of validators."] pub fn validators (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Session" , "Validators" , vec ! [] , [144u8 , 235u8 , 200u8 , 43u8 , 151u8 , 57u8 , 147u8 , 172u8 , 201u8 , 202u8 , 242u8 , 96u8 , 57u8 , 76u8 , 124u8 , 77u8 , 42u8 , 113u8 , 218u8 , 220u8 , 230u8 , 32u8 , 151u8 , 152u8 , 172u8 , 106u8 , 60u8 , 227u8 , 122u8 , 118u8 , 137u8 , 68u8 ,]) } # [doc = " Current index of the session."] pub fn current_index (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Session" , "CurrentIndex" , vec ! [] , [148u8 , 179u8 , 159u8 , 15u8 , 197u8 , 95u8 , 214u8 , 30u8 , 209u8 , 251u8 , 183u8 , 231u8 , 91u8 , 25u8 , 181u8 , 191u8 , 143u8 , 252u8 , 227u8 , 80u8 , 159u8 , 66u8 , 194u8 , 67u8 , 113u8 , 74u8 , 111u8 , 91u8 , 218u8 , 187u8 , 130u8 , 40u8 ,]) } # [doc = " True if the underlying economic identities or weighting behind the validators"] # [doc = " has changed in the queued validator set."] pub fn queued_changed (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: bool > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Session" , "QueuedChanged" , vec ! [] , [105u8 , 140u8 , 235u8 , 218u8 , 96u8 , 100u8 , 252u8 , 10u8 , 58u8 , 221u8 , 244u8 , 251u8 , 67u8 , 91u8 , 80u8 , 202u8 , 152u8 , 42u8 , 50u8 , 113u8 , 200u8 , 247u8 , 59u8 , 213u8 , 77u8 , 195u8 , 1u8 , 150u8 , 220u8 , 18u8 , 245u8 , 46u8 ,]) } # [doc = " The queued keys for the next session. When the next session begins, these keys"] # [doc = " will be used to determine the validator's session keys."] pub fn queued_keys (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , runtime_types :: alphanet_runtime :: pallets :: SessionKeys ,) > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Session" , "QueuedKeys" , vec ! [] , [57u8 , 139u8 , 66u8 , 116u8 , 133u8 , 98u8 , 66u8 , 181u8 , 96u8 , 190u8 , 69u8 , 124u8 , 158u8 , 124u8 , 187u8 , 164u8 , 223u8 , 89u8 , 209u8 , 84u8 , 106u8 , 127u8 , 85u8 , 202u8 , 130u8 , 7u8 , 250u8 , 163u8 , 99u8 , 209u8 , 225u8 , 25u8 ,]) } # [doc = " Indices of disabled validators."] # [doc = ""] # [doc = " The vec is always kept sorted so that we can find whether a given validator is"] # [doc = " disabled using binary search. It gets cleared when `on_session_ending` returns"] # [doc = " a new set of identities."] pub fn disabled_validators (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < :: core :: primitive :: u32 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Session" , "DisabledValidators" , vec ! [] , [135u8 , 22u8 , 22u8 , 97u8 , 82u8 , 217u8 , 144u8 , 141u8 , 121u8 , 240u8 , 189u8 , 16u8 , 176u8 , 88u8 , 177u8 , 31u8 , 20u8 , 242u8 , 73u8 , 104u8 , 11u8 , 110u8 , 214u8 , 34u8 , 52u8 , 217u8 , 106u8 , 33u8 , 174u8 , 174u8 , 198u8 , 84u8 ,]) } # [doc = " The next session keys for a validator."] pub fn next_keys (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: alphanet_runtime :: pallets :: SessionKeys > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Session" , "NextKeys" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [246u8 , 66u8 , 207u8 , 19u8 , 247u8 , 26u8 , 110u8 , 116u8 , 209u8 , 77u8 , 141u8 , 64u8 , 128u8 , 214u8 , 71u8 , 104u8 , 56u8 , 117u8 , 10u8 , 162u8 , 166u8 , 137u8 , 33u8 , 98u8 , 110u8 , 31u8 , 161u8 , 116u8 , 207u8 , 46u8 , 82u8 , 64u8 ,]) } # [doc = " The next session keys for a validator."] pub fn next_keys_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: alphanet_runtime :: pallets :: SessionKeys > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Session" , "NextKeys" , Vec :: new () , [246u8 , 66u8 , 207u8 , 19u8 , 247u8 , 26u8 , 110u8 , 116u8 , 209u8 , 77u8 , 141u8 , 64u8 , 128u8 , 214u8 , 71u8 , 104u8 , 56u8 , 117u8 , 10u8 , 162u8 , 166u8 , 137u8 , 33u8 , 98u8 , 110u8 , 31u8 , 161u8 , 116u8 , 207u8 , 46u8 , 82u8 , 64u8 ,]) } # [doc = " The owner of a key. The key is the `KeyTypeId` + the encoded key."] pub fn key_owner (& self , _0 : impl :: std :: borrow :: Borrow < runtime_types :: sp_core :: crypto :: KeyTypeId > , _1 : impl :: std :: borrow :: Borrow < [:: core :: primitive :: u8] > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Session" , "KeyOwner" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (& (_0 . borrow () , _1 . borrow ()) , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [4u8 , 91u8 , 25u8 , 84u8 , 250u8 , 201u8 , 174u8 , 129u8 , 201u8 , 58u8 , 197u8 , 199u8 , 137u8 , 240u8 , 118u8 , 33u8 , 99u8 , 2u8 , 195u8 , 57u8 , 53u8 , 172u8 , 0u8 , 148u8 , 203u8 , 144u8 , 149u8 , 64u8 , 135u8 , 254u8 , 242u8 , 215u8 ,]) } # [doc = " The owner of a key. The key is the `KeyTypeId` + the encoded key."] pub fn key_owner_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Session" , "KeyOwner" , Vec :: new () , [4u8 , 91u8 , 25u8 , 84u8 , 250u8 , 201u8 , 174u8 , 129u8 , 201u8 , 58u8 , 197u8 , 199u8 , 137u8 , 240u8 , 118u8 , 33u8 , 99u8 , 2u8 , 195u8 , 57u8 , 53u8 , 172u8 , 0u8 , 148u8 , 203u8 , 144u8 , 149u8 , 64u8 , 135u8 , 254u8 , 242u8 , 215u8 ,]) } } } } pub mod grandpa { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ReportEquivocation { pub equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: ext :: sp_core :: H256 , :: core :: primitive :: u32 > > , pub key_owner_proof : runtime_types :: sp_session :: MembershipProof , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ReportEquivocationUnsigned { pub equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: ext :: sp_core :: H256 , :: core :: primitive :: u32 > > , pub key_owner_proof : runtime_types :: sp_session :: MembershipProof , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct NoteStalled { pub delay : :: core :: primitive :: u32 , pub best_finalized_block_number : :: core :: primitive :: u32 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] pub fn report_equivocation (& self , equivocation_proof : runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: ext :: sp_core :: H256 , :: core :: primitive :: u32 > , key_owner_proof : runtime_types :: sp_session :: MembershipProof ,) -> :: subxt :: tx :: StaticTxPayload < ReportEquivocation > { :: subxt :: tx :: StaticTxPayload :: new ("Grandpa" , "report_equivocation" , ReportEquivocation { equivocation_proof : :: std :: boxed :: Box :: new (equivocation_proof) , key_owner_proof , } , [156u8 , 162u8 , 189u8 , 89u8 , 60u8 , 156u8 , 129u8 , 176u8 , 62u8 , 35u8 , 214u8 , 7u8 , 68u8 , 245u8 , 130u8 , 117u8 , 30u8 , 3u8 , 73u8 , 218u8 , 142u8 , 82u8 , 13u8 , 141u8 , 124u8 , 19u8 , 53u8 , 138u8 , 70u8 , 4u8 , 40u8 , 32u8 ,]) } # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] # [doc = ""] # [doc = "This extrinsic must be called unsigned and it is expected that only"] # [doc = "block authors will call it (validated in `ValidateUnsigned`), as such"] # [doc = "if the block author is defined it will be defined as the equivocation"] # [doc = "reporter."] pub fn report_equivocation_unsigned (& self , equivocation_proof : runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: ext :: sp_core :: H256 , :: core :: primitive :: u32 > , key_owner_proof : runtime_types :: sp_session :: MembershipProof ,) -> :: subxt :: tx :: StaticTxPayload < ReportEquivocationUnsigned > { :: subxt :: tx :: StaticTxPayload :: new ("Grandpa" , "report_equivocation_unsigned" , ReportEquivocationUnsigned { equivocation_proof : :: std :: boxed :: Box :: new (equivocation_proof) , key_owner_proof , } , [166u8 , 26u8 , 217u8 , 185u8 , 215u8 , 37u8 , 174u8 , 170u8 , 137u8 , 160u8 , 151u8 , 43u8 , 246u8 , 86u8 , 58u8 , 18u8 , 248u8 , 73u8 , 99u8 , 161u8 , 158u8 , 93u8 , 212u8 , 186u8 , 224u8 , 253u8 , 234u8 , 18u8 , 151u8 , 111u8 , 227u8 , 249u8 ,]) } # [doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."] # [doc = ""] # [doc = "This will trigger a forced authority set change at the beginning of the next session, to"] # [doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"] # [doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."] # [doc = "The block production rate (which may be slowed down because of finality lagging) should"] # [doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"] # [doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"] # [doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"] # [doc = "block of all validators of the new authority set."] # [doc = ""] # [doc = "Only callable by root."] pub fn note_stalled (& self , delay : :: core :: primitive :: u32 , best_finalized_block_number : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < NoteStalled > { :: subxt :: tx :: StaticTxPayload :: new ("Grandpa" , "note_stalled" , NoteStalled { delay , best_finalized_block_number , } , [197u8 , 236u8 , 137u8 , 32u8 , 46u8 , 200u8 , 144u8 , 13u8 , 89u8 , 181u8 , 235u8 , 73u8 , 167u8 , 131u8 , 174u8 , 93u8 , 42u8 , 136u8 , 238u8 , 59u8 , 129u8 , 60u8 , 83u8 , 100u8 , 5u8 , 182u8 , 99u8 , 250u8 , 145u8 , 180u8 , 1u8 , 199u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_grandpa :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "New authority set has been applied."] pub struct NewAuthorities { pub authority_set : :: std :: vec :: Vec < (runtime_types :: sp_finality_grandpa :: app :: Public , :: core :: primitive :: u64 ,) > , } impl :: subxt :: events :: StaticEvent for NewAuthorities { const PALLET : & 'static str = "Grandpa" ; const EVENT : & 'static str = "NewAuthorities" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Current authority set has been paused."] pub struct Paused ; impl :: subxt :: events :: StaticEvent for Paused { const PALLET : & 'static str = "Grandpa" ; const EVENT : & 'static str = "Paused" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Current authority set has been resumed."] pub struct Resumed ; impl :: subxt :: events :: StaticEvent for Resumed { const PALLET : & 'static str = "Grandpa" ; const EVENT : & 'static str = "Resumed" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " State of the current authority set."] pub fn state (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_grandpa :: StoredState < :: core :: primitive :: u32 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Grandpa" , "State" , vec ! [] , [211u8 , 149u8 , 114u8 , 217u8 , 206u8 , 194u8 , 115u8 , 67u8 , 12u8 , 218u8 , 246u8 , 213u8 , 208u8 , 29u8 , 216u8 , 104u8 , 2u8 , 39u8 , 123u8 , 172u8 , 252u8 , 210u8 , 52u8 , 129u8 , 147u8 , 237u8 , 244u8 , 68u8 , 252u8 , 169u8 , 97u8 , 148u8 ,]) } # [doc = " Pending change: (signaled at, scheduled change)."] pub fn pending_change (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_grandpa :: StoredPendingChange < :: core :: primitive :: u32 > > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Grandpa" , "PendingChange" , vec ! [] , [178u8 , 24u8 , 140u8 , 7u8 , 8u8 , 196u8 , 18u8 , 58u8 , 3u8 , 226u8 , 181u8 , 47u8 , 155u8 , 160u8 , 70u8 , 12u8 , 75u8 , 189u8 , 38u8 , 255u8 , 104u8 , 141u8 , 64u8 , 34u8 , 134u8 , 201u8 , 102u8 , 21u8 , 75u8 , 81u8 , 218u8 , 60u8 ,]) } # [doc = " next block number where we can force a change."] pub fn next_forced (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Grandpa" , "NextForced" , vec ! [] , [99u8 , 43u8 , 245u8 , 201u8 , 60u8 , 9u8 , 122u8 , 99u8 , 188u8 , 29u8 , 67u8 , 6u8 , 193u8 , 133u8 , 179u8 , 67u8 , 202u8 , 208u8 , 62u8 , 179u8 , 19u8 , 169u8 , 196u8 , 119u8 , 107u8 , 75u8 , 100u8 , 3u8 , 121u8 , 18u8 , 80u8 , 156u8 ,]) } # [doc = " `true` if we are currently stalled."] pub fn stalled (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Grandpa" , "Stalled" , vec ! [] , [219u8 , 8u8 , 37u8 , 78u8 , 150u8 , 55u8 , 0u8 , 57u8 , 201u8 , 170u8 , 186u8 , 189u8 , 56u8 , 161u8 , 44u8 , 15u8 , 53u8 , 178u8 , 224u8 , 208u8 , 231u8 , 109u8 , 14u8 , 209u8 , 57u8 , 205u8 , 237u8 , 153u8 , 231u8 , 156u8 , 24u8 , 185u8 ,]) } # [doc = " The number of changes (both in terms of keys and underlying economic responsibilities)"] # [doc = " in the \"set\" of Grandpa validators from genesis."] pub fn current_set_id (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u64 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Grandpa" , "CurrentSetId" , vec ! [] , [129u8 , 7u8 , 62u8 , 101u8 , 199u8 , 60u8 , 56u8 , 33u8 , 54u8 , 158u8 , 20u8 , 178u8 , 244u8 , 145u8 , 189u8 , 197u8 , 157u8 , 163u8 , 116u8 , 36u8 , 105u8 , 52u8 , 149u8 , 244u8 , 108u8 , 94u8 , 109u8 , 111u8 , 244u8 , 137u8 , 7u8 , 108u8 ,]) } # [doc = " A mapping from grandpa set ID to the index of the *most recent* session for which its"] # [doc = " members were responsible."] # [doc = ""] # [doc = " TWOX-NOTE: `SetId` is not under user control."] pub fn set_id_session (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u64 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Grandpa" , "SetIdSession" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [91u8 , 175u8 , 145u8 , 127u8 , 242u8 , 81u8 , 13u8 , 231u8 , 110u8 , 11u8 , 166u8 , 169u8 , 103u8 , 146u8 , 123u8 , 133u8 , 157u8 , 15u8 , 33u8 , 234u8 , 108u8 , 13u8 , 88u8 , 115u8 , 254u8 , 9u8 , 145u8 , 199u8 , 102u8 , 47u8 , 53u8 , 134u8 ,]) } # [doc = " A mapping from grandpa set ID to the index of the *most recent* session for which its"] # [doc = " members were responsible."] # [doc = ""] # [doc = " TWOX-NOTE: `SetId` is not under user control."] pub fn set_id_session_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Grandpa" , "SetIdSession" , Vec :: new () , [91u8 , 175u8 , 145u8 , 127u8 , 242u8 , 81u8 , 13u8 , 231u8 , 110u8 , 11u8 , 166u8 , 169u8 , 103u8 , 146u8 , 123u8 , 133u8 , 157u8 , 15u8 , 33u8 , 234u8 , 108u8 , 13u8 , 88u8 , 115u8 , 254u8 , 9u8 , 145u8 , 199u8 , 102u8 , 47u8 , 53u8 , 134u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Max Authorities in use"] pub fn max_authorities (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Grandpa" , "MaxAuthorities" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod im_online { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Heartbeat { pub heartbeat : runtime_types :: pallet_im_online :: Heartbeat < :: core :: primitive :: u32 > , pub signature : runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Signature , } pub struct TransactionApi ; impl TransactionApi { # [doc = "# <weight>"] # [doc = "- Complexity: `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is"] # [doc = "  length of `heartbeat.network_state.external_address`"] # [doc = "  - `O(K)`: decoding of length `K`"] # [doc = "  - `O(E)`: decoding/encoding of length `E`"] # [doc = "- DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,"] # [doc = "  `ReceivedHeartbeats`"] # [doc = "- DbWrites: `ReceivedHeartbeats`"] # [doc = "# </weight>"] pub fn heartbeat (& self , heartbeat : runtime_types :: pallet_im_online :: Heartbeat < :: core :: primitive :: u32 > , signature : runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Signature ,) -> :: subxt :: tx :: StaticTxPayload < Heartbeat > { :: subxt :: tx :: StaticTxPayload :: new ("ImOnline" , "heartbeat" , Heartbeat { heartbeat , signature , } , [212u8 , 23u8 , 174u8 , 246u8 , 60u8 , 220u8 , 178u8 , 137u8 , 53u8 , 146u8 , 165u8 , 225u8 , 179u8 , 209u8 , 233u8 , 152u8 , 129u8 , 210u8 , 126u8 , 32u8 , 216u8 , 22u8 , 76u8 , 196u8 , 255u8 , 128u8 , 246u8 , 161u8 , 30u8 , 186u8 , 249u8 , 34u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_im_online :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A new heartbeat was received from `AuthorityId`."] pub struct HeartbeatReceived { pub authority_id : runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Public , } impl :: subxt :: events :: StaticEvent for HeartbeatReceived { const PALLET : & 'static str = "ImOnline" ; const EVENT : & 'static str = "HeartbeatReceived" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "At the end of the session, no offence was committed."] pub struct AllGood ; impl :: subxt :: events :: StaticEvent for AllGood { const PALLET : & 'static str = "ImOnline" ; const EVENT : & 'static str = "AllGood" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "At the end of the session, at least one validator was found to be offline."] pub struct SomeOffline { pub offline : :: std :: vec :: Vec < (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_staking :: Exposure < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > ,) > , } impl :: subxt :: events :: StaticEvent for SomeOffline { const PALLET : & 'static str = "ImOnline" ; const EVENT : & 'static str = "SomeOffline" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The block number after which it's ok to send heartbeats in the current"] # [doc = " session."] # [doc = ""] # [doc = " At the beginning of each session we set this to a value that should fall"] # [doc = " roughly in the middle of the session duration. The idea is to first wait for"] # [doc = " the validators to produce a block in the current session, so that the"] # [doc = " heartbeat later on will not be necessary."] # [doc = ""] # [doc = " This value will only be used as a fallback if we fail to get a proper session"] # [doc = " progress estimate from `NextSessionRotation`, as those estimates should be"] # [doc = " more accurate then the value we calculate for `HeartbeatAfter`."] pub fn heartbeat_after (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ImOnline" , "HeartbeatAfter" , vec ! [] , [108u8 , 100u8 , 85u8 , 198u8 , 226u8 , 122u8 , 94u8 , 225u8 , 97u8 , 154u8 , 135u8 , 95u8 , 106u8 , 28u8 , 185u8 , 78u8 , 192u8 , 196u8 , 35u8 , 191u8 , 12u8 , 19u8 , 163u8 , 46u8 , 232u8 , 235u8 , 193u8 , 81u8 , 126u8 , 204u8 , 25u8 , 228u8 ,]) } # [doc = " The current set of keys that may issue a heartbeat."] pub fn keys (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Public > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ImOnline" , "Keys" , vec ! [] , [6u8 , 198u8 , 221u8 , 58u8 , 14u8 , 166u8 , 245u8 , 103u8 , 191u8 , 20u8 , 69u8 , 233u8 , 147u8 , 245u8 , 24u8 , 64u8 , 207u8 , 180u8 , 39u8 , 208u8 , 252u8 , 236u8 , 247u8 , 112u8 , 187u8 , 97u8 , 70u8 , 11u8 , 248u8 , 148u8 , 208u8 , 106u8 ,]) } # [doc = " For each session index, we keep a mapping of `SessionIndex` and `AuthIndex` to"] # [doc = " `WrapperOpaque<BoundedOpaqueNetworkState>`."] pub fn received_heartbeats (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > , _1 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: frame_support :: traits :: misc :: WrapperOpaque < runtime_types :: pallet_im_online :: BoundedOpaqueNetworkState > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ImOnline" , "ReceivedHeartbeats" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat) , :: subxt :: storage :: address :: StorageMapKey :: new (_1 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [233u8 , 128u8 , 140u8 , 233u8 , 55u8 , 146u8 , 172u8 , 54u8 , 54u8 , 57u8 , 141u8 , 106u8 , 168u8 , 59u8 , 147u8 , 253u8 , 119u8 , 48u8 , 50u8 , 251u8 , 242u8 , 109u8 , 251u8 , 2u8 , 136u8 , 80u8 , 146u8 , 121u8 , 180u8 , 219u8 , 245u8 , 37u8 ,]) } # [doc = " For each session index, we keep a mapping of `SessionIndex` and `AuthIndex` to"] # [doc = " `WrapperOpaque<BoundedOpaqueNetworkState>`."] pub fn received_heartbeats_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: frame_support :: traits :: misc :: WrapperOpaque < runtime_types :: pallet_im_online :: BoundedOpaqueNetworkState > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ImOnline" , "ReceivedHeartbeats" , Vec :: new () , [233u8 , 128u8 , 140u8 , 233u8 , 55u8 , 146u8 , 172u8 , 54u8 , 54u8 , 57u8 , 141u8 , 106u8 , 168u8 , 59u8 , 147u8 , 253u8 , 119u8 , 48u8 , 50u8 , 251u8 , 242u8 , 109u8 , 251u8 , 2u8 , 136u8 , 80u8 , 146u8 , 121u8 , 180u8 , 219u8 , 245u8 , 37u8 ,]) } # [doc = " For each session index, we keep a mapping of `ValidatorId<T>` to the"] # [doc = " number of blocks authored by the given authority."] pub fn authored_blocks (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > , _1 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ImOnline" , "AuthoredBlocks" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat) , :: subxt :: storage :: address :: StorageMapKey :: new (_1 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [50u8 , 4u8 , 242u8 , 240u8 , 247u8 , 184u8 , 114u8 , 245u8 , 233u8 , 170u8 , 24u8 , 197u8 , 18u8 , 245u8 , 8u8 , 28u8 , 33u8 , 115u8 , 166u8 , 245u8 , 221u8 , 223u8 , 56u8 , 144u8 , 33u8 , 139u8 , 10u8 , 227u8 , 228u8 , 223u8 , 103u8 , 151u8 ,]) } # [doc = " For each session index, we keep a mapping of `ValidatorId<T>` to the"] # [doc = " number of blocks authored by the given authority."] pub fn authored_blocks_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ImOnline" , "AuthoredBlocks" , Vec :: new () , [50u8 , 4u8 , 242u8 , 240u8 , 247u8 , 184u8 , 114u8 , 245u8 , 233u8 , 170u8 , 24u8 , 197u8 , 18u8 , 245u8 , 8u8 , 28u8 , 33u8 , 115u8 , 166u8 , 245u8 , 221u8 , 223u8 , 56u8 , 144u8 , 33u8 , 139u8 , 10u8 , 227u8 , 228u8 , 223u8 , 103u8 , 151u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " A configuration for base priority of unsigned transactions."] # [doc = ""] # [doc = " This is exposed so that it can be tuned for particular runtime, when"] # [doc = " multiple pallets send unsigned transactions."] pub fn unsigned_priority (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u64 >> { :: subxt :: constants :: StaticConstantAddress :: new ("ImOnline" , "UnsignedPriority" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } } } } pub mod authority_discovery { use super :: root_mod ; use super :: runtime_types ; pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Keys of the current authority set."] pub fn keys (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: sp_authority_discovery :: app :: Public > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("AuthorityDiscovery" , "Keys" , vec ! [] , [6u8 , 198u8 , 221u8 , 58u8 , 14u8 , 166u8 , 245u8 , 103u8 , 191u8 , 20u8 , 69u8 , 233u8 , 147u8 , 245u8 , 24u8 , 64u8 , 207u8 , 180u8 , 39u8 , 208u8 , 252u8 , 236u8 , 247u8 , 112u8 , 187u8 , 97u8 , 70u8 , 11u8 , 248u8 , 148u8 , 208u8 , 106u8 ,]) } # [doc = " Keys of the next authority set."] pub fn next_keys (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: sp_authority_discovery :: app :: Public > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("AuthorityDiscovery" , "NextKeys" , vec ! [] , [213u8 , 94u8 , 49u8 , 159u8 , 135u8 , 1u8 , 13u8 , 150u8 , 28u8 , 15u8 , 105u8 , 130u8 , 90u8 , 15u8 , 130u8 , 138u8 , 186u8 , 118u8 , 10u8 , 238u8 , 173u8 , 229u8 , 8u8 , 144u8 , 206u8 , 121u8 , 90u8 , 203u8 , 125u8 , 106u8 , 145u8 , 144u8 ,]) } } } } pub mod council { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetMembers { pub new_members : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , pub prime : :: core :: option :: Option < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , pub old_count : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Execute { pub proposal : :: std :: boxed :: Box < runtime_types :: alphanet_runtime :: RuntimeCall > , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Propose { # [codec (compact)] pub threshold : :: core :: primitive :: u32 , pub proposal : :: std :: boxed :: Box < runtime_types :: alphanet_runtime :: RuntimeCall > , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Vote { pub proposal : :: subxt :: ext :: sp_core :: H256 , # [codec (compact)] pub index : :: core :: primitive :: u32 , pub approve : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CloseOldWeight { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , # [codec (compact)] pub index : :: core :: primitive :: u32 , # [codec (compact)] pub proposal_weight_bound : runtime_types :: sp_weights :: OldWeight , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct DisapproveProposal { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Close { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , # [codec (compact)] pub index : :: core :: primitive :: u32 , pub proposal_weight_bound : runtime_types :: sp_weights :: weight_v2 :: Weight , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Set the collective's membership."] # [doc = ""] # [doc = "- `new_members`: The new member list. Be nice to the chain and provide it sorted."] # [doc = "- `prime`: The prime member whose vote sets the default."] # [doc = "- `old_count`: The upper bound for the previous number of members in storage. Used for"] # [doc = "  weight estimation."] # [doc = ""] # [doc = "Requires root origin."] # [doc = ""] # [doc = "NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but"] # [doc = "      the weight estimations rely on it to estimate dispatchable weight."] # [doc = ""] # [doc = "# WARNING:"] # [doc = ""] # [doc = "The `pallet-collective` can also be managed by logic outside of the pallet through the"] # [doc = "implementation of the trait [`ChangeMembers`]."] # [doc = "Any call to `set_members` must be careful that the member set doesn't get out of sync"] # [doc = "with other logic managing the member set."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(MP + N)` where:"] # [doc = "  - `M` old-members-count (code- and governance-bounded)"] # [doc = "  - `N` new-members-count (code- and governance-bounded)"] # [doc = "  - `P` proposals-count (code-bounded)"] # [doc = "- DB:"] # [doc = "  - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the"] # [doc = "    members"] # [doc = "  - 1 storage read (codec `O(P)`) for reading the proposals"] # [doc = "  - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal"] # [doc = "  - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one"] # [doc = "# </weight>"] pub fn set_members (& self , new_members : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , prime : :: core :: option :: Option < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , old_count : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < SetMembers > { :: subxt :: tx :: StaticTxPayload :: new ("Council" , "set_members" , SetMembers { new_members , prime , old_count , } , [196u8 , 103u8 , 123u8 , 125u8 , 226u8 , 177u8 , 126u8 , 37u8 , 160u8 , 114u8 , 34u8 , 136u8 , 219u8 , 84u8 , 199u8 , 94u8 , 242u8 , 20u8 , 126u8 , 126u8 , 166u8 , 190u8 , 198u8 , 33u8 , 162u8 , 113u8 , 237u8 , 222u8 , 90u8 , 1u8 , 2u8 , 234u8 ,]) } # [doc = "Dispatch a proposal from a member using the `Member` origin."] # [doc = ""] # [doc = "Origin must be a member of the collective."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching"] # [doc = "  `proposal`"] # [doc = "- DB: 1 read (codec `O(M)`) + DB access of `proposal`"] # [doc = "- 1 event"] # [doc = "# </weight>"] pub fn execute (& self , proposal : runtime_types :: alphanet_runtime :: RuntimeCall , length_bound : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < Execute > { :: subxt :: tx :: StaticTxPayload :: new ("Council" , "execute" , Execute { proposal : :: std :: boxed :: Box :: new (proposal) , length_bound , } , [229u8 , 213u8 , 163u8 , 8u8 , 98u8 , 61u8 , 235u8 , 111u8 , 34u8 , 62u8 , 191u8 , 67u8 , 177u8 , 154u8 , 8u8 , 151u8 , 67u8 , 64u8 , 45u8 , 181u8 , 28u8 , 68u8 , 250u8 , 107u8 , 217u8 , 164u8 , 38u8 , 121u8 , 6u8 , 72u8 , 92u8 , 103u8 ,]) } # [doc = "Add a new proposal to either be voted on or executed directly."] # [doc = ""] # [doc = "Requires the sender to be member."] # [doc = ""] # [doc = "`threshold` determines whether `proposal` is executed directly (`threshold < 2`)"] # [doc = "or put up for voting."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(B + M + P1)` or `O(B + M + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - branching is influenced by `threshold` where:"] # [doc = "    - `P1` is proposal execution complexity (`threshold < 2`)"] # [doc = "    - `P2` is proposals-count (code-bounded) (`threshold >= 2`)"] # [doc = "- DB:"] # [doc = "  - 1 storage read `is_member` (codec `O(M)`)"] # [doc = "  - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)"] # [doc = "  - DB accesses influenced by `threshold`:"] # [doc = "    - EITHER storage accesses done by `proposal` (`threshold < 2`)"] # [doc = "    - OR proposal insertion (`threshold <= 2`)"] # [doc = "      - 1 storage mutation `Proposals` (codec `O(P2)`)"] # [doc = "      - 1 storage mutation `ProposalCount` (codec `O(1)`)"] # [doc = "      - 1 storage write `ProposalOf` (codec `O(B)`)"] # [doc = "      - 1 storage write `Voting` (codec `O(M)`)"] # [doc = "  - 1 event"] # [doc = "# </weight>"] pub fn propose (& self , threshold : :: core :: primitive :: u32 , proposal : runtime_types :: alphanet_runtime :: RuntimeCall , length_bound : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < Propose > { :: subxt :: tx :: StaticTxPayload :: new ("Council" , "propose" , Propose { threshold , proposal : :: std :: boxed :: Box :: new (proposal) , length_bound , } , [76u8 , 50u8 , 117u8 , 51u8 , 222u8 , 83u8 , 59u8 , 233u8 , 101u8 , 39u8 , 42u8 , 103u8 , 123u8 , 21u8 , 161u8 , 94u8 , 212u8 , 221u8 , 96u8 , 30u8 , 171u8 , 229u8 , 161u8 , 218u8 , 60u8 , 99u8 , 170u8 , 204u8 , 36u8 , 125u8 , 199u8 , 160u8 ,]) } # [doc = "Add an aye or nay vote for the sender to the given proposal."] # [doc = ""] # [doc = "Requires the sender to be a member."] # [doc = ""] # [doc = "Transaction fees will be waived if the member is voting on any particular proposal"] # [doc = "for the first time and the call is successful. Subsequent vote changes will charge a"] # [doc = "fee."] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(M)` where `M` is members-count (code- and governance-bounded)"] # [doc = "- DB:"] # [doc = "  - 1 storage read `Members` (codec `O(M)`)"] # [doc = "  - 1 storage mutation `Voting` (codec `O(M)`)"] # [doc = "- 1 event"] # [doc = "# </weight>"] pub fn vote (& self , proposal : :: subxt :: ext :: sp_core :: H256 , index : :: core :: primitive :: u32 , approve : :: core :: primitive :: bool ,) -> :: subxt :: tx :: StaticTxPayload < Vote > { :: subxt :: tx :: StaticTxPayload :: new ("Council" , "vote" , Vote { proposal , index , approve , } , [108u8 , 46u8 , 180u8 , 148u8 , 145u8 , 24u8 , 173u8 , 56u8 , 36u8 , 100u8 , 216u8 , 43u8 , 178u8 , 202u8 , 26u8 , 136u8 , 93u8 , 84u8 , 80u8 , 134u8 , 14u8 , 42u8 , 248u8 , 205u8 , 68u8 , 92u8 , 79u8 , 11u8 , 113u8 , 115u8 , 157u8 , 100u8 ,]) } # [doc = "Close a vote that is either approved, disapproved or whose voting period has ended."] # [doc = ""] # [doc = "May be called by any signed account in order to finish voting and close the proposal."] # [doc = ""] # [doc = "If called before the end of the voting period it will only close the vote if it is"] # [doc = "has enough votes to be approved or disapproved."] # [doc = ""] # [doc = "If called after the end of the voting period abstentions are counted as rejections"] # [doc = "unless there is a prime member set and the prime member cast an approval."] # [doc = ""] # [doc = "If the close operation completes successfully with disapproval, the transaction fee will"] # [doc = "be waived. Otherwise execution of the approved operation will be charged to the caller."] # [doc = ""] # [doc = "+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed"] # [doc = "proposal."] # [doc = "+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via"] # [doc = "`storage::read` so it is `size_of::<u32>() == 4` larger than the pure length."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(B + M + P1 + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - `P1` is the complexity of `proposal` preimage."] # [doc = "  - `P2` is proposal-count (code-bounded)"] # [doc = "- DB:"] # [doc = " - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)"] # [doc = " - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec"] # [doc = "   `O(P2)`)"] # [doc = " - any mutations done while executing `proposal` (`P1`)"] # [doc = "- up to 3 events"] # [doc = "# </weight>"] pub fn close_old_weight (& self , proposal_hash : :: subxt :: ext :: sp_core :: H256 , index : :: core :: primitive :: u32 , proposal_weight_bound : runtime_types :: sp_weights :: OldWeight , length_bound : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < CloseOldWeight > { :: subxt :: tx :: StaticTxPayload :: new ("Council" , "close_old_weight" , CloseOldWeight { proposal_hash , index , proposal_weight_bound , length_bound , } , [133u8 , 219u8 , 90u8 , 40u8 , 102u8 , 95u8 , 4u8 , 199u8 , 45u8 , 234u8 , 109u8 , 17u8 , 162u8 , 63u8 , 102u8 , 186u8 , 95u8 , 182u8 , 13u8 , 123u8 , 227u8 , 20u8 , 186u8 , 207u8 , 12u8 , 47u8 , 87u8 , 252u8 , 244u8 , 172u8 , 60u8 , 206u8 ,]) } # [doc = "Disapprove a proposal, close, and remove it from the system, regardless of its current"] # [doc = "state."] # [doc = ""] # [doc = "Must be called by the Root origin."] # [doc = ""] # [doc = "Parameters:"] # [doc = "* `proposal_hash`: The hash of the proposal that should be disapproved."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Complexity: O(P) where P is the number of max proposals"] # [doc = "DB Weight:"] # [doc = "* Reads: Proposals"] # [doc = "* Writes: Voting, Proposals, ProposalOf"] # [doc = "# </weight>"] pub fn disapprove_proposal (& self , proposal_hash : :: subxt :: ext :: sp_core :: H256 ,) -> :: subxt :: tx :: StaticTxPayload < DisapproveProposal > { :: subxt :: tx :: StaticTxPayload :: new ("Council" , "disapprove_proposal" , DisapproveProposal { proposal_hash , } , [25u8 , 123u8 , 1u8 , 8u8 , 74u8 , 37u8 , 3u8 , 40u8 , 97u8 , 37u8 , 175u8 , 224u8 , 72u8 , 155u8 , 123u8 , 109u8 , 104u8 , 43u8 , 91u8 , 125u8 , 199u8 , 51u8 , 17u8 , 225u8 , 133u8 , 38u8 , 120u8 , 76u8 , 164u8 , 5u8 , 194u8 , 201u8 ,]) } # [doc = "Close a vote that is either approved, disapproved or whose voting period has ended."] # [doc = ""] # [doc = "May be called by any signed account in order to finish voting and close the proposal."] # [doc = ""] # [doc = "If called before the end of the voting period it will only close the vote if it is"] # [doc = "has enough votes to be approved or disapproved."] # [doc = ""] # [doc = "If called after the end of the voting period abstentions are counted as rejections"] # [doc = "unless there is a prime member set and the prime member cast an approval."] # [doc = ""] # [doc = "If the close operation completes successfully with disapproval, the transaction fee will"] # [doc = "be waived. Otherwise execution of the approved operation will be charged to the caller."] # [doc = ""] # [doc = "+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed"] # [doc = "proposal."] # [doc = "+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via"] # [doc = "`storage::read` so it is `size_of::<u32>() == 4` larger than the pure length."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(B + M + P1 + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - `P1` is the complexity of `proposal` preimage."] # [doc = "  - `P2` is proposal-count (code-bounded)"] # [doc = "- DB:"] # [doc = " - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)"] # [doc = " - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec"] # [doc = "   `O(P2)`)"] # [doc = " - any mutations done while executing `proposal` (`P1`)"] # [doc = "- up to 3 events"] # [doc = "# </weight>"] pub fn close (& self , proposal_hash : :: subxt :: ext :: sp_core :: H256 , index : :: core :: primitive :: u32 , proposal_weight_bound : runtime_types :: sp_weights :: weight_v2 :: Weight , length_bound : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < Close > { :: subxt :: tx :: StaticTxPayload :: new ("Council" , "close" , Close { proposal_hash , index , proposal_weight_bound , length_bound , } , [191u8 , 138u8 , 89u8 , 247u8 , 97u8 , 51u8 , 45u8 , 193u8 , 76u8 , 16u8 , 80u8 , 225u8 , 197u8 , 83u8 , 204u8 , 133u8 , 169u8 , 16u8 , 86u8 , 32u8 , 125u8 , 16u8 , 116u8 , 185u8 , 45u8 , 20u8 , 76u8 , 148u8 , 206u8 , 163u8 , 154u8 , 30u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_collective :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A motion (given hash) has been proposed (by given account) with a threshold (given"] # [doc = "`MemberCount`)."] pub struct Proposed { pub account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub proposal_index : :: core :: primitive :: u32 , pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub threshold : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for Proposed { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Proposed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A motion (given hash) has been voted on by given account, leaving"] # [doc = "a tally (yes votes and no votes given respectively as `MemberCount`)."] pub struct Voted { pub account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub voted : :: core :: primitive :: bool , pub yes : :: core :: primitive :: u32 , pub no : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for Voted { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Voted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A motion was approved by the required threshold."] pub struct Approved { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , } impl :: subxt :: events :: StaticEvent for Approved { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Approved" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A motion was not approved by the required threshold."] pub struct Disapproved { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , } impl :: subxt :: events :: StaticEvent for Disapproved { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Disapproved" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A motion was executed; result will be `Ok` if it returned without error."] pub struct Executed { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: events :: StaticEvent for Executed { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Executed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A single member did some action; result will be `Ok` if it returned without error."] pub struct MemberExecuted { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: events :: StaticEvent for MemberExecuted { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "MemberExecuted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A proposal was closed because its threshold was reached or after its duration was up."] pub struct Closed { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub yes : :: core :: primitive :: u32 , pub no : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for Closed { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Closed" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The hashes of the active proposals."] pub fn proposals (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: H256 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Council" , "Proposals" , vec ! [] , [10u8 , 133u8 , 82u8 , 54u8 , 193u8 , 41u8 , 253u8 , 159u8 , 56u8 , 96u8 , 249u8 , 148u8 , 43u8 , 57u8 , 116u8 , 43u8 , 222u8 , 243u8 , 237u8 , 231u8 , 238u8 , 60u8 , 26u8 , 225u8 , 19u8 , 203u8 , 213u8 , 220u8 , 114u8 , 217u8 , 100u8 , 27u8 ,]) } # [doc = " Actual proposal for a given hash, if it's current."] pub fn proposal_of (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: H256 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: alphanet_runtime :: RuntimeCall > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Council" , "ProposalOf" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Identity)] , [15u8 , 119u8 , 175u8 , 217u8 , 237u8 , 54u8 , 145u8 , 17u8 , 212u8 , 19u8 , 132u8 , 33u8 , 132u8 , 90u8 , 180u8 , 4u8 , 106u8 , 161u8 , 215u8 , 188u8 , 220u8 , 208u8 , 70u8 , 212u8 , 29u8 , 129u8 , 95u8 , 203u8 , 225u8 , 161u8 , 125u8 , 32u8 ,]) } # [doc = " Actual proposal for a given hash, if it's current."] pub fn proposal_of_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: alphanet_runtime :: RuntimeCall > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Council" , "ProposalOf" , Vec :: new () , [15u8 , 119u8 , 175u8 , 217u8 , 237u8 , 54u8 , 145u8 , 17u8 , 212u8 , 19u8 , 132u8 , 33u8 , 132u8 , 90u8 , 180u8 , 4u8 , 106u8 , 161u8 , 215u8 , 188u8 , 220u8 , 208u8 , 70u8 , 212u8 , 29u8 , 129u8 , 95u8 , 203u8 , 225u8 , 161u8 , 125u8 , 32u8 ,]) } # [doc = " Votes on a given proposal, if it is ongoing."] pub fn voting (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: H256 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_collective :: Votes < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Council" , "Voting" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Identity)] , [89u8 , 108u8 , 65u8 , 58u8 , 60u8 , 116u8 , 54u8 , 68u8 , 179u8 , 73u8 , 161u8 , 168u8 , 78u8 , 213u8 , 208u8 , 54u8 , 244u8 , 58u8 , 70u8 , 209u8 , 170u8 , 136u8 , 215u8 , 3u8 , 2u8 , 105u8 , 229u8 , 217u8 , 240u8 , 230u8 , 107u8 , 221u8 ,]) } # [doc = " Votes on a given proposal, if it is ongoing."] pub fn voting_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_collective :: Votes < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Council" , "Voting" , Vec :: new () , [89u8 , 108u8 , 65u8 , 58u8 , 60u8 , 116u8 , 54u8 , 68u8 , 179u8 , 73u8 , 161u8 , 168u8 , 78u8 , 213u8 , 208u8 , 54u8 , 244u8 , 58u8 , 70u8 , 209u8 , 170u8 , 136u8 , 215u8 , 3u8 , 2u8 , 105u8 , 229u8 , 217u8 , 240u8 , 230u8 , 107u8 , 221u8 ,]) } # [doc = " Proposals so far."] pub fn proposal_count (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Council" , "ProposalCount" , vec ! [] , [132u8 , 145u8 , 78u8 , 218u8 , 51u8 , 189u8 , 55u8 , 172u8 , 143u8 , 33u8 , 140u8 , 99u8 , 124u8 , 208u8 , 57u8 , 232u8 , 154u8 , 110u8 , 32u8 , 142u8 , 24u8 , 149u8 , 109u8 , 105u8 , 30u8 , 83u8 , 39u8 , 177u8 , 127u8 , 160u8 , 34u8 , 70u8 ,]) } # [doc = " The current members of the collective. This is stored sorted (just by value)."] pub fn members (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Council" , "Members" , vec ! [] , [162u8 , 72u8 , 174u8 , 204u8 , 140u8 , 105u8 , 205u8 , 176u8 , 197u8 , 117u8 , 206u8 , 134u8 , 157u8 , 110u8 , 139u8 , 54u8 , 43u8 , 233u8 , 25u8 , 51u8 , 36u8 , 238u8 , 94u8 , 124u8 , 221u8 , 52u8 , 237u8 , 71u8 , 125u8 , 56u8 , 129u8 , 222u8 ,]) } # [doc = " The prime member that helps determine the default vote behavior in case of absentations."] pub fn prime (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Council" , "Prime" , vec ! [] , [108u8 , 118u8 , 54u8 , 193u8 , 207u8 , 227u8 , 119u8 , 97u8 , 23u8 , 239u8 , 157u8 , 69u8 , 56u8 , 142u8 , 106u8 , 17u8 , 215u8 , 159u8 , 48u8 , 42u8 , 185u8 , 209u8 , 49u8 , 159u8 , 32u8 , 168u8 , 111u8 , 158u8 , 159u8 , 217u8 , 244u8 , 158u8 ,]) } } } } pub mod phragmen_election { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Vote { pub votes : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RemoveVoter ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SubmitCandidacy { # [codec (compact)] pub candidate_count : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RenounceCandidacy { pub renouncing : runtime_types :: pallet_elections_phragmen :: Renouncing , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RemoveMember { pub who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub slash_bond : :: core :: primitive :: bool , pub rerun_election : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CleanDefunctVoters { pub num_voters : :: core :: primitive :: u32 , pub num_defunct : :: core :: primitive :: u32 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Vote for a set of candidates for the upcoming round of election. This can be called to"] # [doc = "set the initial votes, or update already existing votes."] # [doc = ""] # [doc = "Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is"] # [doc = "reserved. The deposit is based on the number of votes and can be updated over time."] # [doc = ""] # [doc = "The `votes` should:"] # [doc = "  - not be empty."] # [doc = "  - be less than the number of possible candidates. Note that all current members and"] # [doc = "    runners-up are also automatically candidates for the next round."] # [doc = ""] # [doc = "If `value` is more than `who`'s free balance, then the maximum of the two is used."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed."] # [doc = ""] # [doc = "### Warning"] # [doc = ""] # [doc = "It is the responsibility of the caller to **NOT** place all of their balance into the"] # [doc = "lock and keep some for further operations."] # [doc = ""] # [doc = "# <weight>"] # [doc = "We assume the maximum weight among all 3 cases: vote_equal, vote_more and vote_less."] # [doc = "# </weight>"] pub fn vote (& self , votes : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , value : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < Vote > { :: subxt :: tx :: StaticTxPayload :: new ("PhragmenElection" , "vote" , Vote { votes , value , } , [71u8 , 90u8 , 175u8 , 225u8 , 51u8 , 202u8 , 197u8 , 252u8 , 183u8 , 92u8 , 239u8 , 83u8 , 112u8 , 144u8 , 128u8 , 211u8 , 109u8 , 33u8 , 252u8 , 6u8 , 156u8 , 15u8 , 91u8 , 88u8 , 70u8 , 19u8 , 32u8 , 29u8 , 224u8 , 255u8 , 26u8 , 145u8 ,]) } # [doc = "Remove `origin` as a voter."] # [doc = ""] # [doc = "This removes the lock and returns the deposit."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed and be a voter."] pub fn remove_voter (& self ,) -> :: subxt :: tx :: StaticTxPayload < RemoveVoter > { :: subxt :: tx :: StaticTxPayload :: new ("PhragmenElection" , "remove_voter" , RemoveVoter { } , [254u8 , 46u8 , 140u8 , 4u8 , 218u8 , 45u8 , 150u8 , 72u8 , 67u8 , 131u8 , 108u8 , 201u8 , 46u8 , 157u8 , 104u8 , 161u8 , 53u8 , 155u8 , 130u8 , 50u8 , 88u8 , 149u8 , 255u8 , 12u8 , 17u8 , 85u8 , 95u8 , 69u8 , 153u8 , 130u8 , 221u8 , 1u8 ,]) } # [doc = "Submit oneself for candidacy. A fixed amount of deposit is recorded."] # [doc = ""] # [doc = "All candidates are wiped at the end of the term. They either become a member/runner-up,"] # [doc = "or leave the system while their deposit is slashed."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed."] # [doc = ""] # [doc = "### Warning"] # [doc = ""] # [doc = "Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]"] # [doc = "to get their deposit back. Losing the spot in an election will always lead to a slash."] # [doc = ""] # [doc = "# <weight>"] # [doc = "The number of current candidates must be provided as witness data."] # [doc = "# </weight>"] pub fn submit_candidacy (& self , candidate_count : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < SubmitCandidacy > { :: subxt :: tx :: StaticTxPayload :: new ("PhragmenElection" , "submit_candidacy" , SubmitCandidacy { candidate_count , } , [228u8 , 63u8 , 217u8 , 99u8 , 128u8 , 104u8 , 175u8 , 10u8 , 30u8 , 35u8 , 47u8 , 14u8 , 254u8 , 122u8 , 146u8 , 239u8 , 61u8 , 145u8 , 82u8 , 7u8 , 181u8 , 98u8 , 238u8 , 208u8 , 23u8 , 84u8 , 48u8 , 255u8 , 177u8 , 255u8 , 84u8 , 83u8 ,]) } # [doc = "Renounce one's intention to be a candidate for the next election round. 3 potential"] # [doc = "outcomes exist:"] # [doc = ""] # [doc = "- `origin` is a candidate and not elected in any set. In this case, the deposit is"] # [doc = "  unreserved, returned and origin is removed as a candidate."] # [doc = "- `origin` is a current runner-up. In this case, the deposit is unreserved, returned and"] # [doc = "  origin is removed as a runner-up."] # [doc = "- `origin` is a current member. In this case, the deposit is unreserved and origin is"] # [doc = "  removed as a member, consequently not being a candidate for the next round anymore."] # [doc = "  Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they"] # [doc = "  are immediately used. If the prime is renouncing, then no prime will exist until the"] # [doc = "  next round."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed, and have one of the above roles."] # [doc = ""] # [doc = "# <weight>"] # [doc = "The type of renouncing must be provided as witness data."] # [doc = "# </weight>"] pub fn renounce_candidacy (& self , renouncing : runtime_types :: pallet_elections_phragmen :: Renouncing ,) -> :: subxt :: tx :: StaticTxPayload < RenounceCandidacy > { :: subxt :: tx :: StaticTxPayload :: new ("PhragmenElection" , "renounce_candidacy" , RenounceCandidacy { renouncing , } , [70u8 , 72u8 , 208u8 , 36u8 , 80u8 , 245u8 , 224u8 , 75u8 , 60u8 , 142u8 , 19u8 , 49u8 , 142u8 , 90u8 , 14u8 , 69u8 , 15u8 , 61u8 , 170u8 , 235u8 , 16u8 , 252u8 , 86u8 , 200u8 , 120u8 , 127u8 , 36u8 , 42u8 , 143u8 , 130u8 , 217u8 , 128u8 ,]) } # [doc = "Remove a particular member from the set. This is effective immediately and the bond of"] # [doc = "the outgoing member is slashed."] # [doc = ""] # [doc = "If a runner-up is available, then the best runner-up will be removed and replaces the"] # [doc = "outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is"] # [doc = "started, else, nothing happens."] # [doc = ""] # [doc = "If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,"] # [doc = "it is returned."] # [doc = ""] # [doc = "The dispatch origin of this call must be root."] # [doc = ""] # [doc = "Note that this does not affect the designated block number of the next election."] # [doc = ""] # [doc = "# <weight>"] # [doc = "If we have a replacement, we use a small weight. Else, since this is a root call and"] # [doc = "will go into phragmen, we assume full block for now."] # [doc = "# </weight>"] pub fn remove_member (& self , who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , slash_bond : :: core :: primitive :: bool , rerun_election : :: core :: primitive :: bool ,) -> :: subxt :: tx :: StaticTxPayload < RemoveMember > { :: subxt :: tx :: StaticTxPayload :: new ("PhragmenElection" , "remove_member" , RemoveMember { who , slash_bond , rerun_election , } , [45u8 , 106u8 , 9u8 , 19u8 , 133u8 , 38u8 , 20u8 , 233u8 , 12u8 , 169u8 , 216u8 , 40u8 , 23u8 , 139u8 , 184u8 , 202u8 , 2u8 , 124u8 , 202u8 , 48u8 , 205u8 , 176u8 , 161u8 , 43u8 , 66u8 , 24u8 , 189u8 , 183u8 , 233u8 , 62u8 , 102u8 , 237u8 ,]) } # [doc = "Clean all voters who are defunct (i.e. they do not serve any purpose at all). The"] # [doc = "deposit of the removed voters are returned."] # [doc = ""] # [doc = "This is an root function to be used only for cleaning the state."] # [doc = ""] # [doc = "The dispatch origin of this call must be root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "The total number of voters and those that are defunct must be provided as witness data."] # [doc = "# </weight>"] pub fn clean_defunct_voters (& self , num_voters : :: core :: primitive :: u32 , num_defunct : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < CleanDefunctVoters > { :: subxt :: tx :: StaticTxPayload :: new ("PhragmenElection" , "clean_defunct_voters" , CleanDefunctVoters { num_voters , num_defunct , } , [198u8 , 162u8 , 30u8 , 249u8 , 191u8 , 38u8 , 141u8 , 123u8 , 230u8 , 90u8 , 213u8 , 103u8 , 168u8 , 28u8 , 5u8 , 215u8 , 213u8 , 152u8 , 46u8 , 189u8 , 238u8 , 209u8 , 209u8 , 142u8 , 159u8 , 222u8 , 161u8 , 26u8 , 161u8 , 250u8 , 9u8 , 100u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_elections_phragmen :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A new term with new_members. This indicates that enough candidates existed to run"] # [doc = "the election, not that enough have has been elected. The inner value must be examined"] # [doc = "for this purpose. A `NewTerm(\\[\\])` indicates that some candidates got their bond"] # [doc = "slashed and none were elected, whilst `EmptyTerm` means that no candidates existed to"] # [doc = "begin with."] pub struct NewTerm { pub new_members : :: std :: vec :: Vec < (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > , } impl :: subxt :: events :: StaticEvent for NewTerm { const PALLET : & 'static str = "PhragmenElection" ; const EVENT : & 'static str = "NewTerm" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "No (or not enough) candidates existed for this round. This is different from"] # [doc = "`NewTerm(\\[\\])`. See the description of `NewTerm`."] pub struct EmptyTerm ; impl :: subxt :: events :: StaticEvent for EmptyTerm { const PALLET : & 'static str = "PhragmenElection" ; const EVENT : & 'static str = "EmptyTerm" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Internal error happened while trying to perform election."] pub struct ElectionError ; impl :: subxt :: events :: StaticEvent for ElectionError { const PALLET : & 'static str = "PhragmenElection" ; const EVENT : & 'static str = "ElectionError" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A member has been removed. This should always be followed by either `NewTerm` or"] # [doc = "`EmptyTerm`."] pub struct MemberKicked { pub member : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for MemberKicked { const PALLET : & 'static str = "PhragmenElection" ; const EVENT : & 'static str = "MemberKicked" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Someone has renounced their candidacy."] pub struct Renounced { pub candidate : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for Renounced { const PALLET : & 'static str = "PhragmenElection" ; const EVENT : & 'static str = "Renounced" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A candidate was slashed by amount due to failing to obtain a seat as member or"] # [doc = "runner-up."] # [doc = ""] # [doc = "Note that old members and runners-up are also candidates."] pub struct CandidateSlashed { pub candidate : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for CandidateSlashed { const PALLET : & 'static str = "PhragmenElection" ; const EVENT : & 'static str = "CandidateSlashed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A seat holder was slashed by amount by being forcefully removed from the set."] pub struct SeatHolderSlashed { pub seat_holder : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for SeatHolderSlashed { const PALLET : & 'static str = "PhragmenElection" ; const EVENT : & 'static str = "SeatHolderSlashed" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The current elected members."] # [doc = ""] # [doc = " Invariant: Always sorted based on account id."] pub fn members (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < runtime_types :: pallet_elections_phragmen :: SeatHolder < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("PhragmenElection" , "Members" , vec ! [] , [2u8 , 182u8 , 43u8 , 180u8 , 87u8 , 185u8 , 26u8 , 79u8 , 196u8 , 55u8 , 28u8 , 26u8 , 174u8 , 133u8 , 158u8 , 221u8 , 101u8 , 161u8 , 83u8 , 9u8 , 221u8 , 175u8 , 221u8 , 220u8 , 81u8 , 80u8 , 1u8 , 236u8 , 74u8 , 121u8 , 10u8 , 82u8 ,]) } # [doc = " The current reserved runners-up."] # [doc = ""] # [doc = " Invariant: Always sorted based on rank (worse to best). Upon removal of a member, the"] # [doc = " last (i.e. _best_) runner-up will be replaced."] pub fn runners_up (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < runtime_types :: pallet_elections_phragmen :: SeatHolder < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("PhragmenElection" , "RunnersUp" , vec ! [] , [248u8 , 81u8 , 190u8 , 53u8 , 121u8 , 49u8 , 55u8 , 69u8 , 116u8 , 177u8 , 46u8 , 30u8 , 131u8 , 14u8 , 32u8 , 198u8 , 10u8 , 132u8 , 73u8 , 117u8 , 2u8 , 146u8 , 188u8 , 146u8 , 214u8 , 227u8 , 97u8 , 77u8 , 7u8 , 131u8 , 208u8 , 209u8 ,]) } # [doc = " The present candidate list. A current member or runner-up can never enter this vector"] # [doc = " and is always implicitly assumed to be a candidate."] # [doc = ""] # [doc = " Second element is the deposit."] # [doc = ""] # [doc = " Invariant: Always sorted based on account id."] pub fn candidates (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("PhragmenElection" , "Candidates" , vec ! [] , [224u8 , 107u8 , 141u8 , 11u8 , 54u8 , 86u8 , 117u8 , 45u8 , 195u8 , 252u8 , 152u8 , 21u8 , 165u8 , 23u8 , 198u8 , 117u8 , 5u8 , 216u8 , 183u8 , 163u8 , 243u8 , 56u8 , 11u8 , 102u8 , 85u8 , 107u8 , 219u8 , 250u8 , 45u8 , 80u8 , 108u8 , 127u8 ,]) } # [doc = " The total number of vote rounds that have happened, excluding the upcoming one."] pub fn election_rounds (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("PhragmenElection" , "ElectionRounds" , vec ! [] , [144u8 , 146u8 , 10u8 , 32u8 , 149u8 , 147u8 , 59u8 , 205u8 , 61u8 , 246u8 , 28u8 , 169u8 , 130u8 , 136u8 , 143u8 , 104u8 , 253u8 , 86u8 , 228u8 , 68u8 , 19u8 , 184u8 , 166u8 , 214u8 , 58u8 , 103u8 , 176u8 , 160u8 , 240u8 , 249u8 , 117u8 , 115u8 ,]) } # [doc = " Votes and locked stake of a particular voter."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE as `AccountId` is a crypto hash."] pub fn voting (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_elections_phragmen :: Voter < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("PhragmenElection" , "Voting" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [9u8 , 135u8 , 76u8 , 194u8 , 240u8 , 182u8 , 111u8 , 207u8 , 102u8 , 37u8 , 126u8 , 36u8 , 84u8 , 112u8 , 26u8 , 216u8 , 175u8 , 5u8 , 14u8 , 189u8 , 83u8 , 185u8 , 136u8 , 39u8 , 171u8 , 221u8 , 147u8 , 20u8 , 168u8 , 126u8 , 111u8 , 137u8 ,]) } # [doc = " Votes and locked stake of a particular voter."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE as `AccountId` is a crypto hash."] pub fn voting_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_elections_phragmen :: Voter < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("PhragmenElection" , "Voting" , Vec :: new () , [9u8 , 135u8 , 76u8 , 194u8 , 240u8 , 182u8 , 111u8 , 207u8 , 102u8 , 37u8 , 126u8 , 36u8 , 84u8 , 112u8 , 26u8 , 216u8 , 175u8 , 5u8 , 14u8 , 189u8 , 83u8 , 185u8 , 136u8 , 39u8 , 171u8 , 221u8 , 147u8 , 20u8 , 168u8 , 126u8 , 111u8 , 137u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Identifier for the elections-phragmen pallet's lock"] pub fn pallet_id (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < [:: core :: primitive :: u8 ; 8usize] >> { :: subxt :: constants :: StaticConstantAddress :: new ("PhragmenElection" , "PalletId" , [224u8 , 197u8 , 247u8 , 125u8 , 62u8 , 180u8 , 69u8 , 91u8 , 226u8 , 36u8 , 82u8 , 148u8 , 70u8 , 147u8 , 209u8 , 40u8 , 210u8 , 229u8 , 181u8 , 191u8 , 170u8 , 205u8 , 138u8 , 97u8 , 127u8 , 59u8 , 124u8 , 244u8 , 252u8 , 30u8 , 213u8 , 179u8 ,]) } # [doc = " How much should be locked up in order to submit one's candidacy."] pub fn candidacy_bond (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("PhragmenElection" , "CandidacyBond" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " Base deposit associated with voting."] # [doc = ""] # [doc = " This should be sensibly high to economically ensure the pallet cannot be attacked by"] # [doc = " creating a gigantic number of votes."] pub fn voting_bond_base (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("PhragmenElection" , "VotingBondBase" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The amount of bond that need to be locked for each vote (32 bytes)."] pub fn voting_bond_factor (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("PhragmenElection" , "VotingBondFactor" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " Number of members to elect."] pub fn desired_members (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("PhragmenElection" , "DesiredMembers" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Number of runners_up to keep."] pub fn desired_runners_up (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("PhragmenElection" , "DesiredRunnersUp" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " How long each seat is kept. This defines the next block number at which an election"] # [doc = " round will happen. If set to zero, no elections are ever triggered and the module will"] # [doc = " be in passive mode."] pub fn term_duration (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("PhragmenElection" , "TermDuration" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of candidates in a phragmen election."] # [doc = ""] # [doc = " Warning: The election happens onchain, and this value will determine"] # [doc = " the size of the election. When this limit is reached no more"] # [doc = " candidates are accepted in the election."] pub fn max_candidates (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("PhragmenElection" , "MaxCandidates" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of voters to allow in a phragmen election."] # [doc = ""] # [doc = " Warning: This impacts the size of the election which is run onchain."] # [doc = " When the limit is reached the new voters are ignored."] pub fn max_voters (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("PhragmenElection" , "MaxVoters" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod democracy { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Propose { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , # [codec (compact)] pub value : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Second { # [codec (compact)] pub proposal : :: core :: primitive :: u32 , # [codec (compact)] pub seconds_upper_bound : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Vote { # [codec (compact)] pub ref_index : :: core :: primitive :: u32 , pub vote : runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct EmergencyCancel { pub ref_index : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ExternalPropose { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ExternalProposeMajority { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ExternalProposeDefault { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct FastTrack { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub voting_period : :: core :: primitive :: u32 , pub delay : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct VetoExternal { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CancelReferendum { # [codec (compact)] pub ref_index : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CancelQueued { pub which : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Delegate { pub to : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub conviction : runtime_types :: pallet_democracy :: conviction :: Conviction , pub balance : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Undelegate ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ClearPublicProposals ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct NotePreimage { pub encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct NotePreimageOperational { pub encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct NoteImminentPreimage { pub encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct NoteImminentPreimageOperational { pub encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ReapPreimage { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , # [codec (compact)] pub proposal_len_upper_bound : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Unlock { pub target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RemoveVote { pub index : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RemoveOtherVote { pub target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub index : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct EnactProposal { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub index : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Blacklist { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub maybe_ref_index : :: core :: option :: Option < :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CancelProposal { # [codec (compact)] pub prop_index : :: core :: primitive :: u32 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Propose a sensitive action to be taken."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the sender must"] # [doc = "have funds to cover the deposit."] # [doc = ""] # [doc = "- `proposal_hash`: The hash of the proposal preimage."] # [doc = "- `value`: The amount of deposit (must be at least `MinimumDeposit`)."] # [doc = ""] # [doc = "Emits `Proposed`."] # [doc = ""] # [doc = "Weight: `O(p)`"] pub fn propose (& self , proposal_hash : :: subxt :: ext :: sp_core :: H256 , value : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < Propose > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "propose" , Propose { proposal_hash , value , } , [151u8 , 2u8 , 117u8 , 57u8 , 201u8 , 246u8 , 181u8 , 198u8 , 83u8 , 74u8 , 99u8 , 211u8 , 237u8 , 53u8 , 90u8 , 173u8 , 161u8 , 250u8 , 139u8 , 253u8 , 223u8 , 251u8 , 39u8 , 108u8 , 254u8 , 192u8 , 233u8 , 23u8 , 9u8 , 99u8 , 169u8 , 195u8 ,]) } # [doc = "Signals agreement with a particular proposal."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the sender"] # [doc = "must have funds to cover the deposit, equal to the original deposit."] # [doc = ""] # [doc = "- `proposal`: The index of the proposal to second."] # [doc = "- `seconds_upper_bound`: an upper bound on the current number of seconds on this"] # [doc = "  proposal. Extrinsic is weighted according to this value with no refund."] # [doc = ""] # [doc = "Weight: `O(S)` where S is the number of seconds a proposal already has."] pub fn second (& self , proposal : :: core :: primitive :: u32 , seconds_upper_bound : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < Second > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "second" , Second { proposal , seconds_upper_bound , } , [152u8 , 56u8 , 134u8 , 181u8 , 88u8 , 224u8 , 68u8 , 238u8 , 231u8 , 78u8 , 237u8 , 142u8 , 133u8 , 16u8 , 93u8 , 63u8 , 253u8 , 81u8 , 96u8 , 200u8 , 43u8 , 21u8 , 249u8 , 92u8 , 78u8 , 24u8 , 101u8 , 217u8 , 143u8 , 16u8 , 213u8 , 244u8 ,]) } # [doc = "Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;"] # [doc = "otherwise it is a vote to keep the status quo."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `ref_index`: The index of the referendum to vote for."] # [doc = "- `vote`: The vote configuration."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter has voted on."] pub fn vote (& self , ref_index : :: core :: primitive :: u32 , vote : runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > ,) -> :: subxt :: tx :: StaticTxPayload < Vote > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "vote" , Vote { ref_index , vote , } , [138u8 , 213u8 , 229u8 , 111u8 , 1u8 , 191u8 , 73u8 , 3u8 , 145u8 , 28u8 , 44u8 , 88u8 , 163u8 , 188u8 , 129u8 , 188u8 , 64u8 , 15u8 , 64u8 , 103u8 , 250u8 , 97u8 , 234u8 , 188u8 , 29u8 , 205u8 , 51u8 , 6u8 , 116u8 , 58u8 , 156u8 , 201u8 ,]) } # [doc = "Schedule an emergency cancellation of a referendum. Cannot happen twice to the same"] # [doc = "referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be `CancellationOrigin`."] # [doc = ""] # [doc = "-`ref_index`: The index of the referendum to cancel."] # [doc = ""] # [doc = "Weight: `O(1)`."] pub fn emergency_cancel (& self , ref_index : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < EmergencyCancel > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "emergency_cancel" , EmergencyCancel { ref_index , } , [139u8 , 213u8 , 133u8 , 75u8 , 34u8 , 206u8 , 124u8 , 245u8 , 35u8 , 237u8 , 132u8 , 92u8 , 49u8 , 167u8 , 117u8 , 80u8 , 188u8 , 93u8 , 198u8 , 237u8 , 132u8 , 77u8 , 195u8 , 65u8 , 29u8 , 37u8 , 86u8 , 74u8 , 214u8 , 119u8 , 71u8 , 204u8 ,]) } # [doc = "Schedule a referendum to be tabled once it is legal to schedule an external"] # [doc = "referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be `ExternalOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Weight: `O(V)` with V number of vetoers in the blacklist of proposal."] # [doc = "  Decoding vec of length V. Charged as maximum"] pub fn external_propose (& self , proposal_hash : :: subxt :: ext :: sp_core :: H256 ,) -> :: subxt :: tx :: StaticTxPayload < ExternalPropose > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "external_propose" , ExternalPropose { proposal_hash , } , [8u8 , 206u8 , 229u8 , 218u8 , 203u8 , 208u8 , 253u8 , 113u8 , 43u8 , 62u8 , 110u8 , 155u8 , 123u8 , 35u8 , 187u8 , 211u8 , 180u8 , 225u8 , 41u8 , 30u8 , 204u8 , 110u8 , 202u8 , 210u8 , 143u8 , 84u8 , 117u8 , 20u8 , 215u8 , 110u8 , 211u8 , 89u8 ,]) } # [doc = "Schedule a majority-carries referendum to be tabled next once it is legal to schedule"] # [doc = "an external referendum."] # [doc = ""] # [doc = "The dispatch of this call must be `ExternalMajorityOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Unlike `external_propose`, blacklisting has no effect on this and it may replace a"] # [doc = "pre-scheduled `external_propose` call."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn external_propose_majority (& self , proposal_hash : :: subxt :: ext :: sp_core :: H256 ,) -> :: subxt :: tx :: StaticTxPayload < ExternalProposeMajority > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "external_propose_majority" , ExternalProposeMajority { proposal_hash , } , [36u8 , 47u8 , 192u8 , 177u8 , 164u8 , 82u8 , 109u8 , 215u8 , 98u8 , 28u8 , 47u8 , 237u8 , 159u8 , 233u8 , 53u8 , 9u8 , 158u8 , 134u8 , 232u8 , 249u8 , 55u8 , 189u8 , 48u8 , 133u8 , 201u8 , 46u8 , 237u8 , 158u8 , 181u8 , 163u8 , 166u8 , 213u8 ,]) } # [doc = "Schedule a negative-turnout-bias referendum to be tabled next once it is legal to"] # [doc = "schedule an external referendum."] # [doc = ""] # [doc = "The dispatch of this call must be `ExternalDefaultOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Unlike `external_propose`, blacklisting has no effect on this and it may replace a"] # [doc = "pre-scheduled `external_propose` call."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn external_propose_default (& self , proposal_hash : :: subxt :: ext :: sp_core :: H256 ,) -> :: subxt :: tx :: StaticTxPayload < ExternalProposeDefault > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "external_propose_default" , ExternalProposeDefault { proposal_hash , } , [32u8 , 100u8 , 249u8 , 175u8 , 187u8 , 77u8 , 30u8 , 65u8 , 90u8 , 103u8 , 251u8 , 21u8 , 21u8 , 220u8 , 8u8 , 118u8 , 97u8 , 160u8 , 152u8 , 122u8 , 71u8 , 140u8 , 96u8 , 8u8 , 245u8 , 74u8 , 112u8 , 164u8 , 55u8 , 130u8 , 38u8 , 14u8 ,]) } # [doc = "Schedule the currently externally-proposed majority-carries referendum to be tabled"] # [doc = "immediately. If there is no externally-proposed referendum currently, or if there is one"] # [doc = "but it is not a majority-carries referendum then it fails."] # [doc = ""] # [doc = "The dispatch of this call must be `FastTrackOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The hash of the current external proposal."] # [doc = "- `voting_period`: The period that is allowed for voting on this proposal."] # [doc = "\tMust be always greater than zero."] # [doc = "\tFor `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`."] # [doc = "- `delay`: The number of block after voting has ended in approval and this should be"] # [doc = "  enacted. This doesn't have a minimum amount."] # [doc = ""] # [doc = "Emits `Started`."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn fast_track (& self , proposal_hash : :: subxt :: ext :: sp_core :: H256 , voting_period : :: core :: primitive :: u32 , delay : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < FastTrack > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "fast_track" , FastTrack { proposal_hash , voting_period , delay , } , [125u8 , 209u8 , 107u8 , 120u8 , 93u8 , 205u8 , 129u8 , 147u8 , 254u8 , 126u8 , 45u8 , 126u8 , 39u8 , 0u8 , 56u8 , 14u8 , 233u8 , 49u8 , 245u8 , 220u8 , 156u8 , 10u8 , 252u8 , 31u8 , 102u8 , 90u8 , 163u8 , 236u8 , 178u8 , 85u8 , 13u8 , 24u8 ,]) } # [doc = "Veto and blacklist the external proposal hash."] # [doc = ""] # [doc = "The dispatch origin of this call must be `VetoOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal to veto and blacklist."] # [doc = ""] # [doc = "Emits `Vetoed`."] # [doc = ""] # [doc = "Weight: `O(V + log(V))` where V is number of `existing vetoers`"] pub fn veto_external (& self , proposal_hash : :: subxt :: ext :: sp_core :: H256 ,) -> :: subxt :: tx :: StaticTxPayload < VetoExternal > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "veto_external" , VetoExternal { proposal_hash , } , [209u8 , 18u8 , 18u8 , 103u8 , 186u8 , 160u8 , 214u8 , 124u8 , 150u8 , 207u8 , 112u8 , 90u8 , 84u8 , 197u8 , 95u8 , 157u8 , 165u8 , 65u8 , 109u8 , 101u8 , 75u8 , 201u8 , 41u8 , 149u8 , 75u8 , 154u8 , 37u8 , 178u8 , 239u8 , 121u8 , 124u8 , 23u8 ,]) } # [doc = "Remove a referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "- `ref_index`: The index of the referendum to cancel."] # [doc = ""] # [doc = "# Weight: `O(1)`."] pub fn cancel_referendum (& self , ref_index : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < CancelReferendum > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "cancel_referendum" , CancelReferendum { ref_index , } , [51u8 , 25u8 , 25u8 , 251u8 , 236u8 , 115u8 , 130u8 , 230u8 , 72u8 , 186u8 , 119u8 , 71u8 , 165u8 , 137u8 , 55u8 , 167u8 , 187u8 , 128u8 , 55u8 , 8u8 , 212u8 , 139u8 , 245u8 , 232u8 , 103u8 , 136u8 , 229u8 , 113u8 , 125u8 , 36u8 , 1u8 , 149u8 ,]) } # [doc = "Cancel a proposal queued for enactment."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "- `which`: The index of the referendum to cancel."] # [doc = ""] # [doc = "Weight: `O(D)` where `D` is the items in the dispatch queue. Weighted as `D = 10`."] pub fn cancel_queued (& self , which : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < CancelQueued > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "cancel_queued" , CancelQueued { which , } , [6u8 , 97u8 , 182u8 , 142u8 , 165u8 , 206u8 , 218u8 , 245u8 , 206u8 , 224u8 , 143u8 , 164u8 , 232u8 , 129u8 , 202u8 , 141u8 , 78u8 , 65u8 , 79u8 , 206u8 , 3u8 , 195u8 , 151u8 , 36u8 , 8u8 , 220u8 , 184u8 , 239u8 , 28u8 , 187u8 , 208u8 , 174u8 ,]) } # [doc = "Delegate the voting power (with some given conviction) of the sending account."] # [doc = ""] # [doc = "The balance delegated is locked for as long as it's delegated, and thereafter for the"] # [doc = "time appropriate for the conviction's lock period."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_, and the signing account must either:"] # [doc = "  - be delegating already; or"] # [doc = "  - have no voting activity (if there is, then it will need to be removed/consolidated"] # [doc = "    through `reap_vote` or `unvote`)."] # [doc = ""] # [doc = "- `to`: The account whose voting the `target` account's voting power will follow."] # [doc = "- `conviction`: The conviction that will be attached to the delegated votes. When the"] # [doc = "  account is undelegated, the funds will be locked for the corresponding period."] # [doc = "- `balance`: The amount of the account's balance to be used in delegating. This must not"] # [doc = "  be more than the account's current balance."] # [doc = ""] # [doc = "Emits `Delegated`."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter delegating to has"] # [doc = "  voted on. Weight is charged as if maximum votes."] pub fn delegate (& self , to : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , conviction : runtime_types :: pallet_democracy :: conviction :: Conviction , balance : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < Delegate > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "delegate" , Delegate { to , conviction , balance , } , [22u8 , 205u8 , 202u8 , 196u8 , 63u8 , 1u8 , 196u8 , 109u8 , 4u8 , 190u8 , 38u8 , 142u8 , 248u8 , 200u8 , 136u8 , 12u8 , 194u8 , 170u8 , 237u8 , 176u8 , 70u8 , 21u8 , 112u8 , 154u8 , 93u8 , 169u8 , 211u8 , 120u8 , 156u8 , 68u8 , 14u8 , 231u8 ,]) } # [doc = "Undelegate the voting power of the sending account."] # [doc = ""] # [doc = "Tokens may be unlocked following once an amount of time consistent with the lock period"] # [doc = "of the conviction with which the delegation was issued."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the signing account must be"] # [doc = "currently delegating."] # [doc = ""] # [doc = "Emits `Undelegated`."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter delegating to has"] # [doc = "  voted on. Weight is charged as if maximum votes."] pub fn undelegate (& self ,) -> :: subxt :: tx :: StaticTxPayload < Undelegate > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "undelegate" , Undelegate { } , [165u8 , 40u8 , 183u8 , 209u8 , 57u8 , 153u8 , 111u8 , 29u8 , 114u8 , 109u8 , 107u8 , 235u8 , 97u8 , 61u8 , 53u8 , 155u8 , 44u8 , 245u8 , 28u8 , 220u8 , 56u8 , 134u8 , 43u8 , 122u8 , 248u8 , 156u8 , 191u8 , 154u8 , 4u8 , 121u8 , 152u8 , 153u8 ,]) } # [doc = "Clears all public proposals."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "Weight: `O(1)`."] pub fn clear_public_proposals (& self ,) -> :: subxt :: tx :: StaticTxPayload < ClearPublicProposals > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "clear_public_proposals" , ClearPublicProposals { } , [59u8 , 126u8 , 254u8 , 223u8 , 252u8 , 225u8 , 75u8 , 185u8 , 188u8 , 181u8 , 42u8 , 179u8 , 211u8 , 73u8 , 12u8 , 141u8 , 243u8 , 197u8 , 46u8 , 130u8 , 215u8 , 196u8 , 225u8 , 88u8 , 48u8 , 199u8 , 231u8 , 249u8 , 195u8 , 53u8 , 184u8 , 204u8 ,]) } # [doc = "Register the preimage for an upcoming proposal. This doesn't require the proposal to be"] # [doc = "in the dispatch queue but does require a deposit, returned once enacted."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `encoded_proposal`: The preimage of a proposal."] # [doc = ""] # [doc = "Emits `PreimageNoted`."] # [doc = ""] # [doc = "Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."] pub fn note_preimage (& self , encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: StaticTxPayload < NotePreimage > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "note_preimage" , NotePreimage { encoded_proposal , } , [31u8 , 252u8 , 248u8 , 238u8 , 103u8 , 1u8 , 82u8 , 84u8 , 135u8 , 152u8 , 246u8 , 234u8 , 251u8 , 124u8 , 193u8 , 73u8 , 52u8 , 255u8 , 88u8 , 31u8 , 112u8 , 99u8 , 191u8 , 245u8 , 251u8 , 202u8 , 51u8 , 130u8 , 136u8 , 114u8 , 177u8 , 241u8 ,]) } # [doc = "Same as `note_preimage` but origin is `OperationalPreimageOrigin`."] pub fn note_preimage_operational (& self , encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: StaticTxPayload < NotePreimageOperational > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "note_preimage_operational" , NotePreimageOperational { encoded_proposal , } , [184u8 , 81u8 , 31u8 , 172u8 , 81u8 , 113u8 , 84u8 , 246u8 , 189u8 , 219u8 , 167u8 , 32u8 , 191u8 , 126u8 , 165u8 , 250u8 , 147u8 , 199u8 , 241u8 , 196u8 , 253u8 , 34u8 , 51u8 , 158u8 , 2u8 , 157u8 , 16u8 , 122u8 , 210u8 , 66u8 , 110u8 , 234u8 ,]) } # [doc = "Register the preimage for an upcoming proposal. This requires the proposal to be"] # [doc = "in the dispatch queue. No deposit is needed. When this call is successful, i.e."] # [doc = "the preimage has not been uploaded before and matches some imminent proposal,"] # [doc = "no fee is paid."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `encoded_proposal`: The preimage of a proposal."] # [doc = ""] # [doc = "Emits `PreimageNoted`."] # [doc = ""] # [doc = "Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."] pub fn note_imminent_preimage (& self , encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: StaticTxPayload < NoteImminentPreimage > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "note_imminent_preimage" , NoteImminentPreimage { encoded_proposal , } , [32u8 , 188u8 , 10u8 , 215u8 , 245u8 , 132u8 , 234u8 , 124u8 , 19u8 , 90u8 , 225u8 , 216u8 , 169u8 , 105u8 , 95u8 , 231u8 , 12u8 , 109u8 , 16u8 , 91u8 , 153u8 , 134u8 , 240u8 , 82u8 , 80u8 , 254u8 , 117u8 , 230u8 , 88u8 , 203u8 , 68u8 , 42u8 ,]) } # [doc = "Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`."] pub fn note_imminent_preimage_operational (& self , encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: StaticTxPayload < NoteImminentPreimageOperational > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "note_imminent_preimage_operational" , NoteImminentPreimageOperational { encoded_proposal , } , [7u8 , 31u8 , 49u8 , 238u8 , 155u8 , 234u8 , 187u8 , 147u8 , 123u8 , 84u8 , 50u8 , 98u8 , 221u8 , 39u8 , 218u8 , 204u8 , 175u8 , 136u8 , 44u8 , 93u8 , 140u8 , 172u8 , 73u8 , 98u8 , 168u8 , 110u8 , 31u8 , 82u8 , 22u8 , 1u8 , 205u8 , 84u8 ,]) } # [doc = "Remove an expired proposal preimage and collect the deposit."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of a proposal."] # [doc = "- `proposal_length_upper_bound`: an upper bound on length of the proposal. Extrinsic is"] # [doc = "  weighted according to this value with no refund."] # [doc = ""] # [doc = "This will only work after `VotingPeriod` blocks from the time that the preimage was"] # [doc = "noted, if it's the same account doing it. If it's a different account, then it'll only"] # [doc = "work an additional `EnactmentPeriod` later."] # [doc = ""] # [doc = "Emits `PreimageReaped`."] # [doc = ""] # [doc = "Weight: `O(D)` where D is length of proposal."] pub fn reap_preimage (& self , proposal_hash : :: subxt :: ext :: sp_core :: H256 , proposal_len_upper_bound : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < ReapPreimage > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "reap_preimage" , ReapPreimage { proposal_hash , proposal_len_upper_bound , } , [135u8 , 43u8 , 115u8 , 154u8 , 93u8 , 121u8 , 112u8 , 65u8 , 145u8 , 141u8 , 236u8 , 252u8 , 203u8 , 155u8 , 63u8 , 130u8 , 120u8 , 221u8 , 13u8 , 105u8 , 81u8 , 179u8 , 167u8 , 254u8 , 213u8 , 117u8 , 146u8 , 232u8 , 18u8 , 104u8 , 196u8 , 112u8 ,]) } # [doc = "Unlock tokens that have an expired lock."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account to remove the lock on."] # [doc = ""] # [doc = "Weight: `O(R)` with R number of vote of target."] pub fn unlock (& self , target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < Unlock > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "unlock" , Unlock { target , } , [126u8 , 151u8 , 230u8 , 89u8 , 49u8 , 247u8 , 242u8 , 139u8 , 190u8 , 15u8 , 47u8 , 2u8 , 132u8 , 165u8 , 48u8 , 205u8 , 196u8 , 66u8 , 230u8 , 222u8 , 164u8 , 249u8 , 152u8 , 107u8 , 0u8 , 99u8 , 238u8 , 167u8 , 72u8 , 77u8 , 145u8 , 236u8 ,]) } # [doc = "Remove a vote for a referendum."] # [doc = ""] # [doc = "If:"] # [doc = "- the referendum was cancelled, or"] # [doc = "- the referendum is ongoing, or"] # [doc = "- the referendum has ended such that"] # [doc = "  - the vote of the account was in opposition to the result; or"] # [doc = "  - there was no conviction to the account's vote; or"] # [doc = "  - the account made a split vote"] # [doc = "...then the vote is removed cleanly and a following call to `unlock` may result in more"] # [doc = "funds being available."] # [doc = ""] # [doc = "If, however, the referendum has ended and:"] # [doc = "- it finished corresponding to the vote of the account, and"] # [doc = "- the account made a standard vote with conviction, and"] # [doc = "- the lock period of the conviction is not over"] # [doc = "...then the lock will be aggregated into the overall account's lock, which may involve"] # [doc = "*overlocking* (where the two locks are combined into a single lock that is the maximum"] # [doc = "of both the amount locked and the time is it locked for)."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_, and the signer must have a vote"] # [doc = "registered for referendum `index`."] # [doc = ""] # [doc = "- `index`: The index of referendum of the vote to be removed."] # [doc = ""] # [doc = "Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on."] # [doc = "  Weight is calculated for the maximum number of vote."] pub fn remove_vote (& self , index : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < RemoveVote > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "remove_vote" , RemoveVote { index , } , [148u8 , 120u8 , 14u8 , 172u8 , 81u8 , 152u8 , 159u8 , 178u8 , 106u8 , 244u8 , 36u8 , 98u8 , 120u8 , 189u8 , 213u8 , 93u8 , 119u8 , 156u8 , 112u8 , 34u8 , 241u8 , 72u8 , 206u8 , 113u8 , 212u8 , 161u8 , 164u8 , 126u8 , 122u8 , 82u8 , 160u8 , 74u8 ,]) } # [doc = "Remove a vote for a referendum."] # [doc = ""] # [doc = "If the `target` is equal to the signer, then this function is exactly equivalent to"] # [doc = "`remove_vote`. If not equal to the signer, then the vote must have expired,"] # [doc = "either because the referendum was cancelled, because the voter lost the referendum or"] # [doc = "because the conviction period is over."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account of the vote to be removed; this account must have voted for"] # [doc = "  referendum `index`."] # [doc = "- `index`: The index of referendum of the vote to be removed."] # [doc = ""] # [doc = "Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on."] # [doc = "  Weight is calculated for the maximum number of vote."] pub fn remove_other_vote (& self , target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , index : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < RemoveOtherVote > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "remove_other_vote" , RemoveOtherVote { target , index , } , [151u8 , 190u8 , 115u8 , 124u8 , 185u8 , 43u8 , 70u8 , 147u8 , 98u8 , 167u8 , 120u8 , 25u8 , 231u8 , 143u8 , 214u8 , 25u8 , 240u8 , 74u8 , 35u8 , 58u8 , 206u8 , 78u8 , 121u8 , 215u8 , 190u8 , 42u8 , 2u8 , 206u8 , 241u8 , 44u8 , 92u8 , 23u8 ,]) } # [doc = "Enact a proposal from a referendum. For now we just make the weight be the maximum."] pub fn enact_proposal (& self , proposal_hash : :: subxt :: ext :: sp_core :: H256 , index : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < EnactProposal > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "enact_proposal" , EnactProposal { proposal_hash , index , } , [191u8 , 244u8 , 244u8 , 174u8 , 95u8 , 86u8 , 132u8 , 63u8 , 2u8 , 94u8 , 3u8 , 117u8 , 96u8 , 54u8 , 100u8 , 89u8 , 124u8 , 117u8 , 205u8 , 142u8 , 214u8 , 192u8 , 137u8 , 141u8 , 178u8 , 145u8 , 241u8 , 167u8 , 163u8 , 76u8 , 61u8 , 31u8 ,]) } # [doc = "Permanently place a proposal into the blacklist. This prevents it from ever being"] # [doc = "proposed again."] # [doc = ""] # [doc = "If called on a queued public or external proposal, then this will result in it being"] # [doc = "removed. If the `ref_index` supplied is an active referendum with the proposal hash,"] # [doc = "then it will be cancelled."] # [doc = ""] # [doc = "The dispatch origin of this call must be `BlacklistOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The proposal hash to blacklist permanently."] # [doc = "- `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be"] # [doc = "cancelled."] # [doc = ""] # [doc = "Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a"] # [doc = "  reasonable value)."] pub fn blacklist (& self , proposal_hash : :: subxt :: ext :: sp_core :: H256 , maybe_ref_index : :: core :: option :: Option < :: core :: primitive :: u32 > ,) -> :: subxt :: tx :: StaticTxPayload < Blacklist > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "blacklist" , Blacklist { proposal_hash , maybe_ref_index , } , [48u8 , 144u8 , 81u8 , 164u8 , 54u8 , 111u8 , 197u8 , 134u8 , 6u8 , 98u8 , 121u8 , 179u8 , 254u8 , 191u8 , 204u8 , 212u8 , 84u8 , 255u8 , 86u8 , 110u8 , 225u8 , 130u8 , 26u8 , 65u8 , 133u8 , 56u8 , 231u8 , 15u8 , 245u8 , 137u8 , 146u8 , 242u8 ,]) } # [doc = "Remove a proposal."] # [doc = ""] # [doc = "The dispatch origin of this call must be `CancelProposalOrigin`."] # [doc = ""] # [doc = "- `prop_index`: The index of the proposal to cancel."] # [doc = ""] # [doc = "Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`"] pub fn cancel_proposal (& self , prop_index : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < CancelProposal > { :: subxt :: tx :: StaticTxPayload :: new ("Democracy" , "cancel_proposal" , CancelProposal { prop_index , } , [179u8 , 3u8 , 198u8 , 244u8 , 241u8 , 124u8 , 205u8 , 58u8 , 100u8 , 80u8 , 177u8 , 254u8 , 98u8 , 220u8 , 189u8 , 63u8 , 229u8 , 60u8 , 157u8 , 83u8 , 142u8 , 6u8 , 236u8 , 183u8 , 193u8 , 235u8 , 253u8 , 126u8 , 153u8 , 185u8 , 74u8 , 117u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_democracy :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A motion has been proposed by a public account."] pub struct Proposed { pub proposal_index : :: core :: primitive :: u32 , pub deposit : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Proposed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Proposed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A public proposal has been tabled for referendum vote."] pub struct Tabled { pub proposal_index : :: core :: primitive :: u32 , pub deposit : :: core :: primitive :: u128 , pub depositors : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } impl :: subxt :: events :: StaticEvent for Tabled { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Tabled" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An external proposal has been tabled."] pub struct ExternalTabled ; impl :: subxt :: events :: StaticEvent for ExternalTabled { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "ExternalTabled" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A referendum has begun."] pub struct Started { pub ref_index : :: core :: primitive :: u32 , pub threshold : runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold , } impl :: subxt :: events :: StaticEvent for Started { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Started" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A proposal has been approved by referendum."] pub struct Passed { pub ref_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for Passed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Passed" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A proposal has been rejected by referendum."] pub struct NotPassed { pub ref_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for NotPassed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "NotPassed" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A referendum has been cancelled."] pub struct Cancelled { pub ref_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for Cancelled { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Cancelled" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A proposal has been enacted."] pub struct Executed { pub ref_index : :: core :: primitive :: u32 , pub result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: events :: StaticEvent for Executed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Executed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An account has delegated their vote to another account."] pub struct Delegated { pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub target : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for Delegated { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Delegated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An account has cancelled a previous delegation operation."] pub struct Undelegated { pub account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for Undelegated { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Undelegated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An external proposal has been vetoed."] pub struct Vetoed { pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub until : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for Vetoed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Vetoed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A proposal's preimage was noted, and the deposit taken."] pub struct PreimageNoted { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub deposit : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for PreimageNoted { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "PreimageNoted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A proposal preimage was removed and used (the deposit was returned)."] pub struct PreimageUsed { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub provider : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub deposit : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for PreimageUsed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "PreimageUsed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A proposal could not be executed because its preimage was invalid."] pub struct PreimageInvalid { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub ref_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for PreimageInvalid { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "PreimageInvalid" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A proposal could not be executed because its preimage was missing."] pub struct PreimageMissing { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub ref_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for PreimageMissing { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "PreimageMissing" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A registered preimage was removed and the deposit collected by the reaper."] pub struct PreimageReaped { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub provider : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub deposit : :: core :: primitive :: u128 , pub reaper : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for PreimageReaped { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "PreimageReaped" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A proposal_hash has been blacklisted permanently."] pub struct Blacklisted { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , } impl :: subxt :: events :: StaticEvent for Blacklisted { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Blacklisted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An account has voted in a referendum"] pub struct Voted { pub voter : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub ref_index : :: core :: primitive :: u32 , pub vote : runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > , } impl :: subxt :: events :: StaticEvent for Voted { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Voted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An account has secconded a proposal"] pub struct Seconded { pub seconder : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub prop_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for Seconded { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Seconded" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A proposal got canceled."] pub struct ProposalCanceled { pub prop_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for ProposalCanceled { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "ProposalCanceled" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The number of (public) proposals that have been made so far."] pub fn public_prop_count (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "PublicPropCount" , vec ! [] , [91u8 , 14u8 , 171u8 , 94u8 , 37u8 , 157u8 , 46u8 , 157u8 , 254u8 , 13u8 , 68u8 , 144u8 , 23u8 , 146u8 , 128u8 , 159u8 , 9u8 , 174u8 , 74u8 , 174u8 , 218u8 , 197u8 , 23u8 , 235u8 , 152u8 , 226u8 , 216u8 , 4u8 , 120u8 , 121u8 , 27u8 , 138u8 ,]) } # [doc = " The public proposals. Unsorted. The second item is the proposal's hash."] pub fn public_props (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: subxt :: ext :: sp_core :: H256 , :: subxt :: ext :: sp_core :: crypto :: AccountId32 ,) > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "PublicProps" , vec ! [] , [151u8 , 247u8 , 196u8 , 97u8 , 171u8 , 230u8 , 55u8 , 45u8 , 220u8 , 16u8 , 12u8 , 28u8 , 22u8 , 58u8 , 127u8 , 179u8 , 130u8 , 192u8 , 115u8 , 165u8 , 5u8 , 173u8 , 87u8 , 104u8 , 7u8 , 186u8 , 114u8 , 47u8 , 162u8 , 182u8 , 252u8 , 154u8 ,]) } # [doc = " Those who have locked a deposit."] # [doc = ""] # [doc = " TWOX-NOTE: Safe, as increasing integer keys are safe."] pub fn deposit_of (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , :: core :: primitive :: u128 ,) > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "DepositOf" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [153u8 , 236u8 , 152u8 , 224u8 , 221u8 , 90u8 , 204u8 , 183u8 , 222u8 , 160u8 , 227u8 , 26u8 , 8u8 , 110u8 , 230u8 , 102u8 , 133u8 , 186u8 , 66u8 , 2u8 , 84u8 , 31u8 , 236u8 , 228u8 , 202u8 , 75u8 , 17u8 , 97u8 , 133u8 , 232u8 , 64u8 , 7u8 ,]) } # [doc = " Those who have locked a deposit."] # [doc = ""] # [doc = " TWOX-NOTE: Safe, as increasing integer keys are safe."] pub fn deposit_of_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , :: core :: primitive :: u128 ,) > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "DepositOf" , Vec :: new () , [153u8 , 236u8 , 152u8 , 224u8 , 221u8 , 90u8 , 204u8 , 183u8 , 222u8 , 160u8 , 227u8 , 26u8 , 8u8 , 110u8 , 230u8 , 102u8 , 133u8 , 186u8 , 66u8 , 2u8 , 84u8 , 31u8 , 236u8 , 228u8 , 202u8 , 75u8 , 17u8 , 97u8 , 133u8 , 232u8 , 64u8 , 7u8 ,]) } # [doc = " Map of hashes to the proposal preimage, along with who registered it and their deposit."] # [doc = " The block number is the block at which it was deposited."] pub fn preimages (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: H256 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_democracy :: PreimageStatus < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "Preimages" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Identity)] , [206u8 , 131u8 , 7u8 , 129u8 , 172u8 , 231u8 , 164u8 , 220u8 , 129u8 , 0u8 , 204u8 , 227u8 , 231u8 , 244u8 , 61u8 , 145u8 , 144u8 , 146u8 , 173u8 , 215u8 , 174u8 , 218u8 , 192u8 , 83u8 , 174u8 , 99u8 , 87u8 , 102u8 , 98u8 , 235u8 , 138u8 , 127u8 ,]) } # [doc = " Map of hashes to the proposal preimage, along with who registered it and their deposit."] # [doc = " The block number is the block at which it was deposited."] pub fn preimages_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_democracy :: PreimageStatus < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "Preimages" , Vec :: new () , [206u8 , 131u8 , 7u8 , 129u8 , 172u8 , 231u8 , 164u8 , 220u8 , 129u8 , 0u8 , 204u8 , 227u8 , 231u8 , 244u8 , 61u8 , 145u8 , 144u8 , 146u8 , 173u8 , 215u8 , 174u8 , 218u8 , 192u8 , 83u8 , 174u8 , 99u8 , 87u8 , 102u8 , 98u8 , 235u8 , 138u8 , 127u8 ,]) } # [doc = " The next free referendum index, aka the number of referenda started so far."] pub fn referendum_count (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "ReferendumCount" , vec ! [] , [153u8 , 210u8 , 106u8 , 244u8 , 156u8 , 70u8 , 124u8 , 251u8 , 123u8 , 75u8 , 7u8 , 189u8 , 199u8 , 145u8 , 95u8 , 119u8 , 137u8 , 11u8 , 240u8 , 160u8 , 151u8 , 248u8 , 229u8 , 231u8 , 89u8 , 222u8 , 18u8 , 237u8 , 144u8 , 78u8 , 99u8 , 58u8 ,]) } # [doc = " The lowest referendum index representing an unbaked referendum. Equal to"] # [doc = " `ReferendumCount` if there isn't a unbaked referendum."] pub fn lowest_unbaked (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "LowestUnbaked" , vec ! [] , [4u8 , 51u8 , 108u8 , 11u8 , 48u8 , 165u8 , 19u8 , 251u8 , 182u8 , 76u8 , 163u8 , 73u8 , 227u8 , 2u8 , 212u8 , 74u8 , 128u8 , 27u8 , 165u8 , 164u8 , 111u8 , 22u8 , 209u8 , 190u8 , 103u8 , 7u8 , 116u8 , 16u8 , 160u8 , 144u8 , 123u8 , 64u8 ,]) } # [doc = " Information concerning any given referendum."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE as indexes are not under an attackers control."] pub fn referendum_info_of (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_democracy :: types :: ReferendumInfo < :: core :: primitive :: u32 , :: subxt :: ext :: sp_core :: H256 , :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "ReferendumInfoOf" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [132u8 , 4u8 , 108u8 , 126u8 , 91u8 , 168u8 , 18u8 , 17u8 , 86u8 , 79u8 , 219u8 , 222u8 , 195u8 , 137u8 , 149u8 , 177u8 , 101u8 , 134u8 , 130u8 , 41u8 , 217u8 , 109u8 , 18u8 , 18u8 , 33u8 , 206u8 , 117u8 , 131u8 , 98u8 , 26u8 , 51u8 , 8u8 ,]) } # [doc = " Information concerning any given referendum."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE as indexes are not under an attackers control."] pub fn referendum_info_of_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_democracy :: types :: ReferendumInfo < :: core :: primitive :: u32 , :: subxt :: ext :: sp_core :: H256 , :: core :: primitive :: u128 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "ReferendumInfoOf" , Vec :: new () , [132u8 , 4u8 , 108u8 , 126u8 , 91u8 , 168u8 , 18u8 , 17u8 , 86u8 , 79u8 , 219u8 , 222u8 , 195u8 , 137u8 , 149u8 , 177u8 , 101u8 , 134u8 , 130u8 , 41u8 , 217u8 , 109u8 , 18u8 , 18u8 , 33u8 , 206u8 , 117u8 , 131u8 , 98u8 , 26u8 , 51u8 , 8u8 ,]) } # [doc = " All votes for a particular voter. We store the balance for the number of votes that we"] # [doc = " have recorded. The second item is the total amount of delegations, that will be added."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway."] pub fn voting_of (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_democracy :: vote :: Voting < :: core :: primitive :: u128 , :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "VotingOf" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [211u8 , 38u8 , 232u8 , 65u8 , 215u8 , 97u8 , 157u8 , 208u8 , 177u8 , 150u8 , 250u8 , 226u8 , 72u8 , 185u8 , 187u8 , 162u8 , 80u8 , 67u8 , 195u8 , 87u8 , 190u8 , 180u8 , 167u8 , 137u8 , 253u8 , 142u8 , 34u8 , 158u8 , 249u8 , 168u8 , 209u8 , 18u8 ,]) } # [doc = " All votes for a particular voter. We store the balance for the number of votes that we"] # [doc = " have recorded. The second item is the total amount of delegations, that will be added."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway."] pub fn voting_of_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_democracy :: vote :: Voting < :: core :: primitive :: u128 , :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "VotingOf" , Vec :: new () , [211u8 , 38u8 , 232u8 , 65u8 , 215u8 , 97u8 , 157u8 , 208u8 , 177u8 , 150u8 , 250u8 , 226u8 , 72u8 , 185u8 , 187u8 , 162u8 , 80u8 , 67u8 , 195u8 , 87u8 , 190u8 , 180u8 , 167u8 , 137u8 , 253u8 , 142u8 , 34u8 , 158u8 , 249u8 , 168u8 , 209u8 , 18u8 ,]) } # [doc = " True if the last referendum tabled was submitted externally. False if it was a public"] # [doc = " proposal."] pub fn last_tabled_was_external (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: bool > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "LastTabledWasExternal" , vec ! [] , [3u8 , 67u8 , 106u8 , 1u8 , 89u8 , 204u8 , 4u8 , 145u8 , 121u8 , 44u8 , 34u8 , 76u8 , 18u8 , 206u8 , 65u8 , 214u8 , 222u8 , 82u8 , 31u8 , 223u8 , 144u8 , 169u8 , 17u8 , 6u8 , 138u8 , 36u8 , 113u8 , 155u8 , 241u8 , 106u8 , 189u8 , 218u8 ,]) } # [doc = " The referendum to be tabled whenever it would be valid to table an external proposal."] # [doc = " This happens when a referendum needs to be tabled and one of two conditions are met:"] # [doc = " - `LastTabledWasExternal` is `false`; or"] # [doc = " - `PublicProps` is empty."] pub fn next_external (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: subxt :: ext :: sp_core :: H256 , runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold ,) > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "NextExternal" , vec ! [] , [123u8 , 49u8 , 252u8 , 184u8 , 75u8 , 204u8 , 16u8 , 130u8 , 43u8 , 109u8 , 62u8 , 113u8 , 95u8 , 0u8 , 20u8 , 163u8 , 186u8 , 210u8 , 253u8 , 33u8 , 58u8 , 121u8 , 36u8 , 80u8 , 9u8 , 242u8 , 180u8 , 230u8 , 167u8 , 250u8 , 32u8 , 180u8 ,]) } # [doc = " A record of who vetoed what. Maps proposal hash to a possible existent block number"] # [doc = " (until when it may not be resubmitted) and who vetoed it."] pub fn blacklist (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: H256 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: core :: primitive :: u32 , :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "Blacklist" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Identity)] , [93u8 , 165u8 , 219u8 , 135u8 , 41u8 , 114u8 , 144u8 , 133u8 , 171u8 , 83u8 , 153u8 , 157u8 , 79u8 , 14u8 , 170u8 , 29u8 , 179u8 , 23u8 , 222u8 , 124u8 , 237u8 , 253u8 , 122u8 , 21u8 , 186u8 , 209u8 , 184u8 , 89u8 , 197u8 , 5u8 , 178u8 , 255u8 ,]) } # [doc = " A record of who vetoed what. Maps proposal hash to a possible existent block number"] # [doc = " (until when it may not be resubmitted) and who vetoed it."] pub fn blacklist_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: core :: primitive :: u32 , :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "Blacklist" , Vec :: new () , [93u8 , 165u8 , 219u8 , 135u8 , 41u8 , 114u8 , 144u8 , 133u8 , 171u8 , 83u8 , 153u8 , 157u8 , 79u8 , 14u8 , 170u8 , 29u8 , 179u8 , 23u8 , 222u8 , 124u8 , 237u8 , 253u8 , 122u8 , 21u8 , 186u8 , 209u8 , 184u8 , 89u8 , 197u8 , 5u8 , 178u8 , 255u8 ,]) } # [doc = " Record of all proposals that have been subject to emergency cancellation."] pub fn cancellations (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: H256 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: bool > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "Cancellations" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Identity)] , [154u8 , 36u8 , 172u8 , 46u8 , 65u8 , 218u8 , 30u8 , 151u8 , 173u8 , 186u8 , 166u8 , 79u8 , 35u8 , 226u8 , 94u8 , 200u8 , 67u8 , 44u8 , 47u8 , 7u8 , 17u8 , 89u8 , 169u8 , 166u8 , 236u8 , 101u8 , 68u8 , 54u8 , 114u8 , 141u8 , 177u8 , 135u8 ,]) } # [doc = " Record of all proposals that have been subject to emergency cancellation."] pub fn cancellations_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: bool > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "Cancellations" , Vec :: new () , [154u8 , 36u8 , 172u8 , 46u8 , 65u8 , 218u8 , 30u8 , 151u8 , 173u8 , 186u8 , 166u8 , 79u8 , 35u8 , 226u8 , 94u8 , 200u8 , 67u8 , 44u8 , 47u8 , 7u8 , 17u8 , 89u8 , 169u8 , 166u8 , 236u8 , 101u8 , 68u8 , 54u8 , 114u8 , 141u8 , 177u8 , 135u8 ,]) } # [doc = " Storage version of the pallet."] # [doc = ""] # [doc = " New networks start with last version."] pub fn storage_version (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_democracy :: Releases > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Democracy" , "StorageVersion" , vec ! [] , [39u8 , 219u8 , 134u8 , 64u8 , 250u8 , 96u8 , 95u8 , 156u8 , 100u8 , 236u8 , 18u8 , 78u8 , 59u8 , 146u8 , 5u8 , 245u8 , 113u8 , 125u8 , 220u8 , 140u8 , 125u8 , 5u8 , 194u8 , 134u8 , 248u8 , 95u8 , 250u8 , 108u8 , 142u8 , 230u8 , 21u8 , 120u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The period between a proposal being approved and enacted."] # [doc = ""] # [doc = " It should generally be a little more than the unstake period to ensure that"] # [doc = " voting stakers have an opportunity to remove themselves from the system in the case"] # [doc = " where they are on the losing side of a vote."] pub fn enactment_period (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Democracy" , "EnactmentPeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " How often (in blocks) new public referenda are launched."] pub fn launch_period (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Democracy" , "LaunchPeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " How often (in blocks) to check for new votes."] pub fn voting_period (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Democracy" , "VotingPeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The minimum period of vote locking."] # [doc = ""] # [doc = " It should be no shorter than enactment period to ensure that in the case of an approval,"] # [doc = " those successful voters are locked into the consequences that their votes entail."] pub fn vote_locking_period (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Democracy" , "VoteLockingPeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The minimum amount to be used as a deposit for a public referendum proposal."] pub fn minimum_deposit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Democracy" , "MinimumDeposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " Indicator for whether an emergency origin is even allowed to happen. Some chains may"] # [doc = " want to set this permanently to `false`, others may want to condition it on things such"] # [doc = " as an upgrade having happened recently."] pub fn instant_allowed (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: bool >> { :: subxt :: constants :: StaticConstantAddress :: new ("Democracy" , "InstantAllowed" , [165u8 , 28u8 , 112u8 , 190u8 , 18u8 , 129u8 , 182u8 , 206u8 , 237u8 , 1u8 , 68u8 , 252u8 , 125u8 , 234u8 , 185u8 , 50u8 , 149u8 , 164u8 , 47u8 , 126u8 , 134u8 , 100u8 , 14u8 , 86u8 , 209u8 , 39u8 , 20u8 , 4u8 , 233u8 , 115u8 , 102u8 , 131u8 ,]) } # [doc = " Minimum voting period allowed for a fast-track referendum."] pub fn fast_track_voting_period (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Democracy" , "FastTrackVotingPeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Period in blocks where an external proposal may not be re-submitted after being vetoed."] pub fn cooloff_period (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Democracy" , "CooloffPeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The amount of balance that must be deposited per byte of preimage stored."] pub fn preimage_byte_deposit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Democracy" , "PreimageByteDeposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The maximum number of votes for an account."] # [doc = ""] # [doc = " Also used to compute weight, an overly big value can"] # [doc = " lead to extrinsic with very big weight: see `delegate` for instance."] pub fn max_votes (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Democracy" , "MaxVotes" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of public proposals that can exist at any time."] pub fn max_proposals (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Democracy" , "MaxProposals" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod staking { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Bond { pub controller : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] pub value : :: core :: primitive :: u128 , pub payee : runtime_types :: pallet_staking :: RewardDestination < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct BondExtra { # [codec (compact)] pub max_additional : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Unbond { # [codec (compact)] pub value : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct WithdrawUnbonded { pub num_slashing_spans : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Validate { pub prefs : runtime_types :: pallet_staking :: ValidatorPrefs , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Nominate { pub targets : :: std :: vec :: Vec < :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Chill ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetPayee { pub payee : runtime_types :: pallet_staking :: RewardDestination < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetController { pub controller : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetValidatorCount { # [codec (compact)] pub new : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct IncreaseValidatorCount { # [codec (compact)] pub additional : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ScaleValidatorCount { pub factor : runtime_types :: sp_arithmetic :: per_things :: Percent , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ForceNoEras ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ForceNewEra ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetInvulnerables { pub invulnerables : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ForceUnstake { pub stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub num_slashing_spans : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ForceNewEraAlways ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CancelDeferredSlash { pub era : :: core :: primitive :: u32 , pub slash_indices : :: std :: vec :: Vec < :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct PayoutStakers { pub validator_stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub era : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Rebond { # [codec (compact)] pub value : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ReapStash { pub stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub num_slashing_spans : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Kick { pub who : :: std :: vec :: Vec < :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetStakingConfigs { pub min_nominator_bond : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u128 > , pub min_validator_bond : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u128 > , pub max_nominator_count : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u32 > , pub max_validator_count : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u32 > , pub chill_threshold : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < runtime_types :: sp_arithmetic :: per_things :: Percent > , pub min_commission : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < runtime_types :: sp_arithmetic :: per_things :: Perbill > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ChillOther { pub controller : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ForceApplyMinCommission { pub validator_stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Take the origin account as a stash and lock up `value` of its balance. `controller` will"] # [doc = "be the account that controls it."] # [doc = ""] # [doc = "`value` must be more than the `minimum_balance` specified by `T::Currency`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the stash account."] # [doc = ""] # [doc = "Emits `Bonded`."] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Moderate complexity."] # [doc = "- O(1)."] # [doc = "- Three extra DB entries."] # [doc = ""] # [doc = "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned"] # [doc = "unless the `origin` falls below _existential deposit_ and gets removed as dust."] # [doc = "------------------"] # [doc = "# </weight>"] pub fn bond (& self , controller : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , value : :: core :: primitive :: u128 , payee : runtime_types :: pallet_staking :: RewardDestination < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: tx :: StaticTxPayload < Bond > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "bond" , Bond { controller , value , payee , } , [215u8 , 211u8 , 69u8 , 215u8 , 33u8 , 158u8 , 62u8 , 3u8 , 31u8 , 216u8 , 213u8 , 188u8 , 151u8 , 43u8 , 165u8 , 154u8 , 117u8 , 163u8 , 190u8 , 227u8 , 116u8 , 70u8 , 155u8 , 178u8 , 64u8 , 174u8 , 203u8 , 179u8 , 214u8 , 187u8 , 176u8 , 10u8 ,]) } # [doc = "Add some extra amount that have appeared in the stash `free_balance` into the balance up"] # [doc = "for staking."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."] # [doc = ""] # [doc = "Use this if there are additional funds in your stash account that you wish to bond."] # [doc = "Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose"] # [doc = "any limitation on the amount that can be added."] # [doc = ""] # [doc = "Emits `Bonded`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Insignificant complexity."] # [doc = "- O(1)."] # [doc = "# </weight>"] pub fn bond_extra (& self , max_additional : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < BondExtra > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "bond_extra" , BondExtra { max_additional , } , [60u8 , 45u8 , 82u8 , 223u8 , 113u8 , 95u8 , 0u8 , 71u8 , 59u8 , 108u8 , 228u8 , 9u8 , 95u8 , 210u8 , 113u8 , 106u8 , 252u8 , 15u8 , 19u8 , 128u8 , 11u8 , 187u8 , 4u8 , 151u8 , 103u8 , 143u8 , 24u8 , 33u8 , 149u8 , 82u8 , 35u8 , 192u8 ,]) } # [doc = "Schedule a portion of the stash to be unlocked ready for transfer out after the bond"] # [doc = "period ends. If this leaves an amount actively bonded less than"] # [doc = "T::Currency::minimum_balance(), then it is increased to the full amount."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "Once the unlock period is done, you can call `withdraw_unbonded` to actually move"] # [doc = "the funds out of management ready for transfer."] # [doc = ""] # [doc = "No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)"] # [doc = "can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need"] # [doc = "to be called first to remove some of the chunks (if possible)."] # [doc = ""] # [doc = "If a user encounters the `InsufficientBond` error when calling this extrinsic,"] # [doc = "they should call `chill` first in order to free up their bonded funds."] # [doc = ""] # [doc = "Emits `Unbonded`."] # [doc = ""] # [doc = "See also [`Call::withdraw_unbonded`]."] pub fn unbond (& self , value : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < Unbond > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "unbond" , Unbond { value , } , [85u8 , 62u8 , 34u8 , 127u8 , 60u8 , 241u8 , 134u8 , 60u8 , 125u8 , 91u8 , 31u8 , 193u8 , 50u8 , 230u8 , 237u8 , 42u8 , 114u8 , 230u8 , 240u8 , 146u8 , 14u8 , 109u8 , 185u8 , 151u8 , 148u8 , 44u8 , 147u8 , 182u8 , 192u8 , 253u8 , 51u8 , 87u8 ,]) } # [doc = "Remove any unlocked chunks from the `unlocking` queue from our management."] # [doc = ""] # [doc = "This essentially frees up that balance to be used by the stash account to do"] # [doc = "whatever it wants."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller."] # [doc = ""] # [doc = "Emits `Withdrawn`."] # [doc = ""] # [doc = "See also [`Call::unbond`]."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Complexity O(S) where S is the number of slashing spans to remove"] # [doc = "NOTE: Weight annotation is the kill scenario, we refund otherwise."] # [doc = "# </weight>"] pub fn withdraw_unbonded (& self , num_slashing_spans : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < WithdrawUnbonded > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "withdraw_unbonded" , WithdrawUnbonded { num_slashing_spans , } , [95u8 , 223u8 , 122u8 , 217u8 , 76u8 , 208u8 , 86u8 , 129u8 , 31u8 , 104u8 , 70u8 , 154u8 , 23u8 , 250u8 , 165u8 , 192u8 , 149u8 , 249u8 , 158u8 , 159u8 , 194u8 , 224u8 , 118u8 , 134u8 , 204u8 , 157u8 , 72u8 , 136u8 , 19u8 , 193u8 , 183u8 , 84u8 ,]) } # [doc = "Declare the desire to validate for the origin controller."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] pub fn validate (& self , prefs : runtime_types :: pallet_staking :: ValidatorPrefs ,) -> :: subxt :: tx :: StaticTxPayload < Validate > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "validate" , Validate { prefs , } , [191u8 , 116u8 , 139u8 , 35u8 , 250u8 , 211u8 , 86u8 , 240u8 , 35u8 , 9u8 , 19u8 , 44u8 , 148u8 , 35u8 , 91u8 , 106u8 , 200u8 , 172u8 , 108u8 , 145u8 , 194u8 , 146u8 , 61u8 , 145u8 , 233u8 , 168u8 , 2u8 , 26u8 , 145u8 , 101u8 , 114u8 , 157u8 ,]) } # [doc = "Declare the desire to nominate `targets` for the origin controller."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- The transaction's complexity is proportional to the size of `targets` (N)"] # [doc = "which is capped at CompactAssignments::LIMIT (T::MaxNominations)."] # [doc = "- Both the reads and writes follow a similar pattern."] # [doc = "# </weight>"] pub fn nominate (& self , targets : :: std :: vec :: Vec < :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > > ,) -> :: subxt :: tx :: StaticTxPayload < Nominate > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "nominate" , Nominate { targets , } , [112u8 , 162u8 , 70u8 , 26u8 , 74u8 , 7u8 , 188u8 , 193u8 , 210u8 , 247u8 , 27u8 , 189u8 , 133u8 , 137u8 , 33u8 , 155u8 , 255u8 , 171u8 , 122u8 , 68u8 , 175u8 , 247u8 , 139u8 , 253u8 , 97u8 , 187u8 , 254u8 , 201u8 , 66u8 , 166u8 , 226u8 , 90u8 ,]) } # [doc = "Declare no desire to either validate or nominate."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Insignificant complexity."] # [doc = "- Contains one read."] # [doc = "- Writes are limited to the `origin` account key."] # [doc = "# </weight>"] pub fn chill (& self ,) -> :: subxt :: tx :: StaticTxPayload < Chill > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "chill" , Chill { } , [94u8 , 20u8 , 196u8 , 31u8 , 220u8 , 125u8 , 115u8 , 167u8 , 140u8 , 3u8 , 20u8 , 132u8 , 81u8 , 120u8 , 215u8 , 166u8 , 230u8 , 56u8 , 16u8 , 222u8 , 31u8 , 153u8 , 120u8 , 62u8 , 153u8 , 67u8 , 220u8 , 239u8 , 11u8 , 234u8 , 127u8 , 122u8 ,]) } # [doc = "(Re-)set the payment target for a controller."] # [doc = ""] # [doc = "Effects will be felt instantly (as soon as this function is completed successfully)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Insignificant complexity."] # [doc = "- Contains a limited number of reads."] # [doc = "- Writes are limited to the `origin` account key."] # [doc = "---------"] # [doc = "- Weight: O(1)"] # [doc = "- DB Weight:"] # [doc = "    - Read: Ledger"] # [doc = "    - Write: Payee"] # [doc = "# </weight>"] pub fn set_payee (& self , payee : runtime_types :: pallet_staking :: RewardDestination < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: tx :: StaticTxPayload < SetPayee > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "set_payee" , SetPayee { payee , } , [96u8 , 8u8 , 254u8 , 164u8 , 87u8 , 46u8 , 120u8 , 11u8 , 197u8 , 63u8 , 20u8 , 178u8 , 167u8 , 236u8 , 149u8 , 245u8 , 14u8 , 171u8 , 108u8 , 195u8 , 250u8 , 133u8 , 0u8 , 75u8 , 192u8 , 159u8 , 84u8 , 220u8 , 242u8 , 133u8 , 60u8 , 62u8 ,]) } # [doc = "(Re-)set the controller of a stash."] # [doc = ""] # [doc = "Effects will be felt instantly (as soon as this function is completed successfully)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Insignificant complexity."] # [doc = "- Contains a limited number of reads."] # [doc = "- Writes are limited to the `origin` account key."] # [doc = "----------"] # [doc = "Weight: O(1)"] # [doc = "DB Weight:"] # [doc = "- Read: Bonded, Ledger New Controller, Ledger Old Controller"] # [doc = "- Write: Bonded, Ledger New Controller, Ledger Old Controller"] # [doc = "# </weight>"] pub fn set_controller (& self , controller : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < SetController > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "set_controller" , SetController { controller , } , [165u8 , 250u8 , 213u8 , 32u8 , 179u8 , 163u8 , 15u8 , 35u8 , 14u8 , 152u8 , 56u8 , 171u8 , 43u8 , 101u8 , 7u8 , 167u8 , 178u8 , 60u8 , 89u8 , 186u8 , 59u8 , 28u8 , 82u8 , 159u8 , 13u8 , 96u8 , 168u8 , 123u8 , 194u8 , 212u8 , 205u8 , 184u8 ,]) } # [doc = "Sets the ideal number of validators."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Weight: O(1)"] # [doc = "Write: Validator Count"] # [doc = "# </weight>"] pub fn set_validator_count (& self , new : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < SetValidatorCount > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "set_validator_count" , SetValidatorCount { new , } , [55u8 , 232u8 , 95u8 , 66u8 , 228u8 , 217u8 , 11u8 , 27u8 , 3u8 , 202u8 , 199u8 , 242u8 , 70u8 , 160u8 , 250u8 , 187u8 , 194u8 , 91u8 , 15u8 , 36u8 , 215u8 , 36u8 , 160u8 , 108u8 , 251u8 , 60u8 , 240u8 , 202u8 , 249u8 , 235u8 , 28u8 , 94u8 ,]) } # [doc = "Increments the ideal number of validators."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Same as [`Self::set_validator_count`]."] # [doc = "# </weight>"] pub fn increase_validator_count (& self , additional : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < IncreaseValidatorCount > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "increase_validator_count" , IncreaseValidatorCount { additional , } , [239u8 , 184u8 , 155u8 , 213u8 , 25u8 , 22u8 , 193u8 , 13u8 , 102u8 , 192u8 , 82u8 , 153u8 , 249u8 , 192u8 , 60u8 , 158u8 , 8u8 , 78u8 , 175u8 , 219u8 , 46u8 , 51u8 , 222u8 , 193u8 , 193u8 , 201u8 , 78u8 , 90u8 , 58u8 , 86u8 , 196u8 , 17u8 ,]) } # [doc = "Scale up the ideal number of validators by a factor."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Same as [`Self::set_validator_count`]."] # [doc = "# </weight>"] pub fn scale_validator_count (& self , factor : runtime_types :: sp_arithmetic :: per_things :: Percent ,) -> :: subxt :: tx :: StaticTxPayload < ScaleValidatorCount > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "scale_validator_count" , ScaleValidatorCount { factor , } , [198u8 , 68u8 , 227u8 , 94u8 , 110u8 , 157u8 , 209u8 , 217u8 , 112u8 , 37u8 , 78u8 , 142u8 , 12u8 , 193u8 , 219u8 , 167u8 , 149u8 , 112u8 , 49u8 , 139u8 , 74u8 , 81u8 , 172u8 , 72u8 , 253u8 , 224u8 , 56u8 , 194u8 , 185u8 , 90u8 , 87u8 , 125u8 ,]) } # [doc = "Force there to be no new eras indefinitely."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# Warning"] # [doc = ""] # [doc = "The election process starts multiple blocks before the end of the era."] # [doc = "Thus the election process may be ongoing when this is called. In this case the"] # [doc = "election will continue until the next era is triggered."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- No arguments."] # [doc = "- Weight: O(1)"] # [doc = "- Write: ForceEra"] # [doc = "# </weight>"] pub fn force_no_eras (& self ,) -> :: subxt :: tx :: StaticTxPayload < ForceNoEras > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "force_no_eras" , ForceNoEras { } , [16u8 , 81u8 , 207u8 , 168u8 , 23u8 , 236u8 , 11u8 , 75u8 , 141u8 , 107u8 , 92u8 , 2u8 , 53u8 , 111u8 , 252u8 , 116u8 , 91u8 , 120u8 , 75u8 , 24u8 , 125u8 , 53u8 , 9u8 , 28u8 , 242u8 , 87u8 , 245u8 , 55u8 , 40u8 , 103u8 , 151u8 , 178u8 ,]) } # [doc = "Force there to be a new era at the end of the next session. After this, it will be"] # [doc = "reset to normal (non-forced) behaviour."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# Warning"] # [doc = ""] # [doc = "The election process starts multiple blocks before the end of the era."] # [doc = "If this is called just before a new era is triggered, the election process may not"] # [doc = "have enough blocks to get a result."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- No arguments."] # [doc = "- Weight: O(1)"] # [doc = "- Write ForceEra"] # [doc = "# </weight>"] pub fn force_new_era (& self ,) -> :: subxt :: tx :: StaticTxPayload < ForceNewEra > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "force_new_era" , ForceNewEra { } , [230u8 , 242u8 , 169u8 , 196u8 , 78u8 , 145u8 , 24u8 , 191u8 , 113u8 , 68u8 , 5u8 , 138u8 , 48u8 , 51u8 , 109u8 , 126u8 , 73u8 , 136u8 , 162u8 , 158u8 , 174u8 , 201u8 , 213u8 , 230u8 , 215u8 , 44u8 , 200u8 , 32u8 , 75u8 , 27u8 , 23u8 , 254u8 ,]) } # [doc = "Set the validators who cannot be slashed (if any)."] # [doc = ""] # [doc = "The dispatch origin must be Root."] pub fn set_invulnerables (& self , invulnerables : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: tx :: StaticTxPayload < SetInvulnerables > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "set_invulnerables" , SetInvulnerables { invulnerables , } , [2u8 , 148u8 , 221u8 , 111u8 , 153u8 , 48u8 , 222u8 , 36u8 , 228u8 , 84u8 , 18u8 , 35u8 , 168u8 , 239u8 , 53u8 , 245u8 , 27u8 , 76u8 , 18u8 , 203u8 , 206u8 , 9u8 , 8u8 , 81u8 , 35u8 , 224u8 , 22u8 , 133u8 , 58u8 , 99u8 , 103u8 , 39u8 ,]) } # [doc = "Force a current staker to become completely unstaked, immediately."] # [doc = ""] # [doc = "The dispatch origin must be Root."] pub fn force_unstake (& self , stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , num_slashing_spans : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < ForceUnstake > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "force_unstake" , ForceUnstake { stash , num_slashing_spans , } , [94u8 , 247u8 , 238u8 , 47u8 , 250u8 , 6u8 , 96u8 , 175u8 , 173u8 , 123u8 , 161u8 , 187u8 , 162u8 , 214u8 , 176u8 , 233u8 , 33u8 , 33u8 , 167u8 , 239u8 , 40u8 , 223u8 , 19u8 , 131u8 , 230u8 , 39u8 , 175u8 , 200u8 , 36u8 , 182u8 , 76u8 , 207u8 ,]) } # [doc = "Force there to be a new era at the end of sessions indefinitely."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# Warning"] # [doc = ""] # [doc = "The election process starts multiple blocks before the end of the era."] # [doc = "If this is called just before a new era is triggered, the election process may not"] # [doc = "have enough blocks to get a result."] pub fn force_new_era_always (& self ,) -> :: subxt :: tx :: StaticTxPayload < ForceNewEraAlways > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "force_new_era_always" , ForceNewEraAlways { } , [179u8 , 118u8 , 189u8 , 54u8 , 248u8 , 141u8 , 207u8 , 142u8 , 80u8 , 37u8 , 241u8 , 185u8 , 138u8 , 254u8 , 117u8 , 147u8 , 225u8 , 118u8 , 34u8 , 177u8 , 197u8 , 158u8 , 8u8 , 82u8 , 202u8 , 108u8 , 208u8 , 26u8 , 64u8 , 33u8 , 74u8 , 43u8 ,]) } # [doc = "Cancel enactment of a deferred slash."] # [doc = ""] # [doc = "Can be called by the `T::SlashCancelOrigin`."] # [doc = ""] # [doc = "Parameters: era and indices of the slashes for that era to kill."] pub fn cancel_deferred_slash (& self , era : :: core :: primitive :: u32 , slash_indices : :: std :: vec :: Vec < :: core :: primitive :: u32 > ,) -> :: subxt :: tx :: StaticTxPayload < CancelDeferredSlash > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "cancel_deferred_slash" , CancelDeferredSlash { era , slash_indices , } , [120u8 , 57u8 , 162u8 , 105u8 , 91u8 , 250u8 , 129u8 , 240u8 , 110u8 , 234u8 , 170u8 , 98u8 , 164u8 , 65u8 , 106u8 , 101u8 , 19u8 , 88u8 , 146u8 , 210u8 , 171u8 , 44u8 , 37u8 , 50u8 , 65u8 , 178u8 , 37u8 , 223u8 , 239u8 , 197u8 , 116u8 , 168u8 ,]) } # [doc = "Pay out all the stakers behind a single validator for a single era."] # [doc = ""] # [doc = "- `validator_stash` is the stash account of the validator. Their nominators, up to"] # [doc = "  `T::MaxNominatorRewardedPerValidator`, will also receive their rewards."] # [doc = "- `era` may be any era between `[current_era - history_depth; current_era]`."] # [doc = ""] # [doc = "The origin of this call must be _Signed_. Any account can call this function, even if"] # [doc = "it is not one of the stakers."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Time complexity: at most O(MaxNominatorRewardedPerValidator)."] # [doc = "- Contains a limited number of reads and writes."] # [doc = "-----------"] # [doc = "N is the Number of payouts for the validator (including the validator)"] # [doc = "Weight:"] # [doc = "- Reward Destination Staked: O(N)"] # [doc = "- Reward Destination Controller (Creating): O(N)"] # [doc = ""] # [doc = "  NOTE: weights are assuming that payouts are made to alive stash account (Staked)."] # [doc = "  Paying even a dead controller is cheaper weight-wise. We don't do any refunds here."] # [doc = "# </weight>"] pub fn payout_stakers (& self , validator_stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , era : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < PayoutStakers > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "payout_stakers" , PayoutStakers { validator_stash , era , } , [184u8 , 194u8 , 33u8 , 118u8 , 7u8 , 203u8 , 89u8 , 119u8 , 214u8 , 76u8 , 178u8 , 20u8 , 82u8 , 111u8 , 57u8 , 132u8 , 212u8 , 43u8 , 232u8 , 91u8 , 252u8 , 49u8 , 42u8 , 115u8 , 1u8 , 181u8 , 154u8 , 207u8 , 144u8 , 206u8 , 205u8 , 33u8 ,]) } # [doc = "Rebond a portion of the stash scheduled to be unlocked."] # [doc = ""] # [doc = "The dispatch origin must be signed by the controller."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Time complexity: O(L), where L is unlocking chunks"] # [doc = "- Bounded by `MaxUnlockingChunks`."] # [doc = "- Storage changes: Can't increase storage, only decrease it."] # [doc = "# </weight>"] pub fn rebond (& self , value : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < Rebond > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "rebond" , Rebond { value , } , [25u8 , 22u8 , 191u8 , 172u8 , 133u8 , 101u8 , 139u8 , 102u8 , 134u8 , 16u8 , 136u8 , 56u8 , 137u8 , 162u8 , 4u8 , 253u8 , 196u8 , 30u8 , 234u8 , 49u8 , 102u8 , 68u8 , 145u8 , 96u8 , 148u8 , 219u8 , 162u8 , 17u8 , 177u8 , 184u8 , 34u8 , 113u8 ,]) } # [doc = "Remove all data structures concerning a staker/stash once it is at a state where it can"] # [doc = "be considered `dust` in the staking system. The requirements are:"] # [doc = ""] # [doc = "1. the `total_balance` of the stash is below existential deposit."] # [doc = "2. or, the `ledger.total` of the stash is below existential deposit."] # [doc = ""] # [doc = "The former can happen in cases like a slash; the latter when a fully unbonded account"] # [doc = "is still receiving staking rewards in `RewardDestination::Staked`."] # [doc = ""] # [doc = "It can be called by anyone, as long as `stash` meets the above requirements."] # [doc = ""] # [doc = "Refunds the transaction fees upon successful execution."] pub fn reap_stash (& self , stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , num_slashing_spans : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < ReapStash > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "reap_stash" , ReapStash { stash , num_slashing_spans , } , [34u8 , 168u8 , 120u8 , 161u8 , 95u8 , 199u8 , 106u8 , 233u8 , 61u8 , 240u8 , 166u8 , 31u8 , 183u8 , 165u8 , 158u8 , 179u8 , 32u8 , 130u8 , 27u8 , 164u8 , 112u8 , 44u8 , 14u8 , 125u8 , 227u8 , 87u8 , 70u8 , 203u8 , 194u8 , 24u8 , 212u8 , 177u8 ,]) } # [doc = "Remove the given nominations from the calling validator."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "- `who`: A list of nominator stash accounts who are nominating this validator which"] # [doc = "  should no longer be nominating this validator."] # [doc = ""] # [doc = "Note: Making this call only makes sense if you first set the validator preferences to"] # [doc = "block any further nominations."] pub fn kick (& self , who : :: std :: vec :: Vec < :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > > ,) -> :: subxt :: tx :: StaticTxPayload < Kick > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "kick" , Kick { who , } , [32u8 , 26u8 , 202u8 , 6u8 , 186u8 , 180u8 , 58u8 , 121u8 , 185u8 , 208u8 , 123u8 , 10u8 , 53u8 , 179u8 , 167u8 , 203u8 , 96u8 , 229u8 , 7u8 , 144u8 , 231u8 , 172u8 , 145u8 , 141u8 , 162u8 , 180u8 , 212u8 , 42u8 , 34u8 , 5u8 , 199u8 , 82u8 ,]) } # [doc = "Update the various staking configurations ."] # [doc = ""] # [doc = "* `min_nominator_bond`: The minimum active bond needed to be a nominator."] # [doc = "* `min_validator_bond`: The minimum active bond needed to be a validator."] # [doc = "* `max_nominator_count`: The max number of users who can be a nominator at once. When"] # [doc = "  set to `None`, no limit is enforced."] # [doc = "* `max_validator_count`: The max number of users who can be a validator at once. When"] # [doc = "  set to `None`, no limit is enforced."] # [doc = "* `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which"] # [doc = "  should be filled in order for the `chill_other` transaction to work."] # [doc = "* `min_commission`: The minimum amount of commission that each validators must maintain."] # [doc = "  This is checked only upon calling `validate`. Existing validators are not affected."] # [doc = ""] # [doc = "RuntimeOrigin must be Root to call this function."] # [doc = ""] # [doc = "NOTE: Existing nominators and validators will not be affected by this update."] # [doc = "to kick people under the new limits, `chill_other` should be called."] pub fn set_staking_configs (& self , min_nominator_bond : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u128 > , min_validator_bond : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u128 > , max_nominator_count : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u32 > , max_validator_count : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u32 > , chill_threshold : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < runtime_types :: sp_arithmetic :: per_things :: Percent > , min_commission : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < runtime_types :: sp_arithmetic :: per_things :: Perbill > ,) -> :: subxt :: tx :: StaticTxPayload < SetStakingConfigs > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "set_staking_configs" , SetStakingConfigs { min_nominator_bond , min_validator_bond , max_nominator_count , max_validator_count , chill_threshold , min_commission , } , [176u8 , 168u8 , 155u8 , 176u8 , 27u8 , 79u8 , 223u8 , 92u8 , 88u8 , 93u8 , 223u8 , 69u8 , 179u8 , 250u8 , 138u8 , 138u8 , 87u8 , 220u8 , 36u8 , 3u8 , 126u8 , 213u8 , 16u8 , 68u8 , 3u8 , 16u8 , 218u8 , 151u8 , 98u8 , 169u8 , 217u8 , 75u8 ,]) } # [doc = "Declare a `controller` to stop participating as either a validator or nominator."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_, but can be called by anyone."] # [doc = ""] # [doc = "If the caller is the same as the controller being targeted, then no further checks are"] # [doc = "enforced, and this function behaves just like `chill`."] # [doc = ""] # [doc = "If the caller is different than the controller being targeted, the following conditions"] # [doc = "must be met:"] # [doc = ""] # [doc = "* `controller` must belong to a nominator who has become non-decodable,"] # [doc = ""] # [doc = "Or:"] # [doc = ""] # [doc = "* A `ChillThreshold` must be set and checked which defines how close to the max"] # [doc = "  nominators or validators we must reach before users can start chilling one-another."] # [doc = "* A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine"] # [doc = "  how close we are to the threshold."] # [doc = "* A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines"] # [doc = "  if this is a person that should be chilled because they have not met the threshold"] # [doc = "  bond required."] # [doc = ""] # [doc = "This can be helpful if bond requirements are updated, and we need to remove old users"] # [doc = "who do not satisfy these requirements."] pub fn chill_other (& self , controller : :: subxt :: ext :: sp_core :: crypto :: AccountId32 ,) -> :: subxt :: tx :: StaticTxPayload < ChillOther > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "chill_other" , ChillOther { controller , } , [140u8 , 98u8 , 4u8 , 203u8 , 91u8 , 131u8 , 123u8 , 119u8 , 169u8 , 47u8 , 188u8 , 23u8 , 205u8 , 170u8 , 82u8 , 220u8 , 166u8 , 170u8 , 135u8 , 176u8 , 68u8 , 228u8 , 14u8 , 67u8 , 42u8 , 52u8 , 140u8 , 231u8 , 62u8 , 167u8 , 80u8 , 173u8 ,]) } # [doc = "Force a validator to have at least the minimum commission. This will not affect a"] # [doc = "validator who already has a commission greater than or equal to the minimum. Any account"] # [doc = "can call this."] pub fn force_apply_min_commission (& self , validator_stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 ,) -> :: subxt :: tx :: StaticTxPayload < ForceApplyMinCommission > { :: subxt :: tx :: StaticTxPayload :: new ("Staking" , "force_apply_min_commission" , ForceApplyMinCommission { validator_stash , } , [136u8 , 163u8 , 85u8 , 134u8 , 240u8 , 247u8 , 183u8 , 227u8 , 226u8 , 202u8 , 102u8 , 186u8 , 138u8 , 119u8 , 78u8 , 123u8 , 229u8 , 135u8 , 129u8 , 241u8 , 119u8 , 106u8 , 41u8 , 182u8 , 121u8 , 181u8 , 242u8 , 175u8 , 74u8 , 207u8 , 64u8 , 106u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_staking :: pallet :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "The era payout has been set; the first balance is the validator-payout; the second is"] # [doc = "the remainder from the maximum amount of reward."] pub struct EraPaid { pub era_index : :: core :: primitive :: u32 , pub validator_payout : :: core :: primitive :: u128 , pub remainder : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for EraPaid { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "EraPaid" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "The nominator has been rewarded by this amount."] pub struct Rewarded { pub stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Rewarded { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "Rewarded" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "One staker (and potentially its nominators) has been slashed by the given amount."] pub struct Slashed { pub staker : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Slashed { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "Slashed" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An old slashing report from a prior era was discarded because it could"] # [doc = "not be processed."] pub struct OldSlashingReportDiscarded { pub session_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for OldSlashingReportDiscarded { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "OldSlashingReportDiscarded" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A new set of stakers was elected."] pub struct StakersElected ; impl :: subxt :: events :: StaticEvent for StakersElected { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "StakersElected" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An account has bonded this amount. \\[stash, amount\\]"] # [doc = ""] # [doc = "NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,"] # [doc = "it will not be emitted for staking rewards when they are added to stake."] pub struct Bonded { pub stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Bonded { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "Bonded" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An account has unbonded this amount."] pub struct Unbonded { pub stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Unbonded { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "Unbonded" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`"] # [doc = "from the unlocking queue."] pub struct Withdrawn { pub stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Withdrawn { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "Withdrawn" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A nominator has been kicked from a validator."] pub struct Kicked { pub nominator : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for Kicked { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "Kicked" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "The election failed. No new era is planned."] pub struct StakingElectionFailed ; impl :: subxt :: events :: StaticEvent for StakingElectionFailed { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "StakingElectionFailed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An account has stopped participating as either a validator or nominator."] pub struct Chilled { pub stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for Chilled { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "Chilled" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "The stakers' rewards are getting paid."] pub struct PayoutStarted { pub era_index : :: core :: primitive :: u32 , pub validator_stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for PayoutStarted { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "PayoutStarted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A validator has set their preferences."] pub struct ValidatorPrefsSet { pub stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub prefs : runtime_types :: pallet_staking :: ValidatorPrefs , } impl :: subxt :: events :: StaticEvent for ValidatorPrefsSet { const PALLET : & 'static str = "Staking" ; const EVENT : & 'static str = "ValidatorPrefsSet" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The ideal number of staking participants."] pub fn validator_count (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ValidatorCount" , vec ! [] , [245u8 , 75u8 , 214u8 , 110u8 , 66u8 , 164u8 , 86u8 , 206u8 , 69u8 , 89u8 , 12u8 , 111u8 , 117u8 , 16u8 , 228u8 , 184u8 , 207u8 , 6u8 , 0u8 , 126u8 , 221u8 , 67u8 , 125u8 , 218u8 , 188u8 , 245u8 , 156u8 , 188u8 , 34u8 , 85u8 , 208u8 , 197u8 ,]) } # [doc = " Minimum number of staking participants before emergency conditions are imposed."] pub fn minimum_validator_count (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "MinimumValidatorCount" , vec ! [] , [82u8 , 95u8 , 128u8 , 55u8 , 136u8 , 134u8 , 71u8 , 117u8 , 135u8 , 76u8 , 44u8 , 46u8 , 174u8 , 34u8 , 170u8 , 228u8 , 175u8 , 1u8 , 234u8 , 162u8 , 91u8 , 252u8 , 127u8 , 68u8 , 243u8 , 241u8 , 13u8 , 107u8 , 214u8 , 70u8 , 87u8 , 249u8 ,]) } # [doc = " Any validators that may never be slashed or forcibly kicked. It's a Vec since they're"] # [doc = " easy to initialize and the performance hit is minimal (we expect no more than four"] # [doc = " invulnerables) and restricted to testnets."] pub fn invulnerables (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "Invulnerables" , vec ! [] , [77u8 , 78u8 , 63u8 , 199u8 , 150u8 , 167u8 , 135u8 , 130u8 , 192u8 , 51u8 , 202u8 , 119u8 , 68u8 , 49u8 , 241u8 , 68u8 , 82u8 , 90u8 , 226u8 , 201u8 , 96u8 , 170u8 , 21u8 , 173u8 , 236u8 , 116u8 , 148u8 , 8u8 , 174u8 , 92u8 , 7u8 , 11u8 ,]) } # [doc = " Map from all locked \"stash\" accounts to the controller account."] pub fn bonded (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "Bonded" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [35u8 , 197u8 , 156u8 , 60u8 , 22u8 , 59u8 , 103u8 , 83u8 , 77u8 , 15u8 , 118u8 , 193u8 , 155u8 , 97u8 , 229u8 , 36u8 , 119u8 , 128u8 , 224u8 , 162u8 , 21u8 , 46u8 , 199u8 , 221u8 , 15u8 , 74u8 , 59u8 , 70u8 , 77u8 , 218u8 , 73u8 , 165u8 ,]) } # [doc = " Map from all locked \"stash\" accounts to the controller account."] pub fn bonded_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "Bonded" , Vec :: new () , [35u8 , 197u8 , 156u8 , 60u8 , 22u8 , 59u8 , 103u8 , 83u8 , 77u8 , 15u8 , 118u8 , 193u8 , 155u8 , 97u8 , 229u8 , 36u8 , 119u8 , 128u8 , 224u8 , 162u8 , 21u8 , 46u8 , 199u8 , 221u8 , 15u8 , 74u8 , 59u8 , 70u8 , 77u8 , 218u8 , 73u8 , 165u8 ,]) } # [doc = " The minimum active bond to become and maintain the role of a nominator."] pub fn min_nominator_bond (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "MinNominatorBond" , vec ! [] , [187u8 , 66u8 , 149u8 , 226u8 , 72u8 , 219u8 , 57u8 , 246u8 , 102u8 , 47u8 , 71u8 , 12u8 , 219u8 , 204u8 , 127u8 , 223u8 , 58u8 , 134u8 , 81u8 , 165u8 , 200u8 , 142u8 , 196u8 , 158u8 , 26u8 , 38u8 , 165u8 , 19u8 , 91u8 , 251u8 , 119u8 , 84u8 ,]) } # [doc = " The minimum active bond to become and maintain the role of a validator."] pub fn min_validator_bond (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "MinValidatorBond" , vec ! [] , [48u8 , 105u8 , 85u8 , 178u8 , 142u8 , 208u8 , 208u8 , 19u8 , 236u8 , 130u8 , 129u8 , 169u8 , 35u8 , 245u8 , 66u8 , 182u8 , 92u8 , 20u8 , 22u8 , 109u8 , 155u8 , 174u8 , 87u8 , 118u8 , 242u8 , 216u8 , 193u8 , 154u8 , 4u8 , 5u8 , 66u8 , 56u8 ,]) } # [doc = " The minimum amount of commission that validators can set."] # [doc = ""] # [doc = " If set to `0`, no limit exists."] pub fn min_commission (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_arithmetic :: per_things :: Perbill > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "MinCommission" , vec ! [] , [61u8 , 101u8 , 69u8 , 27u8 , 220u8 , 179u8 , 5u8 , 71u8 , 66u8 , 227u8 , 84u8 , 98u8 , 18u8 , 141u8 , 183u8 , 49u8 , 98u8 , 46u8 , 123u8 , 114u8 , 198u8 , 85u8 , 15u8 , 175u8 , 243u8 , 239u8 , 133u8 , 129u8 , 146u8 , 174u8 , 254u8 , 158u8 ,]) } # [doc = " Map from all (unlocked) \"controller\" accounts to the info regarding the staking."] pub fn ledger (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: StakingLedger > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "Ledger" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [31u8 , 205u8 , 3u8 , 165u8 , 22u8 , 22u8 , 62u8 , 92u8 , 33u8 , 189u8 , 124u8 , 120u8 , 177u8 , 70u8 , 27u8 , 242u8 , 188u8 , 184u8 , 204u8 , 188u8 , 242u8 , 140u8 , 128u8 , 230u8 , 85u8 , 99u8 , 181u8 , 173u8 , 67u8 , 252u8 , 37u8 , 236u8 ,]) } # [doc = " Map from all (unlocked) \"controller\" accounts to the info regarding the staking."] pub fn ledger_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: StakingLedger > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "Ledger" , Vec :: new () , [31u8 , 205u8 , 3u8 , 165u8 , 22u8 , 22u8 , 62u8 , 92u8 , 33u8 , 189u8 , 124u8 , 120u8 , 177u8 , 70u8 , 27u8 , 242u8 , 188u8 , 184u8 , 204u8 , 188u8 , 242u8 , 140u8 , 128u8 , 230u8 , 85u8 , 99u8 , 181u8 , 173u8 , 67u8 , 252u8 , 37u8 , 236u8 ,]) } # [doc = " Where the reward payment should be made. Keyed by stash."] pub fn payee (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: RewardDestination < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "Payee" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [195u8 , 125u8 , 82u8 , 213u8 , 216u8 , 64u8 , 76u8 , 63u8 , 187u8 , 163u8 , 20u8 , 230u8 , 153u8 , 13u8 , 189u8 , 232u8 , 119u8 , 118u8 , 107u8 , 17u8 , 102u8 , 245u8 , 36u8 , 42u8 , 232u8 , 137u8 , 177u8 , 165u8 , 169u8 , 246u8 , 199u8 , 57u8 ,]) } # [doc = " Where the reward payment should be made. Keyed by stash."] pub fn payee_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: RewardDestination < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "Payee" , Vec :: new () , [195u8 , 125u8 , 82u8 , 213u8 , 216u8 , 64u8 , 76u8 , 63u8 , 187u8 , 163u8 , 20u8 , 230u8 , 153u8 , 13u8 , 189u8 , 232u8 , 119u8 , 118u8 , 107u8 , 17u8 , 102u8 , 245u8 , 36u8 , 42u8 , 232u8 , 137u8 , 177u8 , 165u8 , 169u8 , 246u8 , 199u8 , 57u8 ,]) } # [doc = " The map from (wannabe) validator stash key to the preferences of that validator."] pub fn validators (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: ValidatorPrefs > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "Validators" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [80u8 , 77u8 , 66u8 , 18u8 , 197u8 , 250u8 , 41u8 , 185u8 , 43u8 , 24u8 , 149u8 , 164u8 , 208u8 , 60u8 , 144u8 , 29u8 , 251u8 , 195u8 , 236u8 , 196u8 , 108u8 , 58u8 , 80u8 , 115u8 , 246u8 , 66u8 , 226u8 , 241u8 , 201u8 , 172u8 , 229u8 , 152u8 ,]) } # [doc = " The map from (wannabe) validator stash key to the preferences of that validator."] pub fn validators_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: ValidatorPrefs > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "Validators" , Vec :: new () , [80u8 , 77u8 , 66u8 , 18u8 , 197u8 , 250u8 , 41u8 , 185u8 , 43u8 , 24u8 , 149u8 , 164u8 , 208u8 , 60u8 , 144u8 , 29u8 , 251u8 , 195u8 , 236u8 , 196u8 , 108u8 , 58u8 , 80u8 , 115u8 , 246u8 , 66u8 , 226u8 , 241u8 , 201u8 , 172u8 , 229u8 , 152u8 ,]) } # [doc = "Counter for the related counted storage map"] pub fn counter_for_validators (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "CounterForValidators" , vec ! [] , [139u8 , 25u8 , 223u8 , 6u8 , 160u8 , 239u8 , 212u8 , 85u8 , 36u8 , 185u8 , 69u8 , 63u8 , 21u8 , 156u8 , 144u8 , 241u8 , 112u8 , 85u8 , 49u8 , 78u8 , 88u8 , 11u8 , 8u8 , 48u8 , 118u8 , 34u8 , 62u8 , 159u8 , 239u8 , 122u8 , 90u8 , 45u8 ,]) } # [doc = " The maximum validator count before we stop allowing new validators to join."] # [doc = ""] # [doc = " When this value is not set, no limits are enforced."] pub fn max_validators_count (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "MaxValidatorsCount" , vec ! [] , [250u8 , 62u8 , 16u8 , 68u8 , 192u8 , 216u8 , 236u8 , 211u8 , 217u8 , 9u8 , 213u8 , 49u8 , 41u8 , 37u8 , 58u8 , 62u8 , 131u8 , 112u8 , 64u8 , 26u8 , 133u8 , 7u8 , 130u8 , 1u8 , 71u8 , 158u8 , 14u8 , 55u8 , 169u8 , 239u8 , 223u8 , 245u8 ,]) } # [doc = " The map from nominator stash key to their nomination preferences, namely the validators that"] # [doc = " they wish to support."] # [doc = ""] # [doc = " Note that the keys of this storage map might become non-decodable in case the"] # [doc = " [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators"] # [doc = " are still existent in storage, their key is correct and retrievable (i.e. `contains_key`"] # [doc = " indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable"] # [doc = " nominators will effectively not-exist, until they re-submit their preferences such that it"] # [doc = " is within the bounds of the newly set `Config::MaxNominations`."] # [doc = ""] # [doc = " This implies that `::iter_keys().count()` and `::iter().count()` might return different"] # [doc = " values for this map. Moreover, the main `::count()` is aligned with the former, namely the"] # [doc = " number of keys that exist."] # [doc = ""] # [doc = " Lastly, if any of the nominators become non-decodable, they can be chilled immediately via"] # [doc = " [`Call::chill_other`] dispatchable by anyone."] pub fn nominators (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: Nominations > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "Nominators" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [1u8 , 154u8 , 55u8 , 170u8 , 215u8 , 64u8 , 56u8 , 83u8 , 254u8 , 19u8 , 152u8 , 85u8 , 164u8 , 171u8 , 206u8 , 129u8 , 184u8 , 45u8 , 221u8 , 181u8 , 229u8 , 133u8 , 200u8 , 231u8 , 16u8 , 146u8 , 247u8 , 21u8 , 77u8 , 122u8 , 165u8 , 134u8 ,]) } # [doc = " The map from nominator stash key to their nomination preferences, namely the validators that"] # [doc = " they wish to support."] # [doc = ""] # [doc = " Note that the keys of this storage map might become non-decodable in case the"] # [doc = " [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators"] # [doc = " are still existent in storage, their key is correct and retrievable (i.e. `contains_key`"] # [doc = " indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable"] # [doc = " nominators will effectively not-exist, until they re-submit their preferences such that it"] # [doc = " is within the bounds of the newly set `Config::MaxNominations`."] # [doc = ""] # [doc = " This implies that `::iter_keys().count()` and `::iter().count()` might return different"] # [doc = " values for this map. Moreover, the main `::count()` is aligned with the former, namely the"] # [doc = " number of keys that exist."] # [doc = ""] # [doc = " Lastly, if any of the nominators become non-decodable, they can be chilled immediately via"] # [doc = " [`Call::chill_other`] dispatchable by anyone."] pub fn nominators_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: Nominations > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "Nominators" , Vec :: new () , [1u8 , 154u8 , 55u8 , 170u8 , 215u8 , 64u8 , 56u8 , 83u8 , 254u8 , 19u8 , 152u8 , 85u8 , 164u8 , 171u8 , 206u8 , 129u8 , 184u8 , 45u8 , 221u8 , 181u8 , 229u8 , 133u8 , 200u8 , 231u8 , 16u8 , 146u8 , 247u8 , 21u8 , 77u8 , 122u8 , 165u8 , 134u8 ,]) } # [doc = "Counter for the related counted storage map"] pub fn counter_for_nominators (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "CounterForNominators" , vec ! [] , [31u8 , 94u8 , 130u8 , 138u8 , 75u8 , 8u8 , 38u8 , 162u8 , 181u8 , 5u8 , 125u8 , 116u8 , 9u8 , 51u8 , 22u8 , 234u8 , 40u8 , 117u8 , 215u8 , 46u8 , 82u8 , 117u8 , 225u8 , 1u8 , 9u8 , 208u8 , 83u8 , 63u8 , 39u8 , 187u8 , 207u8 , 191u8 ,]) } # [doc = " The maximum nominator count before we stop allowing new validators to join."] # [doc = ""] # [doc = " When this value is not set, no limits are enforced."] pub fn max_nominators_count (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "MaxNominatorsCount" , vec ! [] , [180u8 , 190u8 , 180u8 , 66u8 , 235u8 , 173u8 , 76u8 , 160u8 , 197u8 , 92u8 , 96u8 , 165u8 , 220u8 , 188u8 , 32u8 , 119u8 , 3u8 , 73u8 , 86u8 , 49u8 , 104u8 , 17u8 , 186u8 , 98u8 , 221u8 , 175u8 , 109u8 , 254u8 , 207u8 , 245u8 , 125u8 , 179u8 ,]) } # [doc = " The current era index."] # [doc = ""] # [doc = " This is the latest planned era, depending on how the Session pallet queues the validator"] # [doc = " set, it might be active or not."] pub fn current_era (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "CurrentEra" , vec ! [] , [105u8 , 150u8 , 49u8 , 122u8 , 4u8 , 78u8 , 8u8 , 121u8 , 34u8 , 136u8 , 157u8 , 227u8 , 59u8 , 139u8 , 7u8 , 253u8 , 7u8 , 10u8 , 117u8 , 71u8 , 240u8 , 74u8 , 86u8 , 36u8 , 198u8 , 37u8 , 153u8 , 93u8 , 196u8 , 22u8 , 192u8 , 243u8 ,]) } # [doc = " The active era information, it holds index and start."] # [doc = ""] # [doc = " The active era is the era being currently rewarded. Validator set of this era must be"] # [doc = " equal to [`SessionInterface::validators`]."] pub fn active_era (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: ActiveEraInfo > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ActiveEra" , vec ! [] , [15u8 , 112u8 , 251u8 , 183u8 , 108u8 , 61u8 , 28u8 , 71u8 , 44u8 , 150u8 , 162u8 , 4u8 , 143u8 , 121u8 , 11u8 , 37u8 , 83u8 , 29u8 , 193u8 , 21u8 , 210u8 , 116u8 , 190u8 , 236u8 , 213u8 , 235u8 , 49u8 , 97u8 , 189u8 , 142u8 , 251u8 , 124u8 ,]) } # [doc = " The session index at which the era start for the last `HISTORY_DEPTH` eras."] # [doc = ""] # [doc = " Note: This tracks the starting session (i.e. session index when era start being active)"] # [doc = " for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`."] pub fn eras_start_session_index (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ErasStartSessionIndex" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [92u8 , 157u8 , 168u8 , 144u8 , 132u8 , 3u8 , 212u8 , 80u8 , 230u8 , 229u8 , 251u8 , 218u8 , 97u8 , 55u8 , 79u8 , 100u8 , 163u8 , 91u8 , 32u8 , 246u8 , 122u8 , 78u8 , 149u8 , 214u8 , 103u8 , 249u8 , 119u8 , 20u8 , 101u8 , 116u8 , 110u8 , 185u8 ,]) } # [doc = " The session index at which the era start for the last `HISTORY_DEPTH` eras."] # [doc = ""] # [doc = " Note: This tracks the starting session (i.e. session index when era start being active)"] # [doc = " for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`."] pub fn eras_start_session_index_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ErasStartSessionIndex" , Vec :: new () , [92u8 , 157u8 , 168u8 , 144u8 , 132u8 , 3u8 , 212u8 , 80u8 , 230u8 , 229u8 , 251u8 , 218u8 , 97u8 , 55u8 , 79u8 , 100u8 , 163u8 , 91u8 , 32u8 , 246u8 , 122u8 , 78u8 , 149u8 , 214u8 , 103u8 , 249u8 , 119u8 , 20u8 , 101u8 , 116u8 , 110u8 , 185u8 ,]) } # [doc = " Exposure of validator at era."] # [doc = ""] # [doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."] # [doc = ""] # [doc = " Is it removed after `HISTORY_DEPTH` eras."] # [doc = " If stakers hasn't been set or has been removed then empty exposure is returned."] pub fn eras_stakers (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > , _1 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: Exposure < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ErasStakers" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat) , :: subxt :: storage :: address :: StorageMapKey :: new (_1 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [192u8 , 50u8 , 152u8 , 151u8 , 92u8 , 180u8 , 206u8 , 15u8 , 139u8 , 210u8 , 128u8 , 65u8 , 92u8 , 253u8 , 43u8 , 35u8 , 139u8 , 171u8 , 73u8 , 185u8 , 32u8 , 78u8 , 20u8 , 197u8 , 154u8 , 90u8 , 233u8 , 231u8 , 23u8 , 22u8 , 187u8 , 156u8 ,]) } # [doc = " Exposure of validator at era."] # [doc = ""] # [doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."] # [doc = ""] # [doc = " Is it removed after `HISTORY_DEPTH` eras."] # [doc = " If stakers hasn't been set or has been removed then empty exposure is returned."] pub fn eras_stakers_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: Exposure < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ErasStakers" , Vec :: new () , [192u8 , 50u8 , 152u8 , 151u8 , 92u8 , 180u8 , 206u8 , 15u8 , 139u8 , 210u8 , 128u8 , 65u8 , 92u8 , 253u8 , 43u8 , 35u8 , 139u8 , 171u8 , 73u8 , 185u8 , 32u8 , 78u8 , 20u8 , 197u8 , 154u8 , 90u8 , 233u8 , 231u8 , 23u8 , 22u8 , 187u8 , 156u8 ,]) } # [doc = " Clipped Exposure of validator at era."] # [doc = ""] # [doc = " This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the"] # [doc = " `T::MaxNominatorRewardedPerValidator` biggest stakers."] # [doc = " (Note: the field `total` and `own` of the exposure remains unchanged)."] # [doc = " This is used to limit the i/o cost for the nominator payout."] # [doc = ""] # [doc = " This is keyed fist by the era index to allow bulk deletion and then the stash account."] # [doc = ""] # [doc = " Is it removed after `HISTORY_DEPTH` eras."] # [doc = " If stakers hasn't been set or has been removed then empty exposure is returned."] pub fn eras_stakers_clipped (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > , _1 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: Exposure < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ErasStakersClipped" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat) , :: subxt :: storage :: address :: StorageMapKey :: new (_1 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [43u8 , 159u8 , 113u8 , 223u8 , 122u8 , 169u8 , 98u8 , 153u8 , 26u8 , 55u8 , 71u8 , 119u8 , 174u8 , 48u8 , 158u8 , 45u8 , 214u8 , 26u8 , 136u8 , 215u8 , 46u8 , 161u8 , 185u8 , 17u8 , 174u8 , 204u8 , 206u8 , 246u8 , 49u8 , 87u8 , 134u8 , 169u8 ,]) } # [doc = " Clipped Exposure of validator at era."] # [doc = ""] # [doc = " This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the"] # [doc = " `T::MaxNominatorRewardedPerValidator` biggest stakers."] # [doc = " (Note: the field `total` and `own` of the exposure remains unchanged)."] # [doc = " This is used to limit the i/o cost for the nominator payout."] # [doc = ""] # [doc = " This is keyed fist by the era index to allow bulk deletion and then the stash account."] # [doc = ""] # [doc = " Is it removed after `HISTORY_DEPTH` eras."] # [doc = " If stakers hasn't been set or has been removed then empty exposure is returned."] pub fn eras_stakers_clipped_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: Exposure < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ErasStakersClipped" , Vec :: new () , [43u8 , 159u8 , 113u8 , 223u8 , 122u8 , 169u8 , 98u8 , 153u8 , 26u8 , 55u8 , 71u8 , 119u8 , 174u8 , 48u8 , 158u8 , 45u8 , 214u8 , 26u8 , 136u8 , 215u8 , 46u8 , 161u8 , 185u8 , 17u8 , 174u8 , 204u8 , 206u8 , 246u8 , 49u8 , 87u8 , 134u8 , 169u8 ,]) } # [doc = " Similar to `ErasStakers`, this holds the preferences of validators."] # [doc = ""] # [doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."] # [doc = ""] # [doc = " Is it removed after `HISTORY_DEPTH` eras."] pub fn eras_validator_prefs (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > , _1 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: ValidatorPrefs > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ErasValidatorPrefs" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat) , :: subxt :: storage :: address :: StorageMapKey :: new (_1 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [6u8 , 196u8 , 209u8 , 138u8 , 252u8 , 18u8 , 203u8 , 86u8 , 129u8 , 62u8 , 4u8 , 56u8 , 234u8 , 114u8 , 141u8 , 136u8 , 127u8 , 224u8 , 142u8 , 89u8 , 150u8 , 33u8 , 31u8 , 50u8 , 140u8 , 108u8 , 124u8 , 77u8 , 188u8 , 102u8 , 230u8 , 174u8 ,]) } # [doc = " Similar to `ErasStakers`, this holds the preferences of validators."] # [doc = ""] # [doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."] # [doc = ""] # [doc = " Is it removed after `HISTORY_DEPTH` eras."] pub fn eras_validator_prefs_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: ValidatorPrefs > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ErasValidatorPrefs" , Vec :: new () , [6u8 , 196u8 , 209u8 , 138u8 , 252u8 , 18u8 , 203u8 , 86u8 , 129u8 , 62u8 , 4u8 , 56u8 , 234u8 , 114u8 , 141u8 , 136u8 , 127u8 , 224u8 , 142u8 , 89u8 , 150u8 , 33u8 , 31u8 , 50u8 , 140u8 , 108u8 , 124u8 , 77u8 , 188u8 , 102u8 , 230u8 , 174u8 ,]) } # [doc = " The total validator era payout for the last `HISTORY_DEPTH` eras."] # [doc = ""] # [doc = " Eras that haven't finished yet or has been removed doesn't have reward."] pub fn eras_validator_reward (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ErasValidatorReward" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [87u8 , 80u8 , 156u8 , 123u8 , 107u8 , 77u8 , 203u8 , 37u8 , 231u8 , 84u8 , 124u8 , 155u8 , 227u8 , 212u8 , 212u8 , 179u8 , 84u8 , 161u8 , 223u8 , 255u8 , 254u8 , 107u8 , 52u8 , 89u8 , 98u8 , 169u8 , 136u8 , 241u8 , 104u8 , 3u8 , 244u8 , 161u8 ,]) } # [doc = " The total validator era payout for the last `HISTORY_DEPTH` eras."] # [doc = ""] # [doc = " Eras that haven't finished yet or has been removed doesn't have reward."] pub fn eras_validator_reward_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ErasValidatorReward" , Vec :: new () , [87u8 , 80u8 , 156u8 , 123u8 , 107u8 , 77u8 , 203u8 , 37u8 , 231u8 , 84u8 , 124u8 , 155u8 , 227u8 , 212u8 , 212u8 , 179u8 , 84u8 , 161u8 , 223u8 , 255u8 , 254u8 , 107u8 , 52u8 , 89u8 , 98u8 , 169u8 , 136u8 , 241u8 , 104u8 , 3u8 , 244u8 , 161u8 ,]) } # [doc = " Rewards for the last `HISTORY_DEPTH` eras."] # [doc = " If reward hasn't been set or has been removed then 0 reward is returned."] pub fn eras_reward_points (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: EraRewardPoints < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ErasRewardPoints" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [194u8 , 29u8 , 20u8 , 83u8 , 200u8 , 47u8 , 158u8 , 102u8 , 88u8 , 65u8 , 24u8 , 255u8 , 120u8 , 178u8 , 23u8 , 232u8 , 15u8 , 64u8 , 206u8 , 0u8 , 170u8 , 40u8 , 18u8 , 149u8 , 45u8 , 90u8 , 179u8 , 127u8 , 52u8 , 59u8 , 37u8 , 192u8 ,]) } # [doc = " Rewards for the last `HISTORY_DEPTH` eras."] # [doc = " If reward hasn't been set or has been removed then 0 reward is returned."] pub fn eras_reward_points_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: EraRewardPoints < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ErasRewardPoints" , Vec :: new () , [194u8 , 29u8 , 20u8 , 83u8 , 200u8 , 47u8 , 158u8 , 102u8 , 88u8 , 65u8 , 24u8 , 255u8 , 120u8 , 178u8 , 23u8 , 232u8 , 15u8 , 64u8 , 206u8 , 0u8 , 170u8 , 40u8 , 18u8 , 149u8 , 45u8 , 90u8 , 179u8 , 127u8 , 52u8 , 59u8 , 37u8 , 192u8 ,]) } # [doc = " The total amount staked for the last `HISTORY_DEPTH` eras."] # [doc = " If total hasn't been set or has been removed then 0 stake is returned."] pub fn eras_total_stake (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ErasTotalStake" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [224u8 , 240u8 , 168u8 , 69u8 , 148u8 , 140u8 , 249u8 , 240u8 , 4u8 , 46u8 , 77u8 , 11u8 , 224u8 , 65u8 , 26u8 , 239u8 , 1u8 , 110u8 , 53u8 , 11u8 , 247u8 , 235u8 , 142u8 , 234u8 , 22u8 , 43u8 , 24u8 , 36u8 , 37u8 , 43u8 , 170u8 , 40u8 ,]) } # [doc = " The total amount staked for the last `HISTORY_DEPTH` eras."] # [doc = " If total hasn't been set or has been removed then 0 stake is returned."] pub fn eras_total_stake_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ErasTotalStake" , Vec :: new () , [224u8 , 240u8 , 168u8 , 69u8 , 148u8 , 140u8 , 249u8 , 240u8 , 4u8 , 46u8 , 77u8 , 11u8 , 224u8 , 65u8 , 26u8 , 239u8 , 1u8 , 110u8 , 53u8 , 11u8 , 247u8 , 235u8 , 142u8 , 234u8 , 22u8 , 43u8 , 24u8 , 36u8 , 37u8 , 43u8 , 170u8 , 40u8 ,]) } # [doc = " Mode of era forcing."] pub fn force_era (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: Forcing > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ForceEra" , vec ! [] , [221u8 , 41u8 , 71u8 , 21u8 , 28u8 , 193u8 , 65u8 , 97u8 , 103u8 , 37u8 , 145u8 , 146u8 , 183u8 , 194u8 , 57u8 , 131u8 , 214u8 , 136u8 , 68u8 , 156u8 , 140u8 , 194u8 , 69u8 , 151u8 , 115u8 , 177u8 , 92u8 , 147u8 , 29u8 , 40u8 , 41u8 , 31u8 ,]) } # [doc = " The percentage of the slash that is distributed to reporters."] # [doc = ""] # [doc = " The rest of the slashed value is handled by the `Slash`."] pub fn slash_reward_fraction (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_arithmetic :: per_things :: Perbill > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "SlashRewardFraction" , vec ! [] , [167u8 , 79u8 , 143u8 , 202u8 , 199u8 , 100u8 , 129u8 , 162u8 , 23u8 , 165u8 , 106u8 , 170u8 , 244u8 , 86u8 , 144u8 , 242u8 , 65u8 , 207u8 , 115u8 , 224u8 , 231u8 , 155u8 , 55u8 , 139u8 , 101u8 , 129u8 , 242u8 , 196u8 , 130u8 , 50u8 , 3u8 , 117u8 ,]) } # [doc = " The amount of currency given to reporters of a slash event which was"] # [doc = " canceled by extraordinary circumstances (e.g. governance)."] pub fn canceled_slash_payout (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "CanceledSlashPayout" , vec ! [] , [126u8 , 218u8 , 66u8 , 92u8 , 82u8 , 124u8 , 145u8 , 161u8 , 40u8 , 176u8 , 14u8 , 211u8 , 178u8 , 216u8 , 8u8 , 156u8 , 83u8 , 14u8 , 91u8 , 15u8 , 200u8 , 170u8 , 3u8 , 127u8 , 141u8 , 139u8 , 151u8 , 98u8 , 74u8 , 96u8 , 238u8 , 29u8 ,]) } # [doc = " All unapplied slashes that are queued for later."] pub fn unapplied_slashes (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < runtime_types :: pallet_staking :: UnappliedSlash < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "UnappliedSlashes" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [130u8 , 4u8 , 163u8 , 163u8 , 28u8 , 85u8 , 34u8 , 156u8 , 47u8 , 125u8 , 57u8 , 0u8 , 133u8 , 176u8 , 130u8 , 2u8 , 175u8 , 180u8 , 167u8 , 203u8 , 230u8 , 82u8 , 198u8 , 183u8 , 55u8 , 82u8 , 221u8 , 248u8 , 100u8 , 173u8 , 206u8 , 151u8 ,]) } # [doc = " All unapplied slashes that are queued for later."] pub fn unapplied_slashes_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < runtime_types :: pallet_staking :: UnappliedSlash < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "UnappliedSlashes" , Vec :: new () , [130u8 , 4u8 , 163u8 , 163u8 , 28u8 , 85u8 , 34u8 , 156u8 , 47u8 , 125u8 , 57u8 , 0u8 , 133u8 , 176u8 , 130u8 , 2u8 , 175u8 , 180u8 , 167u8 , 203u8 , 230u8 , 82u8 , 198u8 , 183u8 , 55u8 , 82u8 , 221u8 , 248u8 , 100u8 , 173u8 , 206u8 , 151u8 ,]) } # [doc = " A mapping from still-bonded eras to the first session index of that era."] # [doc = ""] # [doc = " Must contains information for eras for the range:"] # [doc = " `[active_era - bounding_duration; active_era]`"] pub fn bonded_eras (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "BondedEras" , vec ! [] , [243u8 , 162u8 , 236u8 , 198u8 , 122u8 , 182u8 , 37u8 , 55u8 , 171u8 , 156u8 , 235u8 , 223u8 , 226u8 , 129u8 , 89u8 , 206u8 , 2u8 , 155u8 , 222u8 , 154u8 , 116u8 , 124u8 , 4u8 , 119u8 , 155u8 , 94u8 , 248u8 , 30u8 , 171u8 , 51u8 , 78u8 , 106u8 ,]) } # [doc = " All slashing events on validators, mapped by era to the highest slash proportion"] # [doc = " and slash value of the era."] pub fn validator_slash_in_era (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > , _1 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (runtime_types :: sp_arithmetic :: per_things :: Perbill , :: core :: primitive :: u128 ,) > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ValidatorSlashInEra" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat) , :: subxt :: storage :: address :: StorageMapKey :: new (_1 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [237u8 , 80u8 , 3u8 , 237u8 , 9u8 , 40u8 , 212u8 , 15u8 , 251u8 , 196u8 , 85u8 , 29u8 , 27u8 , 151u8 , 98u8 , 122u8 , 189u8 , 147u8 , 205u8 , 40u8 , 202u8 , 194u8 , 158u8 , 96u8 , 138u8 , 16u8 , 116u8 , 71u8 , 140u8 , 163u8 , 121u8 , 197u8 ,]) } # [doc = " All slashing events on validators, mapped by era to the highest slash proportion"] # [doc = " and slash value of the era."] pub fn validator_slash_in_era_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (runtime_types :: sp_arithmetic :: per_things :: Perbill , :: core :: primitive :: u128 ,) > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ValidatorSlashInEra" , Vec :: new () , [237u8 , 80u8 , 3u8 , 237u8 , 9u8 , 40u8 , 212u8 , 15u8 , 251u8 , 196u8 , 85u8 , 29u8 , 27u8 , 151u8 , 98u8 , 122u8 , 189u8 , 147u8 , 205u8 , 40u8 , 202u8 , 194u8 , 158u8 , 96u8 , 138u8 , 16u8 , 116u8 , 71u8 , 140u8 , 163u8 , 121u8 , 197u8 ,]) } # [doc = " All slashing events on nominators, mapped by era to the highest slash value of the era."] pub fn nominator_slash_in_era (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > , _1 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "NominatorSlashInEra" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat) , :: subxt :: storage :: address :: StorageMapKey :: new (_1 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [249u8 , 85u8 , 170u8 , 41u8 , 179u8 , 194u8 , 180u8 , 12u8 , 53u8 , 101u8 , 80u8 , 96u8 , 166u8 , 71u8 , 239u8 , 23u8 , 153u8 , 19u8 , 152u8 , 38u8 , 138u8 , 136u8 , 221u8 , 200u8 , 18u8 , 165u8 , 26u8 , 228u8 , 195u8 , 199u8 , 62u8 , 4u8 ,]) } # [doc = " All slashing events on nominators, mapped by era to the highest slash value of the era."] pub fn nominator_slash_in_era_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "NominatorSlashInEra" , Vec :: new () , [249u8 , 85u8 , 170u8 , 41u8 , 179u8 , 194u8 , 180u8 , 12u8 , 53u8 , 101u8 , 80u8 , 96u8 , 166u8 , 71u8 , 239u8 , 23u8 , 153u8 , 19u8 , 152u8 , 38u8 , 138u8 , 136u8 , 221u8 , 200u8 , 18u8 , 165u8 , 26u8 , 228u8 , 195u8 , 199u8 , 62u8 , 4u8 ,]) } # [doc = " Slashing spans for stash accounts."] pub fn slashing_spans (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: slashing :: SlashingSpans > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "SlashingSpans" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [106u8 , 115u8 , 118u8 , 52u8 , 89u8 , 77u8 , 246u8 , 5u8 , 255u8 , 204u8 , 44u8 , 5u8 , 66u8 , 36u8 , 227u8 , 252u8 , 86u8 , 159u8 , 186u8 , 152u8 , 196u8 , 21u8 , 74u8 , 201u8 , 133u8 , 93u8 , 142u8 , 191u8 , 20u8 , 27u8 , 218u8 , 157u8 ,]) } # [doc = " Slashing spans for stash accounts."] pub fn slashing_spans_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: slashing :: SlashingSpans > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "SlashingSpans" , Vec :: new () , [106u8 , 115u8 , 118u8 , 52u8 , 89u8 , 77u8 , 246u8 , 5u8 , 255u8 , 204u8 , 44u8 , 5u8 , 66u8 , 36u8 , 227u8 , 252u8 , 86u8 , 159u8 , 186u8 , 152u8 , 196u8 , 21u8 , 74u8 , 201u8 , 133u8 , 93u8 , 142u8 , 191u8 , 20u8 , 27u8 , 218u8 , 157u8 ,]) } # [doc = " Records information about the maximum slash of a stash within a slashing span,"] # [doc = " as well as how much reward has been paid out."] pub fn span_slash (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , _1 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: slashing :: SpanRecord < :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "SpanSlash" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (& (_0 . borrow () , _1 . borrow ()) , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [160u8 , 63u8 , 115u8 , 190u8 , 233u8 , 148u8 , 75u8 , 3u8 , 11u8 , 59u8 , 184u8 , 220u8 , 205u8 , 64u8 , 28u8 , 190u8 , 116u8 , 210u8 , 225u8 , 230u8 , 224u8 , 163u8 , 103u8 , 157u8 , 100u8 , 29u8 , 86u8 , 167u8 , 84u8 , 217u8 , 109u8 , 200u8 ,]) } # [doc = " Records information about the maximum slash of a stash within a slashing span,"] # [doc = " as well as how much reward has been paid out."] pub fn span_slash_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: slashing :: SpanRecord < :: core :: primitive :: u128 > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "SpanSlash" , Vec :: new () , [160u8 , 63u8 , 115u8 , 190u8 , 233u8 , 148u8 , 75u8 , 3u8 , 11u8 , 59u8 , 184u8 , 220u8 , 205u8 , 64u8 , 28u8 , 190u8 , 116u8 , 210u8 , 225u8 , 230u8 , 224u8 , 163u8 , 103u8 , 157u8 , 100u8 , 29u8 , 86u8 , 167u8 , 84u8 , 217u8 , 109u8 , 200u8 ,]) } # [doc = " The last planned session scheduled by the session pallet."] # [doc = ""] # [doc = " This is basically in sync with the call to [`pallet_session::SessionManager::new_session`]."] pub fn current_planned_session (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "CurrentPlannedSession" , vec ! [] , [38u8 , 22u8 , 56u8 , 250u8 , 17u8 , 154u8 , 99u8 , 37u8 , 155u8 , 253u8 , 100u8 , 117u8 , 5u8 , 239u8 , 31u8 , 190u8 , 53u8 , 241u8 , 11u8 , 185u8 , 163u8 , 227u8 , 10u8 , 77u8 , 210u8 , 64u8 , 156u8 , 218u8 , 105u8 , 16u8 , 1u8 , 57u8 ,]) } # [doc = " Indices of validators that have offended in the active era and whether they are currently"] # [doc = " disabled."] # [doc = ""] # [doc = " This value should be a superset of disabled validators since not all offences lead to the"] # [doc = " validator being disabled (if there was no slash). This is needed to track the percentage of"] # [doc = " validators that have offended in the current era, ensuring a new era is forced if"] # [doc = " `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find"] # [doc = " whether a given validator has previously offended using binary search. It gets cleared when"] # [doc = " the era ends."] pub fn offending_validators (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: bool ,) > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "OffendingValidators" , vec ! [] , [94u8 , 254u8 , 0u8 , 50u8 , 76u8 , 232u8 , 51u8 , 153u8 , 118u8 , 14u8 , 70u8 , 101u8 , 112u8 , 215u8 , 173u8 , 82u8 , 182u8 , 104u8 , 167u8 , 103u8 , 187u8 , 168u8 , 86u8 , 16u8 , 51u8 , 235u8 , 51u8 , 119u8 , 38u8 , 154u8 , 42u8 , 113u8 ,]) } # [doc = " True if network has been upgraded to this version."] # [doc = " Storage version of the pallet."] # [doc = ""] # [doc = " This is set to v7.0.0 for new networks."] pub fn storage_version (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_staking :: Releases > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "StorageVersion" , vec ! [] , [70u8 , 24u8 , 179u8 , 189u8 , 168u8 , 164u8 , 175u8 , 150u8 , 215u8 , 43u8 , 18u8 , 110u8 , 180u8 , 137u8 , 237u8 , 187u8 , 185u8 , 50u8 , 31u8 , 57u8 , 16u8 , 110u8 , 6u8 , 170u8 , 19u8 , 7u8 , 160u8 , 134u8 , 232u8 , 227u8 , 151u8 , 116u8 ,]) } # [doc = " The threshold for when users can start calling `chill_other` for other validators /"] # [doc = " nominators. The threshold is compared to the actual number of validators / nominators"] # [doc = " (`CountFor*`) in the system compared to the configured max (`Max*Count`)."] pub fn chill_threshold (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_arithmetic :: per_things :: Percent > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Staking" , "ChillThreshold" , vec ! [] , [174u8 , 165u8 , 249u8 , 105u8 , 24u8 , 151u8 , 115u8 , 166u8 , 199u8 , 251u8 , 28u8 , 5u8 , 50u8 , 95u8 , 144u8 , 110u8 , 220u8 , 76u8 , 14u8 , 23u8 , 179u8 , 41u8 , 11u8 , 248u8 , 28u8 , 154u8 , 159u8 , 255u8 , 156u8 , 109u8 , 98u8 , 92u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Maximum number of nominations per nominator."] pub fn max_nominations (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Staking" , "MaxNominations" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Number of eras to keep in history."] # [doc = ""] # [doc = " Following information is kept for eras in `[current_era -"] # [doc = " HistoryDepth, current_era]`: `ErasStakers`, `ErasStakersClipped`,"] # [doc = " `ErasValidatorPrefs`, `ErasValidatorReward`, `ErasRewardPoints`,"] # [doc = " `ErasTotalStake`, `ErasStartSessionIndex`,"] # [doc = " `StakingLedger.claimed_rewards`."] # [doc = ""] # [doc = " Must be more than the number of eras delayed by session."] # [doc = " I.e. active era must always be in history. I.e. `active_era >"] # [doc = " current_era - history_depth` must be guaranteed."] # [doc = ""] # [doc = " If migrating an existing pallet from storage value to config value,"] # [doc = " this should be set to same value or greater as in storage."] # [doc = ""] # [doc = " Note: `HistoryDepth` is used as the upper bound for the `BoundedVec`"] # [doc = " item `StakingLedger.claimed_rewards`. Setting this value lower than"] # [doc = " the existing value can lead to inconsistencies in the"] # [doc = " `StakingLedger` and will need to be handled properly in a migration."] # [doc = " The test `reducing_history_depth_abrupt` shows this effect."] pub fn history_depth (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Staking" , "HistoryDepth" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Number of sessions per era."] pub fn sessions_per_era (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Staking" , "SessionsPerEra" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Number of eras that staked funds must remain bonded for."] pub fn bonding_duration (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Staking" , "BondingDuration" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Number of eras that slashes are deferred by, after computation."] # [doc = ""] # [doc = " This should be less than the bonding duration. Set to 0 if slashes"] # [doc = " should be applied immediately, without opportunity for intervention."] pub fn slash_defer_duration (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Staking" , "SlashDeferDuration" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of nominators rewarded for each validator."] # [doc = ""] # [doc = " For each validator only the `$MaxNominatorRewardedPerValidator` biggest stakers can"] # [doc = " claim their reward. This used to limit the i/o cost for the nominator payout."] pub fn max_nominator_rewarded_per_validator (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Staking" , "MaxNominatorRewardedPerValidator" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of `unlocking` chunks a [`StakingLedger`] can"] # [doc = " have. Effectively determines how many unique eras a staker may be"] # [doc = " unbonding in."] # [doc = ""] # [doc = " Note: `MaxUnlockingChunks` is used as the upper bound for the"] # [doc = " `BoundedVec` item `StakingLedger.unlocking`. Setting this value"] # [doc = " lower than the existing value can lead to inconsistencies in the"] # [doc = " `StakingLedger` and will need to be handled properly in a runtime"] # [doc = " migration. The test `reducing_max_unlocking_chunks_abrupt` shows"] # [doc = " this effect."] pub fn max_unlocking_chunks (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Staking" , "MaxUnlockingChunks" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod staking_rewards { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetSessionExtraRewardPayout { # [codec (compact)] pub value : :: core :: primitive :: u128 , } pub struct TransactionApi ; impl TransactionApi { pub fn set_session_extra_reward_payout (& self , value : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < SetSessionExtraRewardPayout > { :: subxt :: tx :: StaticTxPayload :: new ("StakingRewards" , "set_session_extra_reward_payout" , SetSessionExtraRewardPayout { value , } , [206u8 , 107u8 , 54u8 , 89u8 , 21u8 , 57u8 , 127u8 , 150u8 , 233u8 , 164u8 , 243u8 , 171u8 , 224u8 , 255u8 , 226u8 , 28u8 , 129u8 , 95u8 , 126u8 , 87u8 , 242u8 , 134u8 , 52u8 , 8u8 , 172u8 , 126u8 , 151u8 , 247u8 , 168u8 , 155u8 , 202u8 , 138u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: ternoa_staking_rewards :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SessionExtraRewardPayoutChanged { pub value : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for SessionExtraRewardPayoutChanged { const PALLET : & 'static str = "StakingRewards" ; const EVENT : & 'static str = "SessionExtraRewardPayoutChanged" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { pub fn data (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_staking_rewards :: StakingRewardsData < :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("StakingRewards" , "Data" , vec ! [] , [239u8 , 57u8 , 30u8 , 110u8 , 48u8 , 109u8 , 145u8 , 127u8 , 49u8 , 66u8 , 219u8 , 189u8 , 52u8 , 171u8 , 125u8 , 63u8 , 250u8 , 247u8 , 190u8 , 43u8 , 154u8 , 146u8 , 203u8 , 179u8 , 131u8 , 62u8 , 151u8 , 158u8 , 240u8 , 99u8 , 56u8 , 52u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The auctions pallet id - will be used to generate account id"] pub fn pallet_id (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < runtime_types :: frame_support :: PalletId >> { :: subxt :: constants :: StaticConstantAddress :: new ("StakingRewards" , "PalletId" , [139u8 , 109u8 , 228u8 , 151u8 , 252u8 , 32u8 , 130u8 , 69u8 , 112u8 , 154u8 , 174u8 , 45u8 , 83u8 , 245u8 , 51u8 , 132u8 , 173u8 , 5u8 , 186u8 , 24u8 , 243u8 , 9u8 , 12u8 , 214u8 , 80u8 , 74u8 , 69u8 , 189u8 , 30u8 , 94u8 , 22u8 , 39u8 ,]) } } } } pub mod election_provider_multi_phase { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SubmitUnsigned { pub raw_solution : :: std :: boxed :: Box < runtime_types :: pallet_election_provider_multi_phase :: RawSolution < runtime_types :: ternoa_runtime_common :: election_provider_multi_phase :: NposCompactSolution24 > > , pub witness : runtime_types :: pallet_election_provider_multi_phase :: SolutionOrSnapshotSize , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetMinimumUntrustedScore { pub maybe_next_score : :: core :: option :: Option < runtime_types :: sp_npos_elections :: ElectionScore > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetEmergencyElectionResult { pub supports : :: std :: vec :: Vec < (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , runtime_types :: sp_npos_elections :: Support < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Submit { pub raw_solution : :: std :: boxed :: Box < runtime_types :: pallet_election_provider_multi_phase :: RawSolution < runtime_types :: ternoa_runtime_common :: election_provider_multi_phase :: NposCompactSolution24 > > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct GovernanceFallback { pub maybe_max_voters : :: core :: option :: Option < :: core :: primitive :: u32 > , pub maybe_max_targets : :: core :: option :: Option < :: core :: primitive :: u32 > , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Submit a solution for the unsigned phase."] # [doc = ""] # [doc = "The dispatch origin fo this call must be __none__."] # [doc = ""] # [doc = "This submission is checked on the fly. Moreover, this unsigned solution is only"] # [doc = "validated when submitted to the pool from the **local** node. Effectively, this means"] # [doc = "that only active validators can submit this transaction when authoring a block (similar"] # [doc = "to an inherent)."] # [doc = ""] # [doc = "To prevent any incorrect solution (and thus wasted time/weight), this transaction will"] # [doc = "panic if the solution submitted by the validator is invalid in any way, effectively"] # [doc = "putting their authoring reward at risk."] # [doc = ""] # [doc = "No deposit or reward is associated with this submission."] pub fn submit_unsigned (& self , raw_solution : runtime_types :: pallet_election_provider_multi_phase :: RawSolution < runtime_types :: ternoa_runtime_common :: election_provider_multi_phase :: NposCompactSolution24 > , witness : runtime_types :: pallet_election_provider_multi_phase :: SolutionOrSnapshotSize ,) -> :: subxt :: tx :: StaticTxPayload < SubmitUnsigned > { :: subxt :: tx :: StaticTxPayload :: new ("ElectionProviderMultiPhase" , "submit_unsigned" , SubmitUnsigned { raw_solution : :: std :: boxed :: Box :: new (raw_solution) , witness , } , [219u8 , 168u8 , 154u8 , 229u8 , 123u8 , 173u8 , 109u8 , 246u8 , 70u8 , 92u8 , 43u8 , 202u8 , 63u8 , 14u8 , 234u8 , 16u8 , 66u8 , 116u8 , 213u8 , 192u8 , 124u8 , 86u8 , 175u8 , 177u8 , 200u8 , 156u8 , 86u8 , 75u8 , 137u8 , 111u8 , 1u8 , 147u8 ,]) } # [doc = "Set a new value for `MinimumUntrustedScore`."] # [doc = ""] # [doc = "Dispatch origin must be aligned with `T::ForceOrigin`."] # [doc = ""] # [doc = "This check can be turned off by setting the value to `None`."] pub fn set_minimum_untrusted_score (& self , maybe_next_score : :: core :: option :: Option < runtime_types :: sp_npos_elections :: ElectionScore > ,) -> :: subxt :: tx :: StaticTxPayload < SetMinimumUntrustedScore > { :: subxt :: tx :: StaticTxPayload :: new ("ElectionProviderMultiPhase" , "set_minimum_untrusted_score" , SetMinimumUntrustedScore { maybe_next_score , } , [63u8 , 101u8 , 105u8 , 146u8 , 133u8 , 162u8 , 149u8 , 112u8 , 150u8 , 219u8 , 183u8 , 213u8 , 234u8 , 211u8 , 144u8 , 74u8 , 106u8 , 15u8 , 62u8 , 196u8 , 247u8 , 49u8 , 20u8 , 48u8 , 3u8 , 105u8 , 85u8 , 46u8 , 76u8 , 4u8 , 67u8 , 81u8 ,]) } # [doc = "Set a solution in the queue, to be handed out to the client of this pallet in the next"] # [doc = "call to `ElectionProvider::elect`."] # [doc = ""] # [doc = "This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`."] # [doc = ""] # [doc = "The solution is not checked for any feasibility and is assumed to be trustworthy, as any"] # [doc = "feasibility check itself can in principle cause the election process to fail (due to"] # [doc = "memory/weight constrains)."] pub fn set_emergency_election_result (& self , supports : :: std :: vec :: Vec < (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , runtime_types :: sp_npos_elections :: Support < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) > ,) -> :: subxt :: tx :: StaticTxPayload < SetEmergencyElectionResult > { :: subxt :: tx :: StaticTxPayload :: new ("ElectionProviderMultiPhase" , "set_emergency_election_result" , SetEmergencyElectionResult { supports , } , [115u8 , 255u8 , 205u8 , 58u8 , 153u8 , 1u8 , 246u8 , 8u8 , 225u8 , 36u8 , 66u8 , 144u8 , 250u8 , 145u8 , 70u8 , 76u8 , 54u8 , 63u8 , 251u8 , 51u8 , 214u8 , 204u8 , 55u8 , 112u8 , 46u8 , 228u8 , 255u8 , 250u8 , 151u8 , 5u8 , 44u8 , 133u8 ,]) } # [doc = "Submit a solution for the signed phase."] # [doc = ""] # [doc = "The dispatch origin fo this call must be __signed__."] # [doc = ""] # [doc = "The solution is potentially queued, based on the claimed score and processed at the end"] # [doc = "of the signed phase."] # [doc = ""] # [doc = "A deposit is reserved and recorded for the solution. Based on the outcome, the solution"] # [doc = "might be rewarded, slashed, or get all or a part of the deposit back."] pub fn submit (& self , raw_solution : runtime_types :: pallet_election_provider_multi_phase :: RawSolution < runtime_types :: ternoa_runtime_common :: election_provider_multi_phase :: NposCompactSolution24 > ,) -> :: subxt :: tx :: StaticTxPayload < Submit > { :: subxt :: tx :: StaticTxPayload :: new ("ElectionProviderMultiPhase" , "submit" , Submit { raw_solution : :: std :: boxed :: Box :: new (raw_solution) , } , [188u8 , 170u8 , 122u8 , 64u8 , 230u8 , 18u8 , 186u8 , 163u8 , 223u8 , 113u8 , 114u8 , 101u8 , 200u8 , 0u8 , 16u8 , 138u8 , 141u8 , 159u8 , 86u8 , 83u8 , 193u8 , 9u8 , 143u8 , 162u8 , 127u8 , 6u8 , 125u8 , 17u8 , 74u8 , 224u8 , 99u8 , 127u8 ,]) } # [doc = "Trigger the governance fallback."] # [doc = ""] # [doc = "This can only be called when [`Phase::Emergency`] is enabled, as an alternative to"] # [doc = "calling [`Call::set_emergency_election_result`]."] pub fn governance_fallback (& self , maybe_max_voters : :: core :: option :: Option < :: core :: primitive :: u32 > , maybe_max_targets : :: core :: option :: Option < :: core :: primitive :: u32 > ,) -> :: subxt :: tx :: StaticTxPayload < GovernanceFallback > { :: subxt :: tx :: StaticTxPayload :: new ("ElectionProviderMultiPhase" , "governance_fallback" , GovernanceFallback { maybe_max_voters , maybe_max_targets , } , [206u8 , 247u8 , 76u8 , 85u8 , 7u8 , 24u8 , 231u8 , 226u8 , 192u8 , 143u8 , 43u8 , 67u8 , 91u8 , 202u8 , 88u8 , 176u8 , 130u8 , 1u8 , 83u8 , 229u8 , 227u8 , 200u8 , 179u8 , 4u8 , 113u8 , 60u8 , 99u8 , 190u8 , 53u8 , 226u8 , 142u8 , 182u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_election_provider_multi_phase :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A solution was stored with the given compute."] # [doc = ""] # [doc = "If the solution is signed, this means that it hasn't yet been processed. If the"] # [doc = "solution is unsigned, this means that it has also been processed."] # [doc = ""] # [doc = "The `bool` is `true` when a previous solution was ejected to make room for this one."] pub struct SolutionStored { pub compute : runtime_types :: pallet_election_provider_multi_phase :: ElectionCompute , pub prev_ejected : :: core :: primitive :: bool , } impl :: subxt :: events :: StaticEvent for SolutionStored { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const EVENT : & 'static str = "SolutionStored" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "The election has been finalized, with the given computation and score."] pub struct ElectionFinalized { pub compute : runtime_types :: pallet_election_provider_multi_phase :: ElectionCompute , pub score : runtime_types :: sp_npos_elections :: ElectionScore , } impl :: subxt :: events :: StaticEvent for ElectionFinalized { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const EVENT : & 'static str = "ElectionFinalized" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An election failed."] # [doc = ""] # [doc = "Not much can be said about which computes failed in the process."] pub struct ElectionFailed ; impl :: subxt :: events :: StaticEvent for ElectionFailed { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const EVENT : & 'static str = "ElectionFailed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An account has been rewarded for their signed submission being finalized."] pub struct Rewarded { pub account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub value : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Rewarded { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const EVENT : & 'static str = "Rewarded" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An account has been slashed for submitting an invalid signed submission."] pub struct Slashed { pub account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub value : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Slashed { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const EVENT : & 'static str = "Slashed" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "The signed phase of the given round has started."] pub struct SignedPhaseStarted { pub round : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for SignedPhaseStarted { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const EVENT : & 'static str = "SignedPhaseStarted" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "The unsigned phase of the given round has started."] pub struct UnsignedPhaseStarted { pub round : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for UnsignedPhaseStarted { const PALLET : & 'static str = "ElectionProviderMultiPhase" ; const EVENT : & 'static str = "UnsignedPhaseStarted" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Internal counter for the number of rounds."] # [doc = ""] # [doc = " This is useful for de-duplication of transactions submitted to the pool, and general"] # [doc = " diagnostics of the pallet."] # [doc = ""] # [doc = " This is merely incremented once per every time that an upstream `elect` is called."] pub fn round (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ElectionProviderMultiPhase" , "Round" , vec ! [] , [16u8 , 49u8 , 176u8 , 52u8 , 202u8 , 111u8 , 120u8 , 8u8 , 217u8 , 96u8 , 35u8 , 14u8 , 233u8 , 130u8 , 47u8 , 98u8 , 34u8 , 44u8 , 166u8 , 188u8 , 199u8 , 210u8 , 21u8 , 19u8 , 70u8 , 96u8 , 139u8 , 8u8 , 53u8 , 82u8 , 165u8 , 239u8 ,]) } # [doc = " Current phase."] pub fn current_phase (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_election_provider_multi_phase :: Phase < :: core :: primitive :: u32 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ElectionProviderMultiPhase" , "CurrentPhase" , vec ! [] , [236u8 , 101u8 , 8u8 , 52u8 , 68u8 , 240u8 , 74u8 , 159u8 , 181u8 , 53u8 , 153u8 , 101u8 , 228u8 , 81u8 , 96u8 , 161u8 , 34u8 , 67u8 , 35u8 , 28u8 , 121u8 , 44u8 , 229u8 , 45u8 , 196u8 , 87u8 , 73u8 , 125u8 , 216u8 , 245u8 , 255u8 , 15u8 ,]) } # [doc = " Current best solution, signed or unsigned, queued to be returned upon `elect`."] pub fn queued_solution (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_election_provider_multi_phase :: ReadySolution < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ElectionProviderMultiPhase" , "QueuedSolution" , vec ! [] , [149u8 , 246u8 , 152u8 , 57u8 , 54u8 , 217u8 , 14u8 , 124u8 , 125u8 , 202u8 , 242u8 , 149u8 , 147u8 , 201u8 , 168u8 , 99u8 , 249u8 , 17u8 , 163u8 , 184u8 , 254u8 , 115u8 , 100u8 , 108u8 , 28u8 , 14u8 , 139u8 , 215u8 , 26u8 , 93u8 , 215u8 , 251u8 ,]) } # [doc = " Snapshot data of the round."] # [doc = ""] # [doc = " This is created at the beginning of the signed phase and cleared upon calling `elect`."] pub fn snapshot (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_election_provider_multi_phase :: RoundSnapshot > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ElectionProviderMultiPhase" , "Snapshot" , vec ! [] , [239u8 , 56u8 , 191u8 , 77u8 , 150u8 , 224u8 , 248u8 , 88u8 , 132u8 , 224u8 , 164u8 , 83u8 , 253u8 , 36u8 , 46u8 , 156u8 , 72u8 , 152u8 , 36u8 , 206u8 , 72u8 , 27u8 , 226u8 , 87u8 , 146u8 , 220u8 , 93u8 , 178u8 , 26u8 , 115u8 , 232u8 , 71u8 ,]) } # [doc = " Desired number of targets to elect for this round."] # [doc = ""] # [doc = " Only exists when [`Snapshot`] is present."] pub fn desired_targets (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ElectionProviderMultiPhase" , "DesiredTargets" , vec ! [] , [16u8 , 247u8 , 4u8 , 181u8 , 93u8 , 79u8 , 12u8 , 212u8 , 146u8 , 167u8 , 80u8 , 58u8 , 118u8 , 52u8 , 68u8 , 87u8 , 90u8 , 140u8 , 31u8 , 210u8 , 2u8 , 116u8 , 220u8 , 231u8 , 115u8 , 112u8 , 118u8 , 118u8 , 68u8 , 34u8 , 151u8 , 165u8 ,]) } # [doc = " The metadata of the [`RoundSnapshot`]"] # [doc = ""] # [doc = " Only exists when [`Snapshot`] is present."] pub fn snapshot_metadata (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_election_provider_multi_phase :: SolutionOrSnapshotSize > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ElectionProviderMultiPhase" , "SnapshotMetadata" , vec ! [] , [135u8 , 122u8 , 60u8 , 75u8 , 194u8 , 240u8 , 187u8 , 96u8 , 240u8 , 203u8 , 192u8 , 22u8 , 117u8 , 148u8 , 118u8 , 24u8 , 240u8 , 213u8 , 94u8 , 22u8 , 194u8 , 47u8 , 181u8 , 245u8 , 77u8 , 149u8 , 11u8 , 251u8 , 117u8 , 220u8 , 205u8 , 78u8 ,]) } # [doc = " The next index to be assigned to an incoming signed submission."] # [doc = ""] # [doc = " Every accepted submission is assigned a unique index; that index is bound to that particular"] # [doc = " submission for the duration of the election. On election finalization, the next index is"] # [doc = " reset to 0."] # [doc = ""] # [doc = " We can't just use `SignedSubmissionIndices.len()`, because that's a bounded set; past its"] # [doc = " capacity, it will simply saturate. We can't just iterate over `SignedSubmissionsMap`,"] # [doc = " because iteration is slow. Instead, we store the value here."] pub fn signed_submission_next_index (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ElectionProviderMultiPhase" , "SignedSubmissionNextIndex" , vec ! [] , [242u8 , 11u8 , 157u8 , 105u8 , 96u8 , 7u8 , 31u8 , 20u8 , 51u8 , 141u8 , 182u8 , 180u8 , 13u8 , 172u8 , 155u8 , 59u8 , 42u8 , 238u8 , 115u8 , 8u8 , 6u8 , 137u8 , 45u8 , 2u8 , 123u8 , 187u8 , 53u8 , 215u8 , 19u8 , 129u8 , 54u8 , 22u8 ,]) } # [doc = " A sorted, bounded set of `(score, index)`, where each `index` points to a value in"] # [doc = " `SignedSubmissions`."] # [doc = ""] # [doc = " We never need to process more than a single signed submission at a time. Signed submissions"] # [doc = " can be quite large, so we're willing to pay the cost of multiple database accesses to access"] # [doc = " them one at a time instead of reading and decoding all of them at once."] pub fn signed_submission_indices (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_btree_map :: BoundedBTreeMap < runtime_types :: sp_npos_elections :: ElectionScore , :: core :: primitive :: u32 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ElectionProviderMultiPhase" , "SignedSubmissionIndices" , vec ! [] , [121u8 , 119u8 , 26u8 , 183u8 , 167u8 , 33u8 , 230u8 , 159u8 , 230u8 , 171u8 , 8u8 , 52u8 , 178u8 , 214u8 , 245u8 , 148u8 , 202u8 , 6u8 , 7u8 , 50u8 , 84u8 , 174u8 , 253u8 , 131u8 , 235u8 , 136u8 , 40u8 , 83u8 , 2u8 , 64u8 , 9u8 , 83u8 ,]) } # [doc = " Unchecked, signed solutions."] # [doc = ""] # [doc = " Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while"] # [doc = " allowing us to keep only a single one in memory at a time."] # [doc = ""] # [doc = " Twox note: the key of the map is an auto-incrementing index which users cannot inspect or"] # [doc = " affect; we shouldn't need a cryptographically secure hasher."] pub fn signed_submissions_map (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_election_provider_multi_phase :: signed :: SignedSubmission < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , runtime_types :: ternoa_runtime_common :: election_provider_multi_phase :: NposCompactSolution24 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ElectionProviderMultiPhase" , "SignedSubmissionsMap" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [55u8 , 36u8 , 106u8 , 128u8 , 99u8 , 33u8 , 8u8 , 233u8 , 211u8 , 54u8 , 231u8 , 98u8 , 18u8 , 90u8 , 179u8 , 169u8 , 126u8 , 145u8 , 171u8 , 52u8 , 131u8 , 118u8 , 207u8 , 136u8 , 210u8 , 36u8 , 173u8 , 163u8 , 79u8 , 109u8 , 216u8 , 40u8 ,]) } # [doc = " Unchecked, signed solutions."] # [doc = ""] # [doc = " Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while"] # [doc = " allowing us to keep only a single one in memory at a time."] # [doc = ""] # [doc = " Twox note: the key of the map is an auto-incrementing index which users cannot inspect or"] # [doc = " affect; we shouldn't need a cryptographically secure hasher."] pub fn signed_submissions_map_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_election_provider_multi_phase :: signed :: SignedSubmission < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , runtime_types :: ternoa_runtime_common :: election_provider_multi_phase :: NposCompactSolution24 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ElectionProviderMultiPhase" , "SignedSubmissionsMap" , Vec :: new () , [55u8 , 36u8 , 106u8 , 128u8 , 99u8 , 33u8 , 8u8 , 233u8 , 211u8 , 54u8 , 231u8 , 98u8 , 18u8 , 90u8 , 179u8 , 169u8 , 126u8 , 145u8 , 171u8 , 52u8 , 131u8 , 118u8 , 207u8 , 136u8 , 210u8 , 36u8 , 173u8 , 163u8 , 79u8 , 109u8 , 216u8 , 40u8 ,]) } # [doc = " The minimum score that each 'untrusted' solution must attain in order to be considered"] # [doc = " feasible."] # [doc = ""] # [doc = " Can be set via `set_minimum_untrusted_score`."] pub fn minimum_untrusted_score (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_npos_elections :: ElectionScore > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("ElectionProviderMultiPhase" , "MinimumUntrustedScore" , vec ! [] , [77u8 , 235u8 , 181u8 , 45u8 , 230u8 , 12u8 , 0u8 , 179u8 , 152u8 , 38u8 , 74u8 , 199u8 , 47u8 , 84u8 , 85u8 , 55u8 , 171u8 , 226u8 , 217u8 , 125u8 , 17u8 , 194u8 , 95u8 , 157u8 , 73u8 , 245u8 , 75u8 , 130u8 , 248u8 , 7u8 , 53u8 , 226u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Duration of the unsigned phase."] pub fn unsigned_phase (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "UnsignedPhase" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Duration of the signed phase."] pub fn signed_phase (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "SignedPhase" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The minimum amount of improvement to the solution score that defines a solution as"] # [doc = " \"better\" in the Signed phase."] pub fn better_signed_threshold (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_arithmetic :: per_things :: Perbill >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "BetterSignedThreshold" , [225u8 , 236u8 , 95u8 , 157u8 , 90u8 , 94u8 , 106u8 , 192u8 , 254u8 , 19u8 , 87u8 , 80u8 , 16u8 , 62u8 , 42u8 , 204u8 , 136u8 , 106u8 , 225u8 , 53u8 , 212u8 , 52u8 , 177u8 , 79u8 , 4u8 , 116u8 , 201u8 , 104u8 , 222u8 , 75u8 , 86u8 , 227u8 ,]) } # [doc = " The minimum amount of improvement to the solution score that defines a solution as"] # [doc = " \"better\" in the Unsigned phase."] pub fn better_unsigned_threshold (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_arithmetic :: per_things :: Perbill >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "BetterUnsignedThreshold" , [225u8 , 236u8 , 95u8 , 157u8 , 90u8 , 94u8 , 106u8 , 192u8 , 254u8 , 19u8 , 87u8 , 80u8 , 16u8 , 62u8 , 42u8 , 204u8 , 136u8 , 106u8 , 225u8 , 53u8 , 212u8 , 52u8 , 177u8 , 79u8 , 4u8 , 116u8 , 201u8 , 104u8 , 222u8 , 75u8 , 86u8 , 227u8 ,]) } # [doc = " The repeat threshold of the offchain worker."] # [doc = ""] # [doc = " For example, if it is 5, that means that at least 5 blocks will elapse between attempts"] # [doc = " to submit the worker's solution."] pub fn offchain_repeat (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "OffchainRepeat" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The priority of the unsigned transaction submitted in the unsigned-phase"] pub fn miner_tx_priority (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u64 >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "MinerTxPriority" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } # [doc = " Maximum number of signed submissions that can be queued."] # [doc = ""] # [doc = " It is best to avoid adjusting this during an election, as it impacts downstream data"] # [doc = " structures. In particular, `SignedSubmissionIndices<T>` is bounded on this value. If you"] # [doc = " update this value during an election, you _must_ ensure that"] # [doc = " `SignedSubmissionIndices.len()` is less than or equal to the new value. Otherwise,"] # [doc = " attempts to submit new solutions may cause a runtime panic."] pub fn signed_max_submissions (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "SignedMaxSubmissions" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Maximum weight of a signed solution."] # [doc = ""] # [doc = " If [`Config::MinerConfig`] is being implemented to submit signed solutions (outside of"] # [doc = " this pallet), then [`MinerConfig::solution_weight`] is used to compare against"] # [doc = " this value."] pub fn signed_max_weight (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_weights :: weight_v2 :: Weight >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "SignedMaxWeight" , [206u8 , 61u8 , 253u8 , 247u8 , 163u8 , 40u8 , 161u8 , 52u8 , 134u8 , 140u8 , 206u8 , 83u8 , 44u8 , 166u8 , 226u8 , 115u8 , 181u8 , 14u8 , 227u8 , 130u8 , 210u8 , 32u8 , 85u8 , 29u8 , 230u8 , 97u8 , 130u8 , 165u8 , 147u8 , 134u8 , 106u8 , 76u8 ,]) } # [doc = " The maximum amount of unchecked solutions to refund the call fee for."] pub fn signed_max_refunds (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "SignedMaxRefunds" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Base reward for a signed solution"] pub fn signed_reward_base (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "SignedRewardBase" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " Base deposit for a signed solution."] pub fn signed_deposit_base (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "SignedDepositBase" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " Per-byte deposit for a signed solution."] pub fn signed_deposit_byte (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "SignedDepositByte" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " Per-weight deposit for a signed solution."] pub fn signed_deposit_weight (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "SignedDepositWeight" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The maximum number of electing voters to put in the snapshot. At the moment, snapshots"] # [doc = " are only over a single block, but once multi-block elections are introduced they will"] # [doc = " take place over multiple blocks."] pub fn max_electing_voters (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "MaxElectingVoters" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of electable targets to put in the snapshot."] pub fn max_electable_targets (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u16 >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "MaxElectableTargets" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } pub fn miner_max_length (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "MinerMaxLength" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } pub fn miner_max_weight (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_weights :: weight_v2 :: Weight >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "MinerMaxWeight" , [206u8 , 61u8 , 253u8 , 247u8 , 163u8 , 40u8 , 161u8 , 52u8 , 134u8 , 140u8 , 206u8 , 83u8 , 44u8 , 166u8 , 226u8 , 115u8 , 181u8 , 14u8 , 227u8 , 130u8 , 210u8 , 32u8 , 85u8 , 29u8 , 230u8 , 97u8 , 130u8 , 165u8 , 147u8 , 134u8 , 106u8 , 76u8 ,]) } pub fn miner_max_votes_per_voter (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("ElectionProviderMultiPhase" , "MinerMaxVotesPerVoter" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod bags_list { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Rebag { pub dislocated : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct PutInFrontOf { pub lighter : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Declare that some `dislocated` account has, through rewards or penalties, sufficiently"] # [doc = "changed its score that it should properly fall into a different bag than its current"] # [doc = "one."] # [doc = ""] # [doc = "Anyone can call this function about any potentially dislocated account."] # [doc = ""] # [doc = "Will always update the stored score of `dislocated` to the correct score, based on"] # [doc = "`ScoreProvider`."] # [doc = ""] # [doc = "If `dislocated` does not exists, it returns an error."] pub fn rebag (& self , dislocated : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < Rebag > { :: subxt :: tx :: StaticTxPayload :: new ("BagsList" , "rebag" , Rebag { dislocated , } , [35u8 , 182u8 , 31u8 , 22u8 , 190u8 , 187u8 , 31u8 , 138u8 , 60u8 , 48u8 , 236u8 , 16u8 , 191u8 , 143u8 , 52u8 , 110u8 , 228u8 , 43u8 , 116u8 , 13u8 , 171u8 , 108u8 , 112u8 , 123u8 , 252u8 , 231u8 , 132u8 , 97u8 , 195u8 , 148u8 , 252u8 , 241u8 ,]) } # [doc = "Move the caller's Id directly in front of `lighter`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and can only be called by the Id of"] # [doc = "the account going in front of `lighter`."] # [doc = ""] # [doc = "Only works if"] # [doc = "- both nodes are within the same bag,"] # [doc = "- and `origin` has a greater `Score` than `lighter`."] pub fn put_in_front_of (& self , lighter : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < PutInFrontOf > { :: subxt :: tx :: StaticTxPayload :: new ("BagsList" , "put_in_front_of" , PutInFrontOf { lighter , } , [184u8 , 194u8 , 39u8 , 91u8 , 28u8 , 220u8 , 76u8 , 199u8 , 64u8 , 252u8 , 233u8 , 241u8 , 74u8 , 19u8 , 246u8 , 190u8 , 108u8 , 227u8 , 77u8 , 162u8 , 225u8 , 230u8 , 101u8 , 72u8 , 159u8 , 217u8 , 133u8 , 107u8 , 84u8 , 83u8 , 81u8 , 227u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_bags_list :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Moved an account from one bag to another."] pub struct Rebagged { pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub from : :: core :: primitive :: u64 , pub to : :: core :: primitive :: u64 , } impl :: subxt :: events :: StaticEvent for Rebagged { const PALLET : & 'static str = "BagsList" ; const EVENT : & 'static str = "Rebagged" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Updated the score of some account to the given amount."] pub struct ScoreUpdated { pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub new_score : :: core :: primitive :: u64 , } impl :: subxt :: events :: StaticEvent for ScoreUpdated { const PALLET : & 'static str = "BagsList" ; const EVENT : & 'static str = "ScoreUpdated" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " A single node, within some bag."] # [doc = ""] # [doc = " Nodes store links forward and back within their respective bags."] pub fn list_nodes (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_bags_list :: list :: Node > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("BagsList" , "ListNodes" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [176u8 , 186u8 , 93u8 , 51u8 , 100u8 , 184u8 , 240u8 , 29u8 , 70u8 , 3u8 , 117u8 , 47u8 , 23u8 , 66u8 , 231u8 , 234u8 , 53u8 , 8u8 , 234u8 , 175u8 , 181u8 , 8u8 , 161u8 , 154u8 , 48u8 , 178u8 , 147u8 , 227u8 , 122u8 , 115u8 , 57u8 , 97u8 ,]) } # [doc = " A single node, within some bag."] # [doc = ""] # [doc = " Nodes store links forward and back within their respective bags."] pub fn list_nodes_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_bags_list :: list :: Node > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("BagsList" , "ListNodes" , Vec :: new () , [176u8 , 186u8 , 93u8 , 51u8 , 100u8 , 184u8 , 240u8 , 29u8 , 70u8 , 3u8 , 117u8 , 47u8 , 23u8 , 66u8 , 231u8 , 234u8 , 53u8 , 8u8 , 234u8 , 175u8 , 181u8 , 8u8 , 161u8 , 154u8 , 48u8 , 178u8 , 147u8 , 227u8 , 122u8 , 115u8 , 57u8 , 97u8 ,]) } # [doc = "Counter for the related counted storage map"] pub fn counter_for_list_nodes (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("BagsList" , "CounterForListNodes" , vec ! [] , [156u8 , 168u8 , 97u8 , 33u8 , 84u8 , 117u8 , 220u8 , 89u8 , 62u8 , 182u8 , 24u8 , 88u8 , 231u8 , 244u8 , 41u8 , 19u8 , 210u8 , 131u8 , 87u8 , 0u8 , 241u8 , 230u8 , 160u8 , 142u8 , 128u8 , 153u8 , 83u8 , 36u8 , 88u8 , 247u8 , 70u8 , 130u8 ,]) } # [doc = " A bag stored in storage."] # [doc = ""] # [doc = " Stores a `Bag` struct, which stores head and tail pointers to itself."] pub fn list_bags (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u64 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_bags_list :: list :: Bag > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("BagsList" , "ListBags" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [38u8 , 86u8 , 63u8 , 92u8 , 85u8 , 59u8 , 225u8 , 244u8 , 14u8 , 155u8 , 76u8 , 249u8 , 153u8 , 140u8 , 179u8 , 7u8 , 96u8 , 170u8 , 236u8 , 179u8 , 4u8 , 18u8 , 232u8 , 146u8 , 216u8 , 51u8 , 135u8 , 116u8 , 196u8 , 117u8 , 143u8 , 153u8 ,]) } # [doc = " A bag stored in storage."] # [doc = ""] # [doc = " Stores a `Bag` struct, which stores head and tail pointers to itself."] pub fn list_bags_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_bags_list :: list :: Bag > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("BagsList" , "ListBags" , Vec :: new () , [38u8 , 86u8 , 63u8 , 92u8 , 85u8 , 59u8 , 225u8 , 244u8 , 14u8 , 155u8 , 76u8 , 249u8 , 153u8 , 140u8 , 179u8 , 7u8 , 96u8 , 170u8 , 236u8 , 179u8 , 4u8 , 18u8 , 232u8 , 146u8 , 216u8 , 51u8 , 135u8 , 116u8 , 196u8 , 117u8 , 143u8 , 153u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The list of thresholds separating the various bags."] # [doc = ""] # [doc = " Ids are separated into unsorted bags according to their score. This specifies the"] # [doc = " thresholds separating the bags. An id's bag is the largest bag for which the id's score"] # [doc = " is less than or equal to its upper threshold."] # [doc = ""] # [doc = " When ids are iterated, higher bags are iterated completely before lower bags. This means"] # [doc = " that iteration is _semi-sorted_: ids of higher score tend to come before ids of lower"] # [doc = " score, but peer ids within a particular bag are sorted in insertion order."] # [doc = ""] # [doc = " # Expressing the constant"] # [doc = ""] # [doc = " This constant must be sorted in strictly increasing order. Duplicate items are not"] # [doc = " permitted."] # [doc = ""] # [doc = " There is an implied upper limit of `Score::MAX`; that value does not need to be"] # [doc = " specified within the bag. For any two threshold lists, if one ends with"] # [doc = " `Score::MAX`, the other one does not, and they are otherwise equal, the two"] # [doc = " lists will behave identically."] # [doc = ""] # [doc = " # Calculation"] # [doc = ""] # [doc = " It is recommended to generate the set of thresholds in a geometric series, such that"] # [doc = " there exists some constant ratio such that `threshold[k + 1] == (threshold[k] *"] # [doc = " constant_ratio).max(threshold[k] + 1)` for all `k`."] # [doc = ""] # [doc = " The helpers in the `/utils/frame/generate-bags` module can simplify this calculation."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " - If `BagThresholds::get().is_empty()`, then all ids are put into the same bag, and"] # [doc = "   iteration is strictly in insertion order."] # [doc = " - If `BagThresholds::get().len() == 64`, and the thresholds are determined according to"] # [doc = "   the procedure given above, then the constant ratio is equal to 2."] # [doc = " - If `BagThresholds::get().len() == 200`, and the thresholds are determined according to"] # [doc = "   the procedure given above, then the constant ratio is approximately equal to 1.248."] # [doc = " - If the threshold list begins `[1, 2, 3, ...]`, then an id with score 0 or 1 will fall"] # [doc = "   into bag 0, an id with score 2 will fall into bag 1, etc."] # [doc = ""] # [doc = " # Migration"] # [doc = ""] # [doc = " In the event that this list ever changes, a copy of the old bags list must be retained."] # [doc = " With that `List::migrate` can be called, which will perform the appropriate migration."] pub fn bag_thresholds (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < :: core :: primitive :: u64 > >> { :: subxt :: constants :: StaticConstantAddress :: new ("BagsList" , "BagThresholds" , [103u8 , 102u8 , 255u8 , 165u8 , 124u8 , 54u8 , 5u8 , 172u8 , 112u8 , 234u8 , 25u8 , 175u8 , 178u8 , 19u8 , 251u8 , 73u8 , 91u8 , 192u8 , 227u8 , 81u8 , 249u8 , 45u8 , 126u8 , 116u8 , 7u8 , 37u8 , 9u8 , 200u8 , 167u8 , 182u8 , 12u8 , 131u8 ,]) } } } } pub mod technical_committee { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetMembers { pub new_members : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , pub prime : :: core :: option :: Option < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , pub old_count : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Execute { pub proposal : :: std :: boxed :: Box < runtime_types :: alphanet_runtime :: RuntimeCall > , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Propose { # [codec (compact)] pub threshold : :: core :: primitive :: u32 , pub proposal : :: std :: boxed :: Box < runtime_types :: alphanet_runtime :: RuntimeCall > , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Vote { pub proposal : :: subxt :: ext :: sp_core :: H256 , # [codec (compact)] pub index : :: core :: primitive :: u32 , pub approve : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CloseOldWeight { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , # [codec (compact)] pub index : :: core :: primitive :: u32 , # [codec (compact)] pub proposal_weight_bound : runtime_types :: sp_weights :: OldWeight , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct DisapproveProposal { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Close { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , # [codec (compact)] pub index : :: core :: primitive :: u32 , pub proposal_weight_bound : runtime_types :: sp_weights :: weight_v2 :: Weight , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Set the collective's membership."] # [doc = ""] # [doc = "- `new_members`: The new member list. Be nice to the chain and provide it sorted."] # [doc = "- `prime`: The prime member whose vote sets the default."] # [doc = "- `old_count`: The upper bound for the previous number of members in storage. Used for"] # [doc = "  weight estimation."] # [doc = ""] # [doc = "Requires root origin."] # [doc = ""] # [doc = "NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but"] # [doc = "      the weight estimations rely on it to estimate dispatchable weight."] # [doc = ""] # [doc = "# WARNING:"] # [doc = ""] # [doc = "The `pallet-collective` can also be managed by logic outside of the pallet through the"] # [doc = "implementation of the trait [`ChangeMembers`]."] # [doc = "Any call to `set_members` must be careful that the member set doesn't get out of sync"] # [doc = "with other logic managing the member set."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(MP + N)` where:"] # [doc = "  - `M` old-members-count (code- and governance-bounded)"] # [doc = "  - `N` new-members-count (code- and governance-bounded)"] # [doc = "  - `P` proposals-count (code-bounded)"] # [doc = "- DB:"] # [doc = "  - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the"] # [doc = "    members"] # [doc = "  - 1 storage read (codec `O(P)`) for reading the proposals"] # [doc = "  - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal"] # [doc = "  - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one"] # [doc = "# </weight>"] pub fn set_members (& self , new_members : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , prime : :: core :: option :: Option < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , old_count : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < SetMembers > { :: subxt :: tx :: StaticTxPayload :: new ("TechnicalCommittee" , "set_members" , SetMembers { new_members , prime , old_count , } , [196u8 , 103u8 , 123u8 , 125u8 , 226u8 , 177u8 , 126u8 , 37u8 , 160u8 , 114u8 , 34u8 , 136u8 , 219u8 , 84u8 , 199u8 , 94u8 , 242u8 , 20u8 , 126u8 , 126u8 , 166u8 , 190u8 , 198u8 , 33u8 , 162u8 , 113u8 , 237u8 , 222u8 , 90u8 , 1u8 , 2u8 , 234u8 ,]) } # [doc = "Dispatch a proposal from a member using the `Member` origin."] # [doc = ""] # [doc = "Origin must be a member of the collective."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching"] # [doc = "  `proposal`"] # [doc = "- DB: 1 read (codec `O(M)`) + DB access of `proposal`"] # [doc = "- 1 event"] # [doc = "# </weight>"] pub fn execute (& self , proposal : runtime_types :: alphanet_runtime :: RuntimeCall , length_bound : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < Execute > { :: subxt :: tx :: StaticTxPayload :: new ("TechnicalCommittee" , "execute" , Execute { proposal : :: std :: boxed :: Box :: new (proposal) , length_bound , } , [229u8 , 213u8 , 163u8 , 8u8 , 98u8 , 61u8 , 235u8 , 111u8 , 34u8 , 62u8 , 191u8 , 67u8 , 177u8 , 154u8 , 8u8 , 151u8 , 67u8 , 64u8 , 45u8 , 181u8 , 28u8 , 68u8 , 250u8 , 107u8 , 217u8 , 164u8 , 38u8 , 121u8 , 6u8 , 72u8 , 92u8 , 103u8 ,]) } # [doc = "Add a new proposal to either be voted on or executed directly."] # [doc = ""] # [doc = "Requires the sender to be member."] # [doc = ""] # [doc = "`threshold` determines whether `proposal` is executed directly (`threshold < 2`)"] # [doc = "or put up for voting."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(B + M + P1)` or `O(B + M + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - branching is influenced by `threshold` where:"] # [doc = "    - `P1` is proposal execution complexity (`threshold < 2`)"] # [doc = "    - `P2` is proposals-count (code-bounded) (`threshold >= 2`)"] # [doc = "- DB:"] # [doc = "  - 1 storage read `is_member` (codec `O(M)`)"] # [doc = "  - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)"] # [doc = "  - DB accesses influenced by `threshold`:"] # [doc = "    - EITHER storage accesses done by `proposal` (`threshold < 2`)"] # [doc = "    - OR proposal insertion (`threshold <= 2`)"] # [doc = "      - 1 storage mutation `Proposals` (codec `O(P2)`)"] # [doc = "      - 1 storage mutation `ProposalCount` (codec `O(1)`)"] # [doc = "      - 1 storage write `ProposalOf` (codec `O(B)`)"] # [doc = "      - 1 storage write `Voting` (codec `O(M)`)"] # [doc = "  - 1 event"] # [doc = "# </weight>"] pub fn propose (& self , threshold : :: core :: primitive :: u32 , proposal : runtime_types :: alphanet_runtime :: RuntimeCall , length_bound : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < Propose > { :: subxt :: tx :: StaticTxPayload :: new ("TechnicalCommittee" , "propose" , Propose { threshold , proposal : :: std :: boxed :: Box :: new (proposal) , length_bound , } , [76u8 , 50u8 , 117u8 , 51u8 , 222u8 , 83u8 , 59u8 , 233u8 , 101u8 , 39u8 , 42u8 , 103u8 , 123u8 , 21u8 , 161u8 , 94u8 , 212u8 , 221u8 , 96u8 , 30u8 , 171u8 , 229u8 , 161u8 , 218u8 , 60u8 , 99u8 , 170u8 , 204u8 , 36u8 , 125u8 , 199u8 , 160u8 ,]) } # [doc = "Add an aye or nay vote for the sender to the given proposal."] # [doc = ""] # [doc = "Requires the sender to be a member."] # [doc = ""] # [doc = "Transaction fees will be waived if the member is voting on any particular proposal"] # [doc = "for the first time and the call is successful. Subsequent vote changes will charge a"] # [doc = "fee."] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(M)` where `M` is members-count (code- and governance-bounded)"] # [doc = "- DB:"] # [doc = "  - 1 storage read `Members` (codec `O(M)`)"] # [doc = "  - 1 storage mutation `Voting` (codec `O(M)`)"] # [doc = "- 1 event"] # [doc = "# </weight>"] pub fn vote (& self , proposal : :: subxt :: ext :: sp_core :: H256 , index : :: core :: primitive :: u32 , approve : :: core :: primitive :: bool ,) -> :: subxt :: tx :: StaticTxPayload < Vote > { :: subxt :: tx :: StaticTxPayload :: new ("TechnicalCommittee" , "vote" , Vote { proposal , index , approve , } , [108u8 , 46u8 , 180u8 , 148u8 , 145u8 , 24u8 , 173u8 , 56u8 , 36u8 , 100u8 , 216u8 , 43u8 , 178u8 , 202u8 , 26u8 , 136u8 , 93u8 , 84u8 , 80u8 , 134u8 , 14u8 , 42u8 , 248u8 , 205u8 , 68u8 , 92u8 , 79u8 , 11u8 , 113u8 , 115u8 , 157u8 , 100u8 ,]) } # [doc = "Close a vote that is either approved, disapproved or whose voting period has ended."] # [doc = ""] # [doc = "May be called by any signed account in order to finish voting and close the proposal."] # [doc = ""] # [doc = "If called before the end of the voting period it will only close the vote if it is"] # [doc = "has enough votes to be approved or disapproved."] # [doc = ""] # [doc = "If called after the end of the voting period abstentions are counted as rejections"] # [doc = "unless there is a prime member set and the prime member cast an approval."] # [doc = ""] # [doc = "If the close operation completes successfully with disapproval, the transaction fee will"] # [doc = "be waived. Otherwise execution of the approved operation will be charged to the caller."] # [doc = ""] # [doc = "+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed"] # [doc = "proposal."] # [doc = "+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via"] # [doc = "`storage::read` so it is `size_of::<u32>() == 4` larger than the pure length."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(B + M + P1 + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - `P1` is the complexity of `proposal` preimage."] # [doc = "  - `P2` is proposal-count (code-bounded)"] # [doc = "- DB:"] # [doc = " - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)"] # [doc = " - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec"] # [doc = "   `O(P2)`)"] # [doc = " - any mutations done while executing `proposal` (`P1`)"] # [doc = "- up to 3 events"] # [doc = "# </weight>"] pub fn close_old_weight (& self , proposal_hash : :: subxt :: ext :: sp_core :: H256 , index : :: core :: primitive :: u32 , proposal_weight_bound : runtime_types :: sp_weights :: OldWeight , length_bound : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < CloseOldWeight > { :: subxt :: tx :: StaticTxPayload :: new ("TechnicalCommittee" , "close_old_weight" , CloseOldWeight { proposal_hash , index , proposal_weight_bound , length_bound , } , [133u8 , 219u8 , 90u8 , 40u8 , 102u8 , 95u8 , 4u8 , 199u8 , 45u8 , 234u8 , 109u8 , 17u8 , 162u8 , 63u8 , 102u8 , 186u8 , 95u8 , 182u8 , 13u8 , 123u8 , 227u8 , 20u8 , 186u8 , 207u8 , 12u8 , 47u8 , 87u8 , 252u8 , 244u8 , 172u8 , 60u8 , 206u8 ,]) } # [doc = "Disapprove a proposal, close, and remove it from the system, regardless of its current"] # [doc = "state."] # [doc = ""] # [doc = "Must be called by the Root origin."] # [doc = ""] # [doc = "Parameters:"] # [doc = "* `proposal_hash`: The hash of the proposal that should be disapproved."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Complexity: O(P) where P is the number of max proposals"] # [doc = "DB Weight:"] # [doc = "* Reads: Proposals"] # [doc = "* Writes: Voting, Proposals, ProposalOf"] # [doc = "# </weight>"] pub fn disapprove_proposal (& self , proposal_hash : :: subxt :: ext :: sp_core :: H256 ,) -> :: subxt :: tx :: StaticTxPayload < DisapproveProposal > { :: subxt :: tx :: StaticTxPayload :: new ("TechnicalCommittee" , "disapprove_proposal" , DisapproveProposal { proposal_hash , } , [25u8 , 123u8 , 1u8 , 8u8 , 74u8 , 37u8 , 3u8 , 40u8 , 97u8 , 37u8 , 175u8 , 224u8 , 72u8 , 155u8 , 123u8 , 109u8 , 104u8 , 43u8 , 91u8 , 125u8 , 199u8 , 51u8 , 17u8 , 225u8 , 133u8 , 38u8 , 120u8 , 76u8 , 164u8 , 5u8 , 194u8 , 201u8 ,]) } # [doc = "Close a vote that is either approved, disapproved or whose voting period has ended."] # [doc = ""] # [doc = "May be called by any signed account in order to finish voting and close the proposal."] # [doc = ""] # [doc = "If called before the end of the voting period it will only close the vote if it is"] # [doc = "has enough votes to be approved or disapproved."] # [doc = ""] # [doc = "If called after the end of the voting period abstentions are counted as rejections"] # [doc = "unless there is a prime member set and the prime member cast an approval."] # [doc = ""] # [doc = "If the close operation completes successfully with disapproval, the transaction fee will"] # [doc = "be waived. Otherwise execution of the approved operation will be charged to the caller."] # [doc = ""] # [doc = "+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed"] # [doc = "proposal."] # [doc = "+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via"] # [doc = "`storage::read` so it is `size_of::<u32>() == 4` larger than the pure length."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(B + M + P1 + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - `P1` is the complexity of `proposal` preimage."] # [doc = "  - `P2` is proposal-count (code-bounded)"] # [doc = "- DB:"] # [doc = " - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)"] # [doc = " - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec"] # [doc = "   `O(P2)`)"] # [doc = " - any mutations done while executing `proposal` (`P1`)"] # [doc = "- up to 3 events"] # [doc = "# </weight>"] pub fn close (& self , proposal_hash : :: subxt :: ext :: sp_core :: H256 , index : :: core :: primitive :: u32 , proposal_weight_bound : runtime_types :: sp_weights :: weight_v2 :: Weight , length_bound : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < Close > { :: subxt :: tx :: StaticTxPayload :: new ("TechnicalCommittee" , "close" , Close { proposal_hash , index , proposal_weight_bound , length_bound , } , [191u8 , 138u8 , 89u8 , 247u8 , 97u8 , 51u8 , 45u8 , 193u8 , 76u8 , 16u8 , 80u8 , 225u8 , 197u8 , 83u8 , 204u8 , 133u8 , 169u8 , 16u8 , 86u8 , 32u8 , 125u8 , 16u8 , 116u8 , 185u8 , 45u8 , 20u8 , 76u8 , 148u8 , 206u8 , 163u8 , 154u8 , 30u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_collective :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A motion (given hash) has been proposed (by given account) with a threshold (given"] # [doc = "`MemberCount`)."] pub struct Proposed { pub account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub proposal_index : :: core :: primitive :: u32 , pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub threshold : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for Proposed { const PALLET : & 'static str = "TechnicalCommittee" ; const EVENT : & 'static str = "Proposed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A motion (given hash) has been voted on by given account, leaving"] # [doc = "a tally (yes votes and no votes given respectively as `MemberCount`)."] pub struct Voted { pub account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub voted : :: core :: primitive :: bool , pub yes : :: core :: primitive :: u32 , pub no : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for Voted { const PALLET : & 'static str = "TechnicalCommittee" ; const EVENT : & 'static str = "Voted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A motion was approved by the required threshold."] pub struct Approved { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , } impl :: subxt :: events :: StaticEvent for Approved { const PALLET : & 'static str = "TechnicalCommittee" ; const EVENT : & 'static str = "Approved" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A motion was not approved by the required threshold."] pub struct Disapproved { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , } impl :: subxt :: events :: StaticEvent for Disapproved { const PALLET : & 'static str = "TechnicalCommittee" ; const EVENT : & 'static str = "Disapproved" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A motion was executed; result will be `Ok` if it returned without error."] pub struct Executed { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: events :: StaticEvent for Executed { const PALLET : & 'static str = "TechnicalCommittee" ; const EVENT : & 'static str = "Executed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A single member did some action; result will be `Ok` if it returned without error."] pub struct MemberExecuted { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: events :: StaticEvent for MemberExecuted { const PALLET : & 'static str = "TechnicalCommittee" ; const EVENT : & 'static str = "MemberExecuted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A proposal was closed because its threshold was reached or after its duration was up."] pub struct Closed { pub proposal_hash : :: subxt :: ext :: sp_core :: H256 , pub yes : :: core :: primitive :: u32 , pub no : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for Closed { const PALLET : & 'static str = "TechnicalCommittee" ; const EVENT : & 'static str = "Closed" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The hashes of the active proposals."] pub fn proposals (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: H256 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("TechnicalCommittee" , "Proposals" , vec ! [] , [10u8 , 133u8 , 82u8 , 54u8 , 193u8 , 41u8 , 253u8 , 159u8 , 56u8 , 96u8 , 249u8 , 148u8 , 43u8 , 57u8 , 116u8 , 43u8 , 222u8 , 243u8 , 237u8 , 231u8 , 238u8 , 60u8 , 26u8 , 225u8 , 19u8 , 203u8 , 213u8 , 220u8 , 114u8 , 217u8 , 100u8 , 27u8 ,]) } # [doc = " Actual proposal for a given hash, if it's current."] pub fn proposal_of (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: H256 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: alphanet_runtime :: RuntimeCall > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("TechnicalCommittee" , "ProposalOf" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Identity)] , [15u8 , 119u8 , 175u8 , 217u8 , 237u8 , 54u8 , 145u8 , 17u8 , 212u8 , 19u8 , 132u8 , 33u8 , 132u8 , 90u8 , 180u8 , 4u8 , 106u8 , 161u8 , 215u8 , 188u8 , 220u8 , 208u8 , 70u8 , 212u8 , 29u8 , 129u8 , 95u8 , 203u8 , 225u8 , 161u8 , 125u8 , 32u8 ,]) } # [doc = " Actual proposal for a given hash, if it's current."] pub fn proposal_of_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: alphanet_runtime :: RuntimeCall > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("TechnicalCommittee" , "ProposalOf" , Vec :: new () , [15u8 , 119u8 , 175u8 , 217u8 , 237u8 , 54u8 , 145u8 , 17u8 , 212u8 , 19u8 , 132u8 , 33u8 , 132u8 , 90u8 , 180u8 , 4u8 , 106u8 , 161u8 , 215u8 , 188u8 , 220u8 , 208u8 , 70u8 , 212u8 , 29u8 , 129u8 , 95u8 , 203u8 , 225u8 , 161u8 , 125u8 , 32u8 ,]) } # [doc = " Votes on a given proposal, if it is ongoing."] pub fn voting (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: H256 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_collective :: Votes < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("TechnicalCommittee" , "Voting" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Identity)] , [89u8 , 108u8 , 65u8 , 58u8 , 60u8 , 116u8 , 54u8 , 68u8 , 179u8 , 73u8 , 161u8 , 168u8 , 78u8 , 213u8 , 208u8 , 54u8 , 244u8 , 58u8 , 70u8 , 209u8 , 170u8 , 136u8 , 215u8 , 3u8 , 2u8 , 105u8 , 229u8 , 217u8 , 240u8 , 230u8 , 107u8 , 221u8 ,]) } # [doc = " Votes on a given proposal, if it is ongoing."] pub fn voting_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_collective :: Votes < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("TechnicalCommittee" , "Voting" , Vec :: new () , [89u8 , 108u8 , 65u8 , 58u8 , 60u8 , 116u8 , 54u8 , 68u8 , 179u8 , 73u8 , 161u8 , 168u8 , 78u8 , 213u8 , 208u8 , 54u8 , 244u8 , 58u8 , 70u8 , 209u8 , 170u8 , 136u8 , 215u8 , 3u8 , 2u8 , 105u8 , 229u8 , 217u8 , 240u8 , 230u8 , 107u8 , 221u8 ,]) } # [doc = " Proposals so far."] pub fn proposal_count (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("TechnicalCommittee" , "ProposalCount" , vec ! [] , [132u8 , 145u8 , 78u8 , 218u8 , 51u8 , 189u8 , 55u8 , 172u8 , 143u8 , 33u8 , 140u8 , 99u8 , 124u8 , 208u8 , 57u8 , 232u8 , 154u8 , 110u8 , 32u8 , 142u8 , 24u8 , 149u8 , 109u8 , 105u8 , 30u8 , 83u8 , 39u8 , 177u8 , 127u8 , 160u8 , 34u8 , 70u8 ,]) } # [doc = " The current members of the collective. This is stored sorted (just by value)."] pub fn members (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("TechnicalCommittee" , "Members" , vec ! [] , [162u8 , 72u8 , 174u8 , 204u8 , 140u8 , 105u8 , 205u8 , 176u8 , 197u8 , 117u8 , 206u8 , 134u8 , 157u8 , 110u8 , 139u8 , 54u8 , 43u8 , 233u8 , 25u8 , 51u8 , 36u8 , 238u8 , 94u8 , 124u8 , 221u8 , 52u8 , 237u8 , 71u8 , 125u8 , 56u8 , 129u8 , 222u8 ,]) } # [doc = " The prime member that helps determine the default vote behavior in case of absentations."] pub fn prime (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("TechnicalCommittee" , "Prime" , vec ! [] , [108u8 , 118u8 , 54u8 , 193u8 , 207u8 , 227u8 , 119u8 , 97u8 , 23u8 , 239u8 , 157u8 , 69u8 , 56u8 , 142u8 , 106u8 , 17u8 , 215u8 , 159u8 , 48u8 , 42u8 , 185u8 , 209u8 , 49u8 , 159u8 , 32u8 , 168u8 , 111u8 , 158u8 , 159u8 , 217u8 , 244u8 , 158u8 ,]) } } } } pub mod technical_membership { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AddMember { pub who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RemoveMember { pub who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SwapMember { pub remove : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub add : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ResetMembers { pub members : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ChangeKey { pub new : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetPrime { pub who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ClearPrime ; pub struct TransactionApi ; impl TransactionApi { # [doc = "Add a member `who` to the set."] # [doc = ""] # [doc = "May only be called from `T::AddOrigin`."] pub fn add_member (& self , who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < AddMember > { :: subxt :: tx :: StaticTxPayload :: new ("TechnicalMembership" , "add_member" , AddMember { who , } , [165u8 , 116u8 , 123u8 , 50u8 , 236u8 , 196u8 , 108u8 , 211u8 , 112u8 , 214u8 , 121u8 , 105u8 , 7u8 , 88u8 , 125u8 , 99u8 , 24u8 , 0u8 , 168u8 , 65u8 , 158u8 , 100u8 , 42u8 , 62u8 , 101u8 , 59u8 , 30u8 , 174u8 , 170u8 , 119u8 , 141u8 , 121u8 ,]) } # [doc = "Remove a member `who` from the set."] # [doc = ""] # [doc = "May only be called from `T::RemoveOrigin`."] pub fn remove_member (& self , who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < RemoveMember > { :: subxt :: tx :: StaticTxPayload :: new ("TechnicalMembership" , "remove_member" , RemoveMember { who , } , [177u8 , 18u8 , 217u8 , 235u8 , 254u8 , 40u8 , 137u8 , 79u8 , 146u8 , 5u8 , 55u8 , 187u8 , 129u8 , 28u8 , 54u8 , 132u8 , 115u8 , 220u8 , 132u8 , 139u8 , 91u8 , 81u8 , 0u8 , 110u8 , 188u8 , 248u8 , 1u8 , 135u8 , 93u8 , 153u8 , 95u8 , 193u8 ,]) } # [doc = "Swap out one member `remove` for another `add`."] # [doc = ""] # [doc = "May only be called from `T::SwapOrigin`."] # [doc = ""] # [doc = "Prime membership is *not* passed from `remove` to `add`, if extant."] pub fn swap_member (& self , remove : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , add : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < SwapMember > { :: subxt :: tx :: StaticTxPayload :: new ("TechnicalMembership" , "swap_member" , SwapMember { remove , add , } , [96u8 , 248u8 , 50u8 , 206u8 , 192u8 , 242u8 , 162u8 , 62u8 , 28u8 , 91u8 , 11u8 , 208u8 , 15u8 , 84u8 , 188u8 , 234u8 , 219u8 , 233u8 , 200u8 , 215u8 , 157u8 , 155u8 , 40u8 , 220u8 , 132u8 , 182u8 , 57u8 , 210u8 , 94u8 , 240u8 , 95u8 , 252u8 ,]) } # [doc = "Change the membership to a new set, disregarding the existing membership. Be nice and"] # [doc = "pass `members` pre-sorted."] # [doc = ""] # [doc = "May only be called from `T::ResetOrigin`."] pub fn reset_members (& self , members : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: tx :: StaticTxPayload < ResetMembers > { :: subxt :: tx :: StaticTxPayload :: new ("TechnicalMembership" , "reset_members" , ResetMembers { members , } , [9u8 , 35u8 , 28u8 , 59u8 , 158u8 , 232u8 , 89u8 , 78u8 , 101u8 , 53u8 , 240u8 , 98u8 , 13u8 , 104u8 , 235u8 , 161u8 , 201u8 , 150u8 , 117u8 , 32u8 , 75u8 , 209u8 , 166u8 , 252u8 , 57u8 , 131u8 , 96u8 , 215u8 , 51u8 , 81u8 , 42u8 , 123u8 ,]) } # [doc = "Swap out the sending member for some other key `new`."] # [doc = ""] # [doc = "May only be called from `Signed` origin of a current member."] # [doc = ""] # [doc = "Prime membership is passed from the origin account to `new`, if extant."] pub fn change_key (& self , new : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < ChangeKey > { :: subxt :: tx :: StaticTxPayload :: new ("TechnicalMembership" , "change_key" , ChangeKey { new , } , [27u8 , 236u8 , 241u8 , 168u8 , 98u8 , 39u8 , 176u8 , 220u8 , 145u8 , 48u8 , 173u8 , 25u8 , 179u8 , 103u8 , 170u8 , 13u8 , 166u8 , 181u8 , 131u8 , 160u8 , 131u8 , 219u8 , 116u8 , 34u8 , 152u8 , 152u8 , 46u8 , 100u8 , 46u8 , 5u8 , 156u8 , 195u8 ,]) } # [doc = "Set the prime member. Must be a current member."] # [doc = ""] # [doc = "May only be called from `T::PrimeOrigin`."] pub fn set_prime (& self , who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < SetPrime > { :: subxt :: tx :: StaticTxPayload :: new ("TechnicalMembership" , "set_prime" , SetPrime { who , } , [0u8 , 42u8 , 111u8 , 52u8 , 151u8 , 19u8 , 239u8 , 149u8 , 183u8 , 252u8 , 87u8 , 194u8 , 145u8 , 21u8 , 245u8 , 112u8 , 221u8 , 181u8 , 87u8 , 28u8 , 48u8 , 39u8 , 210u8 , 133u8 , 241u8 , 207u8 , 255u8 , 209u8 , 139u8 , 232u8 , 119u8 , 64u8 ,]) } # [doc = "Remove the prime member if it exists."] # [doc = ""] # [doc = "May only be called from `T::PrimeOrigin`."] pub fn clear_prime (& self ,) -> :: subxt :: tx :: StaticTxPayload < ClearPrime > { :: subxt :: tx :: StaticTxPayload :: new ("TechnicalMembership" , "clear_prime" , ClearPrime { } , [186u8 , 182u8 , 225u8 , 90u8 , 71u8 , 124u8 , 69u8 , 100u8 , 234u8 , 25u8 , 53u8 , 23u8 , 182u8 , 32u8 , 176u8 , 81u8 , 54u8 , 140u8 , 235u8 , 126u8 , 247u8 , 7u8 , 155u8 , 62u8 , 35u8 , 135u8 , 48u8 , 61u8 , 88u8 , 160u8 , 183u8 , 72u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_membership :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "The given member was added; see the transaction for who."] pub struct MemberAdded ; impl :: subxt :: events :: StaticEvent for MemberAdded { const PALLET : & 'static str = "TechnicalMembership" ; const EVENT : & 'static str = "MemberAdded" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "The given member was removed; see the transaction for who."] pub struct MemberRemoved ; impl :: subxt :: events :: StaticEvent for MemberRemoved { const PALLET : & 'static str = "TechnicalMembership" ; const EVENT : & 'static str = "MemberRemoved" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Two members were swapped; see the transaction for who."] pub struct MembersSwapped ; impl :: subxt :: events :: StaticEvent for MembersSwapped { const PALLET : & 'static str = "TechnicalMembership" ; const EVENT : & 'static str = "MembersSwapped" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "The membership was reset; see the transaction for who the new set is."] pub struct MembersReset ; impl :: subxt :: events :: StaticEvent for MembersReset { const PALLET : & 'static str = "TechnicalMembership" ; const EVENT : & 'static str = "MembersReset" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "One of the members' keys changed."] pub struct KeyChanged ; impl :: subxt :: events :: StaticEvent for KeyChanged { const PALLET : & 'static str = "TechnicalMembership" ; const EVENT : & 'static str = "KeyChanged" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Phantom member, never used."] pub struct Dummy ; impl :: subxt :: events :: StaticEvent for Dummy { const PALLET : & 'static str = "TechnicalMembership" ; const EVENT : & 'static str = "Dummy" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The current membership, stored as an ordered Vec."] pub fn members (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("TechnicalMembership" , "Members" , vec ! [] , [56u8 , 56u8 , 29u8 , 90u8 , 26u8 , 115u8 , 252u8 , 185u8 , 37u8 , 108u8 , 16u8 , 46u8 , 136u8 , 139u8 , 30u8 , 19u8 , 235u8 , 78u8 , 176u8 , 129u8 , 180u8 , 57u8 , 178u8 , 239u8 , 211u8 , 6u8 , 64u8 , 129u8 , 195u8 , 46u8 , 178u8 , 157u8 ,]) } # [doc = " The current prime member, if one exists."] pub fn prime (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("TechnicalMembership" , "Prime" , vec ! [] , [108u8 , 118u8 , 54u8 , 193u8 , 207u8 , 227u8 , 119u8 , 97u8 , 23u8 , 239u8 , 157u8 , 69u8 , 56u8 , 142u8 , 106u8 , 17u8 , 215u8 , 159u8 , 48u8 , 42u8 , 185u8 , 209u8 , 49u8 , 159u8 , 32u8 , 168u8 , 111u8 , 158u8 , 159u8 , 217u8 , 244u8 , 158u8 ,]) } } } } pub mod mandate { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Mandate { pub call : :: std :: boxed :: Box < runtime_types :: alphanet_runtime :: RuntimeCall > , } pub struct TransactionApi ; impl TransactionApi { pub fn mandate (& self , call : runtime_types :: alphanet_runtime :: RuntimeCall ,) -> :: subxt :: tx :: StaticTxPayload < Mandate > { :: subxt :: tx :: StaticTxPayload :: new ("Mandate" , "mandate" , Mandate { call : :: std :: boxed :: Box :: new (call) , } , [46u8 , 144u8 , 45u8 , 191u8 , 249u8 , 163u8 , 61u8 , 101u8 , 89u8 , 9u8 , 179u8 , 19u8 , 97u8 , 142u8 , 167u8 , 84u8 , 102u8 , 19u8 , 64u8 , 72u8 , 183u8 , 7u8 , 211u8 , 138u8 , 164u8 , 105u8 , 244u8 , 126u8 , 217u8 , 126u8 , 4u8 , 57u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: ternoa_mandate :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A root operation was executed, show result"] pub struct RootOp { pub result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: events :: StaticEvent for RootOp { const PALLET : & 'static str = "Mandate" ; const EVENT : & 'static str = "RootOp" ; } } } pub mod treasury { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ProposeSpend { # [codec (compact)] pub value : :: core :: primitive :: u128 , pub beneficiary : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RejectProposal { # [codec (compact)] pub proposal_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ApproveProposal { # [codec (compact)] pub proposal_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Spend { # [codec (compact)] pub amount : :: core :: primitive :: u128 , pub beneficiary : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RemoveApproval { # [codec (compact)] pub proposal_id : :: core :: primitive :: u32 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Put forward a suggestion for spending. A deposit proportional to the value"] # [doc = "is reserved and slashed if the proposal is rejected. It is returned once the"] # [doc = "proposal is awarded."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(1)"] # [doc = "- DbReads: `ProposalCount`, `origin account`"] # [doc = "- DbWrites: `ProposalCount`, `Proposals`, `origin account`"] # [doc = "# </weight>"] pub fn propose_spend (& self , value : :: core :: primitive :: u128 , beneficiary : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < ProposeSpend > { :: subxt :: tx :: StaticTxPayload :: new ("Treasury" , "propose_spend" , ProposeSpend { value , beneficiary , } , [109u8 , 46u8 , 8u8 , 159u8 , 127u8 , 79u8 , 27u8 , 100u8 , 92u8 , 244u8 , 78u8 , 46u8 , 105u8 , 246u8 , 169u8 , 210u8 , 149u8 , 7u8 , 108u8 , 153u8 , 203u8 , 223u8 , 8u8 , 117u8 , 126u8 , 250u8 , 255u8 , 52u8 , 245u8 , 69u8 , 45u8 , 136u8 ,]) } # [doc = "Reject a proposed spend. The original deposit will be slashed."] # [doc = ""] # [doc = "May only be called from `T::RejectOrigin`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(1)"] # [doc = "- DbReads: `Proposals`, `rejected proposer account`"] # [doc = "- DbWrites: `Proposals`, `rejected proposer account`"] # [doc = "# </weight>"] pub fn reject_proposal (& self , proposal_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < RejectProposal > { :: subxt :: tx :: StaticTxPayload :: new ("Treasury" , "reject_proposal" , RejectProposal { proposal_id , } , [106u8 , 223u8 , 97u8 , 22u8 , 111u8 , 208u8 , 128u8 , 26u8 , 198u8 , 140u8 , 118u8 , 126u8 , 187u8 , 51u8 , 193u8 , 50u8 , 193u8 , 68u8 , 143u8 , 144u8 , 34u8 , 132u8 , 44u8 , 244u8 , 105u8 , 186u8 , 223u8 , 234u8 , 17u8 , 145u8 , 209u8 , 145u8 ,]) } # [doc = "Approve a proposal. At a later time, the proposal will be allocated to the beneficiary"] # [doc = "and the original deposit will be returned."] # [doc = ""] # [doc = "May only be called from `T::ApproveOrigin`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(1)."] # [doc = "- DbReads: `Proposals`, `Approvals`"] # [doc = "- DbWrite: `Approvals`"] # [doc = "# </weight>"] pub fn approve_proposal (& self , proposal_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < ApproveProposal > { :: subxt :: tx :: StaticTxPayload :: new ("Treasury" , "approve_proposal" , ApproveProposal { proposal_id , } , [164u8 , 229u8 , 172u8 , 98u8 , 129u8 , 62u8 , 84u8 , 128u8 , 47u8 , 108u8 , 33u8 , 120u8 , 89u8 , 79u8 , 57u8 , 121u8 , 4u8 , 197u8 , 170u8 , 153u8 , 156u8 , 17u8 , 59u8 , 164u8 , 123u8 , 227u8 , 175u8 , 195u8 , 220u8 , 160u8 , 60u8 , 186u8 ,]) } # [doc = "Propose and approve a spend of treasury funds."] # [doc = ""] # [doc = "- `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`."] # [doc = "- `amount`: The amount to be transferred from the treasury to the `beneficiary`."] # [doc = "- `beneficiary`: The destination account for the transfer."] # [doc = ""] # [doc = "NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the"] # [doc = "beneficiary."] pub fn spend (& self , amount : :: core :: primitive :: u128 , beneficiary : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < Spend > { :: subxt :: tx :: StaticTxPayload :: new ("Treasury" , "spend" , Spend { amount , beneficiary , } , [177u8 , 178u8 , 242u8 , 136u8 , 135u8 , 237u8 , 114u8 , 71u8 , 233u8 , 239u8 , 7u8 , 84u8 , 14u8 , 228u8 , 58u8 , 31u8 , 158u8 , 185u8 , 25u8 , 91u8 , 70u8 , 33u8 , 19u8 , 92u8 , 100u8 , 162u8 , 5u8 , 48u8 , 20u8 , 120u8 , 9u8 , 109u8 ,]) } # [doc = "Force a previously approved proposal to be removed from the approval queue."] # [doc = "The original deposit will no longer be returned."] # [doc = ""] # [doc = "May only be called from `T::RejectOrigin`."] # [doc = "- `proposal_id`: The index of a proposal"] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(A) where `A` is the number of approvals"] # [doc = "- Db reads and writes: `Approvals`"] # [doc = "# </weight>"] # [doc = ""] # [doc = "Errors:"] # [doc = "- `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,"] # [doc = "i.e., the proposal has not been approved. This could also mean the proposal does not"] # [doc = "exist altogether, thus there is no way it would have been approved in the first place."] pub fn remove_approval (& self , proposal_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < RemoveApproval > { :: subxt :: tx :: StaticTxPayload :: new ("Treasury" , "remove_approval" , RemoveApproval { proposal_id , } , [133u8 , 126u8 , 181u8 , 47u8 , 196u8 , 243u8 , 7u8 , 46u8 , 25u8 , 251u8 , 154u8 , 125u8 , 217u8 , 77u8 , 54u8 , 245u8 , 240u8 , 180u8 , 97u8 , 34u8 , 186u8 , 53u8 , 225u8 , 144u8 , 155u8 , 107u8 , 172u8 , 54u8 , 250u8 , 184u8 , 178u8 , 86u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_treasury :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "New proposal."] pub struct Proposed { pub proposal_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for Proposed { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Proposed" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "We have ended a spend period and will now allocate funds."] pub struct Spending { pub budget_remaining : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Spending { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Spending" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some funds have been allocated."] pub struct Awarded { pub proposal_index : :: core :: primitive :: u32 , pub award : :: core :: primitive :: u128 , pub account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for Awarded { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Awarded" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A proposal was rejected; funds were slashed."] pub struct Rejected { pub proposal_index : :: core :: primitive :: u32 , pub slashed : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Rejected { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Rejected" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some of our funds have been burnt."] pub struct Burnt { pub burnt_funds : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Burnt { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Burnt" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Spending has finished; this is the amount that rolls over until next spend."] pub struct Rollover { pub rollover_balance : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Rollover { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Rollover" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some funds have been deposited."] pub struct Deposit { pub value : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Deposit { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Deposit" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A new spend proposal has been approved."] pub struct SpendApproved { pub proposal_index : :: core :: primitive :: u32 , pub amount : :: core :: primitive :: u128 , pub beneficiary : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for SpendApproved { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "SpendApproved" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Number of proposals that have been made."] pub fn proposal_count (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Treasury" , "ProposalCount" , vec ! [] , [132u8 , 145u8 , 78u8 , 218u8 , 51u8 , 189u8 , 55u8 , 172u8 , 143u8 , 33u8 , 140u8 , 99u8 , 124u8 , 208u8 , 57u8 , 232u8 , 154u8 , 110u8 , 32u8 , 142u8 , 24u8 , 149u8 , 109u8 , 105u8 , 30u8 , 83u8 , 39u8 , 177u8 , 127u8 , 160u8 , 34u8 , 70u8 ,]) } # [doc = " Proposals that have been made."] pub fn proposals (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_treasury :: Proposal < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Treasury" , "Proposals" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [62u8 , 223u8 , 55u8 , 209u8 , 151u8 , 134u8 , 122u8 , 65u8 , 207u8 , 38u8 , 113u8 , 213u8 , 237u8 , 48u8 , 129u8 , 32u8 , 91u8 , 228u8 , 108u8 , 91u8 , 37u8 , 49u8 , 94u8 , 4u8 , 75u8 , 122u8 , 25u8 , 34u8 , 198u8 , 224u8 , 246u8 , 160u8 ,]) } # [doc = " Proposals that have been made."] pub fn proposals_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_treasury :: Proposal < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Treasury" , "Proposals" , Vec :: new () , [62u8 , 223u8 , 55u8 , 209u8 , 151u8 , 134u8 , 122u8 , 65u8 , 207u8 , 38u8 , 113u8 , 213u8 , 237u8 , 48u8 , 129u8 , 32u8 , 91u8 , 228u8 , 108u8 , 91u8 , 37u8 , 49u8 , 94u8 , 4u8 , 75u8 , 122u8 , 25u8 , 34u8 , 198u8 , 224u8 , 246u8 , 160u8 ,]) } # [doc = " Proposal indices that have been approved but not yet awarded."] pub fn approvals (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Treasury" , "Approvals" , vec ! [] , [202u8 , 106u8 , 189u8 , 40u8 , 127u8 , 172u8 , 108u8 , 50u8 , 193u8 , 4u8 , 248u8 , 226u8 , 176u8 , 101u8 , 212u8 , 222u8 , 64u8 , 206u8 , 244u8 , 175u8 , 111u8 , 106u8 , 86u8 , 96u8 , 19u8 , 109u8 , 218u8 , 152u8 , 30u8 , 59u8 , 96u8 , 1u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Fraction of a proposal's value that should be bonded in order to place the proposal."] # [doc = " An accepted proposal gets these back. A rejected proposal does not."] pub fn proposal_bond (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_arithmetic :: per_things :: Permill >> { :: subxt :: constants :: StaticConstantAddress :: new ("Treasury" , "ProposalBond" , [225u8 , 236u8 , 95u8 , 157u8 , 90u8 , 94u8 , 106u8 , 192u8 , 254u8 , 19u8 , 87u8 , 80u8 , 16u8 , 62u8 , 42u8 , 204u8 , 136u8 , 106u8 , 225u8 , 53u8 , 212u8 , 52u8 , 177u8 , 79u8 , 4u8 , 116u8 , 201u8 , 104u8 , 222u8 , 75u8 , 86u8 , 227u8 ,]) } # [doc = " Minimum amount of funds that should be placed in a deposit for making a proposal."] pub fn proposal_bond_minimum (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Treasury" , "ProposalBondMinimum" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " Maximum amount of funds that should be placed in a deposit for making a proposal."] pub fn proposal_bond_maximum (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: option :: Option < :: core :: primitive :: u128 > >> { :: subxt :: constants :: StaticConstantAddress :: new ("Treasury" , "ProposalBondMaximum" , [84u8 , 154u8 , 218u8 , 83u8 , 84u8 , 189u8 , 32u8 , 20u8 , 120u8 , 194u8 , 88u8 , 205u8 , 109u8 , 216u8 , 114u8 , 193u8 , 120u8 , 198u8 , 154u8 , 237u8 , 134u8 , 204u8 , 102u8 , 247u8 , 52u8 , 103u8 , 231u8 , 43u8 , 243u8 , 122u8 , 60u8 , 216u8 ,]) } # [doc = " Period between successive spends."] pub fn spend_period (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Treasury" , "SpendPeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Percentage of spare funds (if any) that are burnt per spend period."] pub fn burn (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_arithmetic :: per_things :: Permill >> { :: subxt :: constants :: StaticConstantAddress :: new ("Treasury" , "Burn" , [225u8 , 236u8 , 95u8 , 157u8 , 90u8 , 94u8 , 106u8 , 192u8 , 254u8 , 19u8 , 87u8 , 80u8 , 16u8 , 62u8 , 42u8 , 204u8 , 136u8 , 106u8 , 225u8 , 53u8 , 212u8 , 52u8 , 177u8 , 79u8 , 4u8 , 116u8 , 201u8 , 104u8 , 222u8 , 75u8 , 86u8 , 227u8 ,]) } # [doc = " The treasury's pallet id, used for deriving its sovereign account ID."] pub fn pallet_id (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < runtime_types :: frame_support :: PalletId >> { :: subxt :: constants :: StaticConstantAddress :: new ("Treasury" , "PalletId" , [139u8 , 109u8 , 228u8 , 151u8 , 252u8 , 32u8 , 130u8 , 69u8 , 112u8 , 154u8 , 174u8 , 45u8 , 83u8 , 245u8 , 51u8 , 132u8 , 173u8 , 5u8 , 186u8 , 24u8 , 243u8 , 9u8 , 12u8 , 214u8 , 80u8 , 74u8 , 69u8 , 189u8 , 30u8 , 94u8 , 22u8 , 39u8 ,]) } # [doc = " The maximum number of approvals that can wait in the spending queue."] # [doc = ""] # [doc = " NOTE: This parameter is also used within the Bounties Pallet extension if enabled."] pub fn max_approvals (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Treasury" , "MaxApprovals" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod utility { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Batch { pub calls : :: std :: vec :: Vec < runtime_types :: alphanet_runtime :: RuntimeCall > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AsDerivative { pub index : :: core :: primitive :: u16 , pub call : :: std :: boxed :: Box < runtime_types :: alphanet_runtime :: RuntimeCall > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct BatchAll { pub calls : :: std :: vec :: Vec < runtime_types :: alphanet_runtime :: RuntimeCall > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct DispatchAs { pub as_origin : :: std :: boxed :: Box < runtime_types :: alphanet_runtime :: OriginCaller > , pub call : :: std :: boxed :: Box < runtime_types :: alphanet_runtime :: RuntimeCall > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ForceBatch { pub calls : :: std :: vec :: Vec < runtime_types :: alphanet_runtime :: RuntimeCall > , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Send a batch of dispatch calls."] # [doc = ""] # [doc = "May be called from any origin."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then call are dispatch without checking origin filter. (This includes"] # [doc = "bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(C) where C is the number of calls to be batched."] # [doc = "# </weight>"] # [doc = ""] # [doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"] # [doc = "event is deposited. If a call failed and the batch was interrupted, then the"] # [doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"] # [doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"] # [doc = "event is deposited."] pub fn batch (& self , calls : :: std :: vec :: Vec < runtime_types :: alphanet_runtime :: RuntimeCall > ,) -> :: subxt :: tx :: StaticTxPayload < Batch > { :: subxt :: tx :: StaticTxPayload :: new ("Utility" , "batch" , Batch { calls , } , [238u8 , 116u8 , 0u8 , 94u8 , 192u8 , 64u8 , 57u8 , 104u8 , 3u8 , 86u8 , 142u8 , 107u8 , 97u8 , 24u8 , 199u8 , 255u8 , 97u8 , 38u8 , 238u8 , 56u8 , 211u8 , 153u8 , 176u8 , 31u8 , 17u8 , 79u8 , 36u8 , 8u8 , 77u8 , 204u8 , 132u8 , 10u8 ,]) } # [doc = "Send a call through an indexed pseudonym of the sender."] # [doc = ""] # [doc = "Filter from origin are passed along. The call will be dispatched with an origin which"] # [doc = "use the same filter as the origin of this call."] # [doc = ""] # [doc = "NOTE: If you need to ensure that any account-based filtering is not honored (i.e."] # [doc = "because you expect `proxy` to have been used prior in the call stack and you do not want"] # [doc = "the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`"] # [doc = "in the Multisig pallet instead."] # [doc = ""] # [doc = "NOTE: Prior to version *12, this was called `as_limited_sub`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] pub fn as_derivative (& self , index : :: core :: primitive :: u16 , call : runtime_types :: alphanet_runtime :: RuntimeCall ,) -> :: subxt :: tx :: StaticTxPayload < AsDerivative > { :: subxt :: tx :: StaticTxPayload :: new ("Utility" , "as_derivative" , AsDerivative { index , call : :: std :: boxed :: Box :: new (call) , } , [186u8 , 60u8 , 100u8 , 193u8 , 140u8 , 9u8 , 202u8 , 174u8 , 179u8 , 255u8 , 210u8 , 216u8 , 99u8 , 88u8 , 154u8 , 218u8 , 25u8 , 142u8 , 52u8 , 64u8 , 11u8 , 172u8 , 228u8 , 88u8 , 19u8 , 172u8 , 250u8 , 148u8 , 109u8 , 196u8 , 193u8 , 11u8 ,]) } # [doc = "Send a batch of dispatch calls and atomically execute them."] # [doc = "The whole transaction will rollback and fail if any of the calls failed."] # [doc = ""] # [doc = "May be called from any origin."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then call are dispatch without checking origin filter. (This includes"] # [doc = "bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(C) where C is the number of calls to be batched."] # [doc = "# </weight>"] pub fn batch_all (& self , calls : :: std :: vec :: Vec < runtime_types :: alphanet_runtime :: RuntimeCall > ,) -> :: subxt :: tx :: StaticTxPayload < BatchAll > { :: subxt :: tx :: StaticTxPayload :: new ("Utility" , "batch_all" , BatchAll { calls , } , [120u8 , 48u8 , 126u8 , 145u8 , 60u8 , 211u8 , 207u8 , 179u8 , 129u8 , 180u8 , 172u8 , 69u8 , 6u8 , 185u8 , 48u8 , 19u8 , 80u8 , 43u8 , 111u8 , 16u8 , 129u8 , 253u8 , 77u8 , 175u8 , 227u8 , 210u8 , 162u8 , 89u8 , 196u8 , 36u8 , 40u8 , 120u8 ,]) } # [doc = "Dispatches a function call with a provided origin."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "- Limited storage reads."] # [doc = "- One DB write (event)."] # [doc = "- Weight of derivative `call` execution + T::WeightInfo::dispatch_as()."] # [doc = "# </weight>"] pub fn dispatch_as (& self , as_origin : runtime_types :: alphanet_runtime :: OriginCaller , call : runtime_types :: alphanet_runtime :: RuntimeCall ,) -> :: subxt :: tx :: StaticTxPayload < DispatchAs > { :: subxt :: tx :: StaticTxPayload :: new ("Utility" , "dispatch_as" , DispatchAs { as_origin : :: std :: boxed :: Box :: new (as_origin) , call : :: std :: boxed :: Box :: new (call) , } , [146u8 , 60u8 , 216u8 , 194u8 , 122u8 , 101u8 , 56u8 , 251u8 , 53u8 , 30u8 , 115u8 , 80u8 , 140u8 , 102u8 , 209u8 , 223u8 , 8u8 , 239u8 , 31u8 , 147u8 , 68u8 , 53u8 , 243u8 , 205u8 , 103u8 , 149u8 , 180u8 , 60u8 , 12u8 , 143u8 , 25u8 , 79u8 ,]) } # [doc = "Send a batch of dispatch calls."] # [doc = "Unlike `batch`, it allows errors and won't interrupt."] # [doc = ""] # [doc = "May be called from any origin."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then call are dispatch without checking origin filter. (This includes"] # [doc = "bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(C) where C is the number of calls to be batched."] # [doc = "# </weight>"] pub fn force_batch (& self , calls : :: std :: vec :: Vec < runtime_types :: alphanet_runtime :: RuntimeCall > ,) -> :: subxt :: tx :: StaticTxPayload < ForceBatch > { :: subxt :: tx :: StaticTxPayload :: new ("Utility" , "force_batch" , ForceBatch { calls , } , [50u8 , 67u8 , 167u8 , 90u8 , 137u8 , 73u8 , 146u8 , 209u8 , 71u8 , 159u8 , 68u8 , 103u8 , 40u8 , 202u8 , 90u8 , 135u8 , 207u8 , 230u8 , 119u8 , 109u8 , 12u8 , 170u8 , 46u8 , 135u8 , 158u8 , 90u8 , 138u8 , 6u8 , 6u8 , 81u8 , 20u8 , 108u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_utility :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Batch of dispatches did not complete fully. Index of first failing dispatch given, as"] # [doc = "well as the error."] pub struct BatchInterrupted { pub index : :: core :: primitive :: u32 , pub error : runtime_types :: sp_runtime :: DispatchError , } impl :: subxt :: events :: StaticEvent for BatchInterrupted { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "BatchInterrupted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Batch of dispatches completed fully with no error."] pub struct BatchCompleted ; impl :: subxt :: events :: StaticEvent for BatchCompleted { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "BatchCompleted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Batch of dispatches completed but has errors."] pub struct BatchCompletedWithErrors ; impl :: subxt :: events :: StaticEvent for BatchCompletedWithErrors { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "BatchCompletedWithErrors" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A single item within a Batch of dispatches has completed with no error."] pub struct ItemCompleted ; impl :: subxt :: events :: StaticEvent for ItemCompleted { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "ItemCompleted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A single item within a Batch of dispatches has completed with error."] pub struct ItemFailed { pub error : runtime_types :: sp_runtime :: DispatchError , } impl :: subxt :: events :: StaticEvent for ItemFailed { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "ItemFailed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A call was dispatched."] pub struct DispatchedAs { pub result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: events :: StaticEvent for DispatchedAs { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "DispatchedAs" ; } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The limit on the number of batched calls."] pub fn batched_calls_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Utility" , "batched_calls_limit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod preimage { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct NotePreimage { pub bytes : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct UnnotePreimage { pub hash : :: subxt :: ext :: sp_core :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RequestPreimage { pub hash : :: subxt :: ext :: sp_core :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct UnrequestPreimage { pub hash : :: subxt :: ext :: sp_core :: H256 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Register a preimage on-chain."] # [doc = ""] # [doc = "If the preimage was previously requested, no fees or deposits are taken for providing"] # [doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."] pub fn note_preimage (& self , bytes : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: StaticTxPayload < NotePreimage > { :: subxt :: tx :: StaticTxPayload :: new ("Preimage" , "note_preimage" , NotePreimage { bytes , } , [77u8 , 48u8 , 104u8 , 3u8 , 254u8 , 65u8 , 106u8 , 95u8 , 204u8 , 89u8 , 149u8 , 29u8 , 144u8 , 188u8 , 99u8 , 23u8 , 146u8 , 142u8 , 35u8 , 17u8 , 125u8 , 130u8 , 31u8 , 206u8 , 106u8 , 83u8 , 163u8 , 192u8 , 81u8 , 23u8 , 232u8 , 230u8 ,]) } # [doc = "Clear an unrequested preimage from the runtime storage."] pub fn unnote_preimage (& self , hash : :: subxt :: ext :: sp_core :: H256 ,) -> :: subxt :: tx :: StaticTxPayload < UnnotePreimage > { :: subxt :: tx :: StaticTxPayload :: new ("Preimage" , "unnote_preimage" , UnnotePreimage { hash , } , [211u8 , 204u8 , 205u8 , 58u8 , 33u8 , 179u8 , 68u8 , 74u8 , 149u8 , 138u8 , 213u8 , 45u8 , 140u8 , 27u8 , 106u8 , 81u8 , 68u8 , 212u8 , 147u8 , 116u8 , 27u8 , 130u8 , 84u8 , 34u8 , 231u8 , 197u8 , 135u8 , 8u8 , 19u8 , 242u8 , 207u8 , 17u8 ,]) } # [doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."] # [doc = ""] # [doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"] # [doc = "a user may have paid, and take the control of the preimage out of their hands."] pub fn request_preimage (& self , hash : :: subxt :: ext :: sp_core :: H256 ,) -> :: subxt :: tx :: StaticTxPayload < RequestPreimage > { :: subxt :: tx :: StaticTxPayload :: new ("Preimage" , "request_preimage" , RequestPreimage { hash , } , [195u8 , 26u8 , 146u8 , 255u8 , 79u8 , 43u8 , 73u8 , 60u8 , 115u8 , 78u8 , 99u8 , 197u8 , 137u8 , 95u8 , 139u8 , 141u8 , 79u8 , 213u8 , 170u8 , 169u8 , 127u8 , 30u8 , 236u8 , 65u8 , 38u8 , 16u8 , 118u8 , 228u8 , 141u8 , 83u8 , 162u8 , 233u8 ,]) } # [doc = "Clear a previously made request for a preimage."] # [doc = ""] # [doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."] pub fn unrequest_preimage (& self , hash : :: subxt :: ext :: sp_core :: H256 ,) -> :: subxt :: tx :: StaticTxPayload < UnrequestPreimage > { :: subxt :: tx :: StaticTxPayload :: new ("Preimage" , "unrequest_preimage" , UnrequestPreimage { hash , } , [143u8 , 225u8 , 239u8 , 44u8 , 237u8 , 83u8 , 18u8 , 105u8 , 101u8 , 68u8 , 111u8 , 116u8 , 66u8 , 212u8 , 63u8 , 190u8 , 38u8 , 32u8 , 105u8 , 152u8 , 69u8 , 177u8 , 193u8 , 15u8 , 60u8 , 26u8 , 95u8 , 130u8 , 11u8 , 113u8 , 187u8 , 108u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_preimage :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A preimage has been noted."] pub struct Noted { pub hash : :: subxt :: ext :: sp_core :: H256 , } impl :: subxt :: events :: StaticEvent for Noted { const PALLET : & 'static str = "Preimage" ; const EVENT : & 'static str = "Noted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A preimage has been requested."] pub struct Requested { pub hash : :: subxt :: ext :: sp_core :: H256 , } impl :: subxt :: events :: StaticEvent for Requested { const PALLET : & 'static str = "Preimage" ; const EVENT : & 'static str = "Requested" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A preimage has ben cleared."] pub struct Cleared { pub hash : :: subxt :: ext :: sp_core :: H256 , } impl :: subxt :: events :: StaticEvent for Cleared { const PALLET : & 'static str = "Preimage" ; const EVENT : & 'static str = "Cleared" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The request status of a given hash."] pub fn status_for (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: H256 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_preimage :: RequestStatus < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Preimage" , "StatusFor" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Identity)] , [244u8 , 6u8 , 120u8 , 75u8 , 164u8 , 32u8 , 39u8 , 15u8 , 107u8 , 127u8 , 19u8 , 242u8 , 80u8 , 121u8 , 18u8 , 219u8 , 253u8 , 174u8 , 138u8 , 9u8 , 76u8 , 219u8 , 156u8 , 229u8 , 78u8 , 155u8 , 233u8 , 162u8 , 215u8 , 237u8 , 23u8 , 123u8 ,]) } # [doc = " The request status of a given hash."] pub fn status_for_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_preimage :: RequestStatus < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Preimage" , "StatusFor" , Vec :: new () , [244u8 , 6u8 , 120u8 , 75u8 , 164u8 , 32u8 , 39u8 , 15u8 , 107u8 , 127u8 , 19u8 , 242u8 , 80u8 , 121u8 , 18u8 , 219u8 , 253u8 , 174u8 , 138u8 , 9u8 , 76u8 , 219u8 , 156u8 , 229u8 , 78u8 , 155u8 , 233u8 , 162u8 , 215u8 , 237u8 , 23u8 , 123u8 ,]) } # [doc = " The preimages stored by this pallet."] pub fn preimage_for (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: H256 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Preimage" , "PreimageFor" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Identity)] , [82u8 , 216u8 , 233u8 , 5u8 , 102u8 , 206u8 , 96u8 , 64u8 , 133u8 , 179u8 , 63u8 , 45u8 , 53u8 , 42u8 , 190u8 , 95u8 , 77u8 , 197u8 , 60u8 , 11u8 , 59u8 , 231u8 , 190u8 , 219u8 , 87u8 , 149u8 , 112u8 , 196u8 , 33u8 , 238u8 , 247u8 , 117u8 ,]) } # [doc = " The preimages stored by this pallet."] pub fn preimage_for_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Preimage" , "PreimageFor" , Vec :: new () , [82u8 , 216u8 , 233u8 , 5u8 , 102u8 , 206u8 , 96u8 , 64u8 , 133u8 , 179u8 , 63u8 , 45u8 , 53u8 , 42u8 , 190u8 , 95u8 , 77u8 , 197u8 , 60u8 , 11u8 , 59u8 , 231u8 , 190u8 , 219u8 , 87u8 , 149u8 , 112u8 , 196u8 , 33u8 , 238u8 , 247u8 , 117u8 ,]) } } } } pub mod bridge { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetThreshold { pub threshold : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AddChain { pub chain_id : :: core :: primitive :: u8 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetRelayers { pub relayers : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetDepositNonce { pub chain_id : :: core :: primitive :: u8 , pub nonce : :: core :: primitive :: u64 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct VoteForProposal { pub chain_id : :: core :: primitive :: u8 , pub nonce : :: core :: primitive :: u64 , pub recipient : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub amount : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Deposit { pub amount : :: core :: primitive :: u128 , pub recipient : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub dest_id : :: core :: primitive :: u8 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetBridgeFee { pub bridge_fee : :: core :: primitive :: u128 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Sets the vote threshold for proposals."] # [doc = ""] # [doc = "This threshold is used to determine how many votes are required"] # [doc = "before a proposal is executed."] pub fn set_threshold (& self , threshold : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < SetThreshold > { :: subxt :: tx :: StaticTxPayload :: new ("Bridge" , "set_threshold" , SetThreshold { threshold , } , [97u8 , 156u8 , 187u8 , 176u8 , 219u8 , 218u8 , 220u8 , 12u8 , 153u8 , 121u8 , 167u8 , 142u8 , 88u8 , 249u8 , 99u8 , 44u8 , 183u8 , 26u8 , 130u8 , 71u8 , 228u8 , 33u8 , 233u8 , 203u8 , 93u8 , 138u8 , 130u8 , 146u8 , 242u8 , 169u8 , 196u8 , 225u8 ,]) } # [doc = "Enables a chain ID as a source or destination for a bridge deposit."] pub fn add_chain (& self , chain_id : :: core :: primitive :: u8 ,) -> :: subxt :: tx :: StaticTxPayload < AddChain > { :: subxt :: tx :: StaticTxPayload :: new ("Bridge" , "add_chain" , AddChain { chain_id , } , [102u8 , 196u8 , 202u8 , 200u8 , 157u8 , 117u8 , 185u8 , 251u8 , 145u8 , 121u8 , 31u8 , 185u8 , 73u8 , 52u8 , 92u8 , 244u8 , 22u8 , 218u8 , 153u8 , 252u8 , 51u8 , 136u8 , 13u8 , 64u8 , 228u8 , 136u8 , 150u8 , 220u8 , 145u8 , 225u8 , 107u8 , 42u8 ,]) } # [doc = "Update the set of relayers."] pub fn set_relayers (& self , relayers : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: tx :: StaticTxPayload < SetRelayers > { :: subxt :: tx :: StaticTxPayload :: new ("Bridge" , "set_relayers" , SetRelayers { relayers , } , [134u8 , 187u8 , 82u8 , 221u8 , 49u8 , 75u8 , 221u8 , 65u8 , 65u8 , 99u8 , 78u8 , 7u8 , 31u8 , 211u8 , 129u8 , 205u8 , 153u8 , 193u8 , 62u8 , 140u8 , 119u8 , 68u8 , 180u8 , 224u8 , 51u8 , 244u8 , 206u8 , 190u8 , 193u8 , 112u8 , 56u8 , 119u8 ,]) } # [doc = "Update the set of relayers."] pub fn set_deposit_nonce (& self , chain_id : :: core :: primitive :: u8 , nonce : :: core :: primitive :: u64 ,) -> :: subxt :: tx :: StaticTxPayload < SetDepositNonce > { :: subxt :: tx :: StaticTxPayload :: new ("Bridge" , "set_deposit_nonce" , SetDepositNonce { chain_id , nonce , } , [62u8 , 150u8 , 239u8 , 226u8 , 162u8 , 178u8 , 78u8 , 189u8 , 126u8 , 217u8 , 229u8 , 64u8 , 138u8 , 254u8 , 16u8 , 254u8 , 51u8 , 251u8 , 15u8 , 8u8 , 51u8 , 42u8 , 126u8 , 41u8 , 189u8 , 19u8 , 43u8 , 105u8 , 21u8 , 1u8 , 179u8 , 215u8 ,]) } # [doc = "Commits a vote in favour or against the provided proposal."] # [doc = ""] # [doc = "If a proposal with the given nonce and source chain ID does not already exist, it will"] # [doc = "be created with an initial vote in favour from the caller."] pub fn vote_for_proposal (& self , chain_id : :: core :: primitive :: u8 , nonce : :: core :: primitive :: u64 , recipient : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , amount : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < VoteForProposal > { :: subxt :: tx :: StaticTxPayload :: new ("Bridge" , "vote_for_proposal" , VoteForProposal { chain_id , nonce , recipient , amount , } , [249u8 , 171u8 , 3u8 , 31u8 , 211u8 , 102u8 , 136u8 , 123u8 , 221u8 , 243u8 , 19u8 , 187u8 , 92u8 , 118u8 , 41u8 , 111u8 , 164u8 , 84u8 , 12u8 , 170u8 , 120u8 , 125u8 , 53u8 , 253u8 , 169u8 , 224u8 , 36u8 , 212u8 , 85u8 , 49u8 , 151u8 , 199u8 ,]) } # [doc = "Deposit some amount of the native token to some recipient on a (whitelisted)"] # [doc = "destination chain."] pub fn deposit (& self , amount : :: core :: primitive :: u128 , recipient : :: std :: vec :: Vec < :: core :: primitive :: u8 > , dest_id : :: core :: primitive :: u8 ,) -> :: subxt :: tx :: StaticTxPayload < Deposit > { :: subxt :: tx :: StaticTxPayload :: new ("Bridge" , "deposit" , Deposit { amount , recipient , dest_id , } , [246u8 , 228u8 , 239u8 , 81u8 , 196u8 , 136u8 , 57u8 , 221u8 , 200u8 , 70u8 , 174u8 , 142u8 , 189u8 , 215u8 , 42u8 , 136u8 , 66u8 , 105u8 , 208u8 , 178u8 , 133u8 , 156u8 , 27u8 , 93u8 , 184u8 , 128u8 , 58u8 , 6u8 , 238u8 , 151u8 , 169u8 , 92u8 ,]) } # [doc = "Update the bridge fee value"] pub fn set_bridge_fee (& self , bridge_fee : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < SetBridgeFee > { :: subxt :: tx :: StaticTxPayload :: new ("Bridge" , "set_bridge_fee" , SetBridgeFee { bridge_fee , } , [184u8 , 94u8 , 126u8 , 12u8 , 78u8 , 212u8 , 72u8 , 171u8 , 72u8 , 240u8 , 152u8 , 201u8 , 108u8 , 130u8 , 227u8 , 84u8 , 139u8 , 21u8 , 179u8 , 230u8 , 255u8 , 52u8 , 152u8 , 92u8 , 159u8 , 6u8 , 184u8 , 21u8 , 100u8 , 62u8 , 25u8 , 192u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: ternoa_bridge :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Bridge fee changed"] pub struct BridgeFeeUpdated { pub fee : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for BridgeFeeUpdated { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "BridgeFeeUpdated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Make a deposit from Native to ERC20"] pub struct DepositMade { pub chain_id : :: core :: primitive :: u8 , pub nonce : :: core :: primitive :: u64 , pub amount : runtime_types :: primitive_types :: U256 , pub recipient : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: events :: StaticEvent for DepositMade { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "DepositMade" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Deposit Nonce Updated"] pub struct DepositNonceUpdated { pub chain_id : :: core :: primitive :: u8 , pub nonce : :: core :: primitive :: u64 , } impl :: subxt :: events :: StaticEvent for DepositNonceUpdated { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "DepositNonceUpdated" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Chain allowed to be used"] pub struct ChainAllowed { pub chain_id : :: core :: primitive :: u8 , } impl :: subxt :: events :: StaticEvent for ChainAllowed { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "ChainAllowed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Voting successful for a proposal"] pub struct ProposalApproved { pub chain_id : :: core :: primitive :: u8 , pub nonce : :: core :: primitive :: u64 , } impl :: subxt :: events :: StaticEvent for ProposalApproved { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "ProposalApproved" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Vote threshold has changed"] pub struct RelayerThresholdUpdated { pub threshold : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for RelayerThresholdUpdated { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "RelayerThresholdUpdated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Vote submitted in favour of proposal"] pub struct RelayerVoted { pub chain_id : :: core :: primitive :: u8 , pub nonce : :: core :: primitive :: u64 , pub account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for RelayerVoted { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "RelayerVoted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Relayers has been updated"] pub struct RelayersUpdated { pub relayers : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } impl :: subxt :: events :: StaticEvent for RelayersUpdated { const PALLET : & 'static str = "Bridge" ; const EVENT : & 'static str = "RelayersUpdated" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " All whitelisted chains and their respective transaction counts"] pub fn chain_nonces (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u8 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u64 > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Bridge" , "ChainNonces" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_256)] , [193u8 , 13u8 , 14u8 , 0u8 , 141u8 , 134u8 , 145u8 , 25u8 , 129u8 , 166u8 , 133u8 , 178u8 , 145u8 , 105u8 , 161u8 , 122u8 , 109u8 , 26u8 , 206u8 , 36u8 , 19u8 , 11u8 , 130u8 , 29u8 , 80u8 , 14u8 , 102u8 , 181u8 , 46u8 , 228u8 , 239u8 , 112u8 ,]) } # [doc = " All whitelisted chains and their respective transaction counts"] pub fn chain_nonces_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u64 > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Bridge" , "ChainNonces" , Vec :: new () , [193u8 , 13u8 , 14u8 , 0u8 , 141u8 , 134u8 , 145u8 , 25u8 , 129u8 , 166u8 , 133u8 , 178u8 , 145u8 , 105u8 , 161u8 , 122u8 , 109u8 , 26u8 , 206u8 , 36u8 , 19u8 , 11u8 , 130u8 , 29u8 , 80u8 , 14u8 , 102u8 , 181u8 , 46u8 , 228u8 , 239u8 , 112u8 ,]) } # [doc = " Number of votes required for a proposal to execute"] pub fn relayer_vote_threshold (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Bridge" , "RelayerVoteThreshold" , vec ! [] , [152u8 , 54u8 , 0u8 , 73u8 , 12u8 , 39u8 , 54u8 , 114u8 , 45u8 , 151u8 , 1u8 , 73u8 , 66u8 , 118u8 , 107u8 , 228u8 , 205u8 , 72u8 , 25u8 , 76u8 , 53u8 , 83u8 , 239u8 , 148u8 , 62u8 , 255u8 , 124u8 , 57u8 , 81u8 , 57u8 , 87u8 , 78u8 ,]) } # [doc = " Tracks current relayer set"] pub fn relayers (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Bridge" , "Relayers" , vec ! [] , [228u8 , 90u8 , 23u8 , 218u8 , 14u8 , 156u8 , 32u8 , 55u8 , 228u8 , 195u8 , 249u8 , 153u8 , 87u8 , 246u8 , 92u8 , 47u8 , 15u8 , 129u8 , 60u8 , 232u8 , 119u8 , 183u8 , 158u8 , 9u8 , 115u8 , 157u8 , 125u8 , 106u8 , 153u8 , 179u8 , 208u8 , 28u8 ,]) } # [doc = " All known proposals."] # [doc = " The key is the hash of the call and the deposit ID, to ensure it's unique."] pub fn votes (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u8 > , _1 : impl :: std :: borrow :: Borrow < (:: core :: primitive :: u64 , :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_bridge :: types :: Proposal < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Bridge" , "Votes" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_256) , :: subxt :: storage :: address :: StorageMapKey :: new (_1 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_256)] , [100u8 , 217u8 , 209u8 , 161u8 , 26u8 , 253u8 , 166u8 , 85u8 , 173u8 , 95u8 , 252u8 , 253u8 , 3u8 , 164u8 , 143u8 , 254u8 , 182u8 , 74u8 , 1u8 , 235u8 , 28u8 , 242u8 , 222u8 , 78u8 , 5u8 , 223u8 , 85u8 , 226u8 , 1u8 , 62u8 , 251u8 , 41u8 ,]) } # [doc = " All known proposals."] # [doc = " The key is the hash of the call and the deposit ID, to ensure it's unique."] pub fn votes_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_bridge :: types :: Proposal < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Bridge" , "Votes" , Vec :: new () , [100u8 , 217u8 , 209u8 , 161u8 , 26u8 , 253u8 , 166u8 , 85u8 , 173u8 , 95u8 , 252u8 , 253u8 , 3u8 , 164u8 , 143u8 , 254u8 , 182u8 , 74u8 , 1u8 , 235u8 , 28u8 , 242u8 , 222u8 , 78u8 , 5u8 , 223u8 , 85u8 , 226u8 , 1u8 , 62u8 , 251u8 , 41u8 ,]) } # [doc = " Host much does it cost to deposit through the bridge (extra fee on top of the tx"] # [doc = " fees)"] pub fn bridge_fee (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Bridge" , "BridgeFee" , vec ! [] , [120u8 , 6u8 , 30u8 , 51u8 , 20u8 , 169u8 , 140u8 , 223u8 , 115u8 , 92u8 , 69u8 , 177u8 , 118u8 , 149u8 , 239u8 , 31u8 , 232u8 , 112u8 , 138u8 , 60u8 , 126u8 , 54u8 , 213u8 , 43u8 , 176u8 , 63u8 , 126u8 , 155u8 , 50u8 , 98u8 , 141u8 , 23u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The identifier for this chain."] # [doc = " This must be unique and must not collide with existing IDs within a set of bridged"] # [doc = " chains."] pub fn chain_id (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u8 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Bridge" , "ChainId" , [141u8 , 130u8 , 11u8 , 35u8 , 226u8 , 114u8 , 92u8 , 179u8 , 168u8 , 110u8 , 28u8 , 91u8 , 221u8 , 64u8 , 4u8 , 148u8 , 201u8 , 193u8 , 185u8 , 66u8 , 226u8 , 114u8 , 97u8 , 79u8 , 62u8 , 212u8 , 202u8 , 114u8 , 237u8 , 228u8 , 183u8 , 165u8 ,]) } # [doc = " Constant configuration parameter to store the module identifier for the pallet."] pub fn pallet_id (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < runtime_types :: frame_support :: PalletId >> { :: subxt :: constants :: StaticConstantAddress :: new ("Bridge" , "PalletId" , [139u8 , 109u8 , 228u8 , 151u8 , 252u8 , 32u8 , 130u8 , 69u8 , 112u8 , 154u8 , 174u8 , 45u8 , 83u8 , 245u8 , 51u8 , 132u8 , 173u8 , 5u8 , 186u8 , 24u8 , 243u8 , 9u8 , 12u8 , 214u8 , 80u8 , 74u8 , 69u8 , 189u8 , 30u8 , 94u8 , 22u8 , 39u8 ,]) } pub fn proposal_lifetime (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Bridge" , "ProposalLifetime" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Type for setting initial number of votes required for a proposal to be executed (see"] # [doc = " [RelayerVoteThreshold] in storage section)."] pub fn relayer_vote_threshold (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Bridge" , "RelayerVoteThreshold" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Total amount of accounts that can be in the bidder list."] pub fn relayer_count_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Bridge" , "RelayerCountLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Total amount of accounts that can be in the bidder list."] pub fn initial_bridge_fee (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Bridge" , "InitialBridgeFee" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } } } } pub mod multisig { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AsMultiThreshold1 { pub other_signatories : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , pub call : :: std :: boxed :: Box < runtime_types :: alphanet_runtime :: RuntimeCall > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AsMulti { pub threshold : :: core :: primitive :: u16 , pub other_signatories : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , pub maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , pub call : :: subxt :: utils :: WrapperKeepOpaque < runtime_types :: alphanet_runtime :: RuntimeCall > , pub store_call : :: core :: primitive :: bool , pub max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ApproveAsMulti { pub threshold : :: core :: primitive :: u16 , pub other_signatories : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , pub maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , pub call_hash : [:: core :: primitive :: u8 ; 32usize] , pub max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CancelAsMulti { pub threshold : :: core :: primitive :: u16 , pub other_signatories : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , pub timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , pub call_hash : [:: core :: primitive :: u8 ; 32usize] , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Immediately dispatch a multi-signature call using a single approval from the caller."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `other_signatories`: The accounts (other than the sender) who are part of the"] # [doc = "multi-signature, but do not participate in the approval process."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result."] # [doc = ""] # [doc = "# <weight>"] # [doc = "O(Z + C) where Z is the length of the call and C its execution weight."] # [doc = "-------------------------------"] # [doc = "- DB Weight: None"] # [doc = "- Plus Call Weight"] # [doc = "# </weight>"] pub fn as_multi_threshold_1 (& self , other_signatories : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , call : runtime_types :: alphanet_runtime :: RuntimeCall ,) -> :: subxt :: tx :: StaticTxPayload < AsMultiThreshold1 > { :: subxt :: tx :: StaticTxPayload :: new ("Multisig" , "as_multi_threshold_1" , AsMultiThreshold1 { other_signatories , call : :: std :: boxed :: Box :: new (call) , } , [187u8 , 148u8 , 12u8 , 202u8 , 198u8 , 202u8 , 16u8 , 215u8 , 46u8 , 171u8 , 167u8 , 251u8 , 62u8 , 46u8 , 90u8 , 50u8 , 96u8 , 55u8 , 208u8 , 122u8 , 93u8 , 19u8 , 157u8 , 36u8 , 33u8 , 54u8 , 234u8 , 227u8 , 20u8 , 65u8 , 133u8 , 219u8 ,]) } # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "If there are enough, then dispatch the call."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "NOTE: Unless this is the final approval, you will generally want to use"] # [doc = "`approve_as_multi` instead, since it only requires a hash of the call."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise"] # [doc = "on success, result is `Ok` and the result from the interior call, if it was executed,"] # [doc = "may be found in the deposited `MultisigExecuted` event."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(S + Z + Call)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- The weight of the `call`."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] # [doc = "-------------------------------"] # [doc = "- DB Weight:"] # [doc = "    - Reads: Multisig Storage, [Caller Account], Calls (if `store_call`)"] # [doc = "    - Writes: Multisig Storage, [Caller Account], Calls (if `store_call`)"] # [doc = "- Plus Call Weight"] # [doc = "# </weight>"] pub fn as_multi (& self , threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , call : :: subxt :: utils :: WrapperKeepOpaque < runtime_types :: alphanet_runtime :: RuntimeCall > , store_call : :: core :: primitive :: bool , max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight ,) -> :: subxt :: tx :: StaticTxPayload < AsMulti > { :: subxt :: tx :: StaticTxPayload :: new ("Multisig" , "as_multi" , AsMulti { threshold , other_signatories , maybe_timepoint , call , store_call , max_weight , } , [100u8 , 137u8 , 175u8 , 142u8 , 184u8 , 140u8 , 25u8 , 93u8 , 143u8 , 156u8 , 100u8 , 25u8 , 220u8 , 169u8 , 13u8 , 95u8 , 247u8 , 0u8 , 50u8 , 126u8 , 116u8 , 22u8 , 205u8 , 168u8 , 13u8 , 176u8 , 246u8 , 184u8 , 210u8 , 53u8 , 254u8 , 179u8 ,]) } # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "NOTE: If this is the final approval, you will want to use `as_multi` instead."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] # [doc = "----------------------------------"] # [doc = "- DB Weight:"] # [doc = "    - Read: Multisig Storage, [Caller Account]"] # [doc = "    - Write: Multisig Storage, [Caller Account]"] # [doc = "# </weight>"] pub fn approve_as_multi (& self , threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , call_hash : [:: core :: primitive :: u8 ; 32usize] , max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight ,) -> :: subxt :: tx :: StaticTxPayload < ApproveAsMulti > { :: subxt :: tx :: StaticTxPayload :: new ("Multisig" , "approve_as_multi" , ApproveAsMulti { threshold , other_signatories , maybe_timepoint , call_hash , max_weight , } , [133u8 , 113u8 , 121u8 , 66u8 , 218u8 , 219u8 , 48u8 , 64u8 , 211u8 , 114u8 , 163u8 , 193u8 , 164u8 , 21u8 , 140u8 , 218u8 , 253u8 , 237u8 , 240u8 , 126u8 , 200u8 , 213u8 , 184u8 , 50u8 , 187u8 , 182u8 , 30u8 , 52u8 , 142u8 , 72u8 , 210u8 , 101u8 ,]) } # [doc = "Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously"] # [doc = "for this operation will be unreserved on success."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `timepoint`: The timepoint (block number and transaction index) of the first approval"] # [doc = "transaction for this dispatch."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- One event."] # [doc = "- I/O: 1 read `O(S)`, one remove."] # [doc = "- Storage: removes one item."] # [doc = "----------------------------------"] # [doc = "- DB Weight:"] # [doc = "    - Read: Multisig Storage, [Caller Account], Refund Account, Calls"] # [doc = "    - Write: Multisig Storage, [Caller Account], Refund Account, Calls"] # [doc = "# </weight>"] pub fn cancel_as_multi (& self , threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , call_hash : [:: core :: primitive :: u8 ; 32usize] ,) -> :: subxt :: tx :: StaticTxPayload < CancelAsMulti > { :: subxt :: tx :: StaticTxPayload :: new ("Multisig" , "cancel_as_multi" , CancelAsMulti { threshold , other_signatories , timepoint , call_hash , } , [30u8 , 25u8 , 186u8 , 142u8 , 168u8 , 81u8 , 235u8 , 164u8 , 82u8 , 209u8 , 66u8 , 129u8 , 209u8 , 78u8 , 172u8 , 9u8 , 163u8 , 222u8 , 125u8 , 57u8 , 2u8 , 43u8 , 169u8 , 174u8 , 159u8 , 167u8 , 25u8 , 226u8 , 254u8 , 110u8 , 80u8 , 216u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_multisig :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A new multisig operation has begun."] pub struct NewMultisig { pub approving : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub multisig : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub call_hash : [:: core :: primitive :: u8 ; 32usize] , } impl :: subxt :: events :: StaticEvent for NewMultisig { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "NewMultisig" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A multisig operation has been approved by someone."] pub struct MultisigApproval { pub approving : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , pub multisig : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub call_hash : [:: core :: primitive :: u8 ; 32usize] , } impl :: subxt :: events :: StaticEvent for MultisigApproval { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "MultisigApproval" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A multisig operation has been executed."] pub struct MultisigExecuted { pub approving : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , pub multisig : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub call_hash : [:: core :: primitive :: u8 ; 32usize] , pub result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: events :: StaticEvent for MultisigExecuted { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "MultisigExecuted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A multisig operation has been cancelled."] pub struct MultisigCancelled { pub cancelling : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , pub multisig : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub call_hash : [:: core :: primitive :: u8 ; 32usize] , } impl :: subxt :: events :: StaticEvent for MultisigCancelled { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "MultisigCancelled" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The set of open multisig operations."] pub fn multisigs (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , _1 : impl :: std :: borrow :: Borrow < [:: core :: primitive :: u8 ; 32usize] > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_multisig :: Multisig < :: core :: primitive :: u32 , :: core :: primitive :: u128 , :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Multisig" , "Multisigs" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat) , :: subxt :: storage :: address :: StorageMapKey :: new (_1 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [145u8 , 78u8 , 57u8 , 171u8 , 199u8 , 158u8 , 226u8 , 250u8 , 224u8 , 133u8 , 45u8 , 251u8 , 202u8 , 22u8 , 171u8 , 132u8 , 229u8 , 110u8 , 248u8 , 233u8 , 38u8 , 2u8 , 247u8 , 140u8 , 150u8 , 103u8 , 211u8 , 209u8 , 160u8 , 158u8 , 23u8 , 215u8 ,]) } # [doc = " The set of open multisig operations."] pub fn multisigs_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_multisig :: Multisig < :: core :: primitive :: u32 , :: core :: primitive :: u128 , :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Multisig" , "Multisigs" , Vec :: new () , [145u8 , 78u8 , 57u8 , 171u8 , 199u8 , 158u8 , 226u8 , 250u8 , 224u8 , 133u8 , 45u8 , 251u8 , 202u8 , 22u8 , 171u8 , 132u8 , 229u8 , 110u8 , 248u8 , 233u8 , 38u8 , 2u8 , 247u8 , 140u8 , 150u8 , 103u8 , 211u8 , 209u8 , 160u8 , 158u8 , 23u8 , 215u8 ,]) } pub fn calls (& self , _0 : impl :: std :: borrow :: Borrow < [:: core :: primitive :: u8 ; 32usize] > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: subxt :: utils :: WrapperKeepOpaque < runtime_types :: alphanet_runtime :: RuntimeCall > , :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Multisig" , "Calls" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Identity)] , [199u8 , 207u8 , 40u8 , 2u8 , 250u8 , 42u8 , 92u8 , 114u8 , 156u8 , 27u8 , 101u8 , 184u8 , 158u8 , 195u8 , 134u8 , 189u8 , 56u8 , 250u8 , 94u8 , 197u8 , 200u8 , 167u8 , 51u8 , 115u8 , 69u8 , 33u8 , 252u8 , 125u8 , 86u8 , 138u8 , 60u8 , 113u8 ,]) } pub fn calls_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: subxt :: utils :: WrapperKeepOpaque < runtime_types :: alphanet_runtime :: RuntimeCall > , :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Multisig" , "Calls" , Vec :: new () , [199u8 , 207u8 , 40u8 , 2u8 , 250u8 , 42u8 , 92u8 , 114u8 , 156u8 , 27u8 , 101u8 , 184u8 , 158u8 , 195u8 , 134u8 , 189u8 , 56u8 , 250u8 , 94u8 , 197u8 , 200u8 , 167u8 , 51u8 , 115u8 , 69u8 , 33u8 , 252u8 , 125u8 , 86u8 , 138u8 , 60u8 , 113u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The base amount of currency needed to reserve for creating a multisig execution or to"] # [doc = " store a dispatch call for later."] # [doc = ""] # [doc = " This is held for an additional storage item whose value size is"] # [doc = " `4 + sizeof((BlockNumber, Balance, AccountId))` bytes and whose key size is"] # [doc = " `32 + sizeof(AccountId)` bytes."] pub fn deposit_base (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Multisig" , "DepositBase" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The amount of currency needed per unit threshold when creating a multisig execution."] # [doc = ""] # [doc = " This is held for adding 32 bytes more into a pre-existing storage value."] pub fn deposit_factor (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Multisig" , "DepositFactor" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The maximum amount of signatories allowed in the multisig."] pub fn max_signatories (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u16 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Multisig" , "MaxSignatories" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } } } } pub mod identity { use super :: root_mod ; use super :: runtime_types ; # [doc = "Identity pallet declaration."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AddRegistrar { pub account : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetIdentity { pub info : :: std :: boxed :: Box < runtime_types :: pallet_identity :: types :: IdentityInfo > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetSubs { pub subs : :: std :: vec :: Vec < (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_identity :: types :: Data ,) > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ClearIdentity ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RequestJudgement { # [codec (compact)] pub reg_index : :: core :: primitive :: u32 , # [codec (compact)] pub max_fee : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CancelRequest { pub reg_index : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetFee { # [codec (compact)] pub index : :: core :: primitive :: u32 , # [codec (compact)] pub fee : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetAccountId { # [codec (compact)] pub index : :: core :: primitive :: u32 , pub new : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetFields { # [codec (compact)] pub index : :: core :: primitive :: u32 , pub fields : runtime_types :: pallet_identity :: types :: BitFlags < runtime_types :: pallet_identity :: types :: IdentityField > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ProvideJudgement { # [codec (compact)] pub reg_index : :: core :: primitive :: u32 , pub target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub judgement : runtime_types :: pallet_identity :: types :: Judgement < :: core :: primitive :: u128 > , pub identity : :: subxt :: ext :: sp_core :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct KillIdentity { pub target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AddSub { pub sub : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub data : runtime_types :: pallet_identity :: types :: Data , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RenameSub { pub sub : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub data : runtime_types :: pallet_identity :: types :: Data , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RemoveSub { pub sub : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct QuitSub ; pub struct TransactionApi ; impl TransactionApi { # [doc = "Add a registrar to the system."] # [doc = ""] # [doc = "The dispatch origin for this call must be `T::RegistrarOrigin`."] # [doc = ""] # [doc = "- `account`: the account of the registrar."] # [doc = ""] # [doc = "Emits `RegistrarAdded` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R)` where `R` registrar-count (governance-bounded and code-bounded)."] # [doc = "- One storage mutation (codec `O(R)`)."] # [doc = "- One event."] # [doc = "# </weight>"] pub fn add_registrar (& self , account : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < AddRegistrar > { :: subxt :: tx :: StaticTxPayload :: new ("Identity" , "add_registrar" , AddRegistrar { account , } , [157u8 , 232u8 , 252u8 , 190u8 , 203u8 , 233u8 , 127u8 , 63u8 , 111u8 , 16u8 , 118u8 , 200u8 , 31u8 , 234u8 , 144u8 , 111u8 , 161u8 , 224u8 , 217u8 , 86u8 , 179u8 , 254u8 , 162u8 , 212u8 , 248u8 , 8u8 , 125u8 , 89u8 , 23u8 , 195u8 , 4u8 , 231u8 ,]) } # [doc = "Set an account's identity information and reserve the appropriate deposit."] # [doc = ""] # [doc = "If the account already has identity information, the deposit is taken as part payment"] # [doc = "for the new deposit."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `info`: The identity information."] # [doc = ""] # [doc = "Emits `IdentitySet` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(X + X' + R)`"] # [doc = "  - where `X` additional-field-count (deposit-bounded and code-bounded)"] # [doc = "  - where `R` judgements-count (registrar-count-bounded)"] # [doc = "- One balance reserve operation."] # [doc = "- One storage mutation (codec-read `O(X' + R)`, codec-write `O(X + R)`)."] # [doc = "- One event."] # [doc = "# </weight>"] pub fn set_identity (& self , info : runtime_types :: pallet_identity :: types :: IdentityInfo ,) -> :: subxt :: tx :: StaticTxPayload < SetIdentity > { :: subxt :: tx :: StaticTxPayload :: new ("Identity" , "set_identity" , SetIdentity { info : :: std :: boxed :: Box :: new (info) , } , [130u8 , 89u8 , 118u8 , 6u8 , 134u8 , 166u8 , 35u8 , 192u8 , 73u8 , 6u8 , 171u8 , 20u8 , 225u8 , 255u8 , 152u8 , 142u8 , 111u8 , 8u8 , 206u8 , 200u8 , 64u8 , 52u8 , 110u8 , 123u8 , 42u8 , 101u8 , 191u8 , 242u8 , 133u8 , 139u8 , 154u8 , 205u8 ,]) } # [doc = "Set the sub-accounts of the sender."] # [doc = ""] # [doc = "Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned"] # [doc = "and an amount `SubAccountDeposit` will be reserved for each item in `subs`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "identity."] # [doc = ""] # [doc = "- `subs`: The identity's (new) sub-accounts."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(P + S)`"] # [doc = "  - where `P` old-subs-count (hard- and deposit-bounded)."] # [doc = "  - where `S` subs-count (hard- and deposit-bounded)."] # [doc = "- At most one balance operations."] # [doc = "- DB:"] # [doc = "  - `P + S` storage mutations (codec complexity `O(1)`)"] # [doc = "  - One storage read (codec complexity `O(P)`)."] # [doc = "  - One storage write (codec complexity `O(S)`)."] # [doc = "  - One storage-exists (`IdentityOf::contains_key`)."] # [doc = "# </weight>"] pub fn set_subs (& self , subs : :: std :: vec :: Vec < (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_identity :: types :: Data ,) > ,) -> :: subxt :: tx :: StaticTxPayload < SetSubs > { :: subxt :: tx :: StaticTxPayload :: new ("Identity" , "set_subs" , SetSubs { subs , } , [177u8 , 219u8 , 84u8 , 183u8 , 5u8 , 32u8 , 192u8 , 82u8 , 174u8 , 68u8 , 198u8 , 224u8 , 56u8 , 85u8 , 134u8 , 171u8 , 30u8 , 132u8 , 140u8 , 236u8 , 117u8 , 24u8 , 150u8 , 218u8 , 146u8 , 194u8 , 144u8 , 92u8 , 103u8 , 206u8 , 46u8 , 90u8 ,]) } # [doc = "Clear an account's identity info and all sub-accounts and return all deposits."] # [doc = ""] # [doc = "Payment: All reserved balances on the account are returned."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "identity."] # [doc = ""] # [doc = "Emits `IdentityCleared` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R + S + X)`"] # [doc = "  - where `R` registrar-count (governance-bounded)."] # [doc = "  - where `S` subs-count (hard- and deposit-bounded)."] # [doc = "  - where `X` additional-field-count (deposit-bounded and code-bounded)."] # [doc = "- One balance-unreserve operation."] # [doc = "- `2` storage reads and `S + 2` storage deletions."] # [doc = "- One event."] # [doc = "# </weight>"] pub fn clear_identity (& self ,) -> :: subxt :: tx :: StaticTxPayload < ClearIdentity > { :: subxt :: tx :: StaticTxPayload :: new ("Identity" , "clear_identity" , ClearIdentity { } , [75u8 , 44u8 , 74u8 , 122u8 , 149u8 , 202u8 , 114u8 , 230u8 , 0u8 , 255u8 , 140u8 , 122u8 , 14u8 , 196u8 , 205u8 , 249u8 , 220u8 , 94u8 , 216u8 , 34u8 , 63u8 , 14u8 , 8u8 , 205u8 , 74u8 , 23u8 , 181u8 , 129u8 , 252u8 , 110u8 , 231u8 , 114u8 ,]) } # [doc = "Request a judgement from a registrar."] # [doc = ""] # [doc = "Payment: At most `max_fee` will be reserved for payment to the registrar if judgement"] # [doc = "given."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a"] # [doc = "registered identity."] # [doc = ""] # [doc = "- `reg_index`: The index of the registrar whose judgement is requested."] # [doc = "- `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:"] # [doc = ""] # [doc = "```nocompile"] # [doc = "Self::registrars().get(reg_index).unwrap().fee"] # [doc = "```"] # [doc = ""] # [doc = "Emits `JudgementRequested` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R + X)`."] # [doc = "- One balance-reserve operation."] # [doc = "- Storage: 1 read `O(R)`, 1 mutate `O(X + R)`."] # [doc = "- One event."] # [doc = "# </weight>"] pub fn request_judgement (& self , reg_index : :: core :: primitive :: u32 , max_fee : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < RequestJudgement > { :: subxt :: tx :: StaticTxPayload :: new ("Identity" , "request_judgement" , RequestJudgement { reg_index , max_fee , } , [186u8 , 149u8 , 61u8 , 54u8 , 159u8 , 194u8 , 77u8 , 161u8 , 220u8 , 157u8 , 3u8 , 216u8 , 23u8 , 105u8 , 119u8 , 76u8 , 144u8 , 198u8 , 157u8 , 45u8 , 235u8 , 139u8 , 87u8 , 82u8 , 81u8 , 12u8 , 25u8 , 134u8 , 225u8 , 92u8 , 182u8 , 101u8 ,]) } # [doc = "Cancel a previous request."] # [doc = ""] # [doc = "Payment: A previously reserved deposit is returned on success."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a"] # [doc = "registered identity."] # [doc = ""] # [doc = "- `reg_index`: The index of the registrar whose judgement is no longer requested."] # [doc = ""] # [doc = "Emits `JudgementUnrequested` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R + X)`."] # [doc = "- One balance-reserve operation."] # [doc = "- One storage mutation `O(R + X)`."] # [doc = "- One event"] # [doc = "# </weight>"] pub fn cancel_request (& self , reg_index : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < CancelRequest > { :: subxt :: tx :: StaticTxPayload :: new ("Identity" , "cancel_request" , CancelRequest { reg_index , } , [83u8 , 180u8 , 239u8 , 126u8 , 32u8 , 51u8 , 17u8 , 20u8 , 180u8 , 3u8 , 59u8 , 96u8 , 24u8 , 32u8 , 136u8 , 92u8 , 58u8 , 254u8 , 68u8 , 70u8 , 50u8 , 11u8 , 51u8 , 91u8 , 180u8 , 79u8 , 81u8 , 84u8 , 216u8 , 138u8 , 6u8 , 215u8 ,]) } # [doc = "Set the fee required for a judgement to be requested from a registrar."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must be the account"] # [doc = "of the registrar whose index is `index`."] # [doc = ""] # [doc = "- `index`: the index of the registrar whose fee is to be set."] # [doc = "- `fee`: the new fee."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R)`."] # [doc = "- One storage mutation `O(R)`."] # [doc = "- Benchmark: 7.315 + R * 0.329 s (min squares analysis)"] # [doc = "# </weight>"] pub fn set_fee (& self , index : :: core :: primitive :: u32 , fee : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < SetFee > { :: subxt :: tx :: StaticTxPayload :: new ("Identity" , "set_fee" , SetFee { index , fee , } , [21u8 , 157u8 , 123u8 , 182u8 , 160u8 , 190u8 , 117u8 , 37u8 , 136u8 , 133u8 , 104u8 , 234u8 , 31u8 , 145u8 , 115u8 , 154u8 , 125u8 , 40u8 , 2u8 , 87u8 , 118u8 , 56u8 , 247u8 , 73u8 , 89u8 , 0u8 , 251u8 , 3u8 , 58u8 , 105u8 , 239u8 , 211u8 ,]) } # [doc = "Change the account associated with a registrar."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must be the account"] # [doc = "of the registrar whose index is `index`."] # [doc = ""] # [doc = "- `index`: the index of the registrar whose fee is to be set."] # [doc = "- `new`: the new account ID."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R)`."] # [doc = "- One storage mutation `O(R)`."] # [doc = "- Benchmark: 8.823 + R * 0.32 s (min squares analysis)"] # [doc = "# </weight>"] pub fn set_account_id (& self , index : :: core :: primitive :: u32 , new : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < SetAccountId > { :: subxt :: tx :: StaticTxPayload :: new ("Identity" , "set_account_id" , SetAccountId { index , new , } , [13u8 , 91u8 , 36u8 , 7u8 , 88u8 , 64u8 , 151u8 , 104u8 , 94u8 , 174u8 , 195u8 , 99u8 , 97u8 , 181u8 , 236u8 , 251u8 , 26u8 , 236u8 , 234u8 , 40u8 , 183u8 , 38u8 , 220u8 , 216u8 , 48u8 , 115u8 , 7u8 , 230u8 , 216u8 , 28u8 , 123u8 , 11u8 ,]) } # [doc = "Set the field information for a registrar."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must be the account"] # [doc = "of the registrar whose index is `index`."] # [doc = ""] # [doc = "- `index`: the index of the registrar whose fee is to be set."] # [doc = "- `fields`: the fields that the registrar concerns themselves with."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R)`."] # [doc = "- One storage mutation `O(R)`."] # [doc = "- Benchmark: 7.464 + R * 0.325 s (min squares analysis)"] # [doc = "# </weight>"] pub fn set_fields (& self , index : :: core :: primitive :: u32 , fields : runtime_types :: pallet_identity :: types :: BitFlags < runtime_types :: pallet_identity :: types :: IdentityField > ,) -> :: subxt :: tx :: StaticTxPayload < SetFields > { :: subxt :: tx :: StaticTxPayload :: new ("Identity" , "set_fields" , SetFields { index , fields , } , [50u8 , 196u8 , 179u8 , 71u8 , 66u8 , 65u8 , 235u8 , 7u8 , 51u8 , 14u8 , 81u8 , 173u8 , 201u8 , 58u8 , 6u8 , 151u8 , 174u8 , 245u8 , 102u8 , 184u8 , 28u8 , 84u8 , 125u8 , 93u8 , 126u8 , 134u8 , 92u8 , 203u8 , 200u8 , 129u8 , 240u8 , 252u8 ,]) } # [doc = "Provide a judgement for an account's identity."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must be the account"] # [doc = "of the registrar whose index is `reg_index`."] # [doc = ""] # [doc = "- `reg_index`: the index of the registrar whose judgement is being made."] # [doc = "- `target`: the account whose identity the judgement is upon. This must be an account"] # [doc = "  with a registered identity."] # [doc = "- `judgement`: the judgement of the registrar of index `reg_index` about `target`."] # [doc = "- `identity`: The hash of the [`IdentityInfo`] for that the judgement is provided."] # [doc = ""] # [doc = "Emits `JudgementGiven` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R + X)`."] # [doc = "- One balance-transfer operation."] # [doc = "- Up to one account-lookup operation."] # [doc = "- Storage: 1 read `O(R)`, 1 mutate `O(R + X)`."] # [doc = "- One event."] # [doc = "# </weight>"] pub fn provide_judgement (& self , reg_index : :: core :: primitive :: u32 , target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , judgement : runtime_types :: pallet_identity :: types :: Judgement < :: core :: primitive :: u128 > , identity : :: subxt :: ext :: sp_core :: H256 ,) -> :: subxt :: tx :: StaticTxPayload < ProvideJudgement > { :: subxt :: tx :: StaticTxPayload :: new ("Identity" , "provide_judgement" , ProvideJudgement { reg_index , target , judgement , identity , } , [147u8 , 66u8 , 29u8 , 90u8 , 149u8 , 65u8 , 161u8 , 115u8 , 12u8 , 254u8 , 188u8 , 248u8 , 165u8 , 115u8 , 191u8 , 2u8 , 167u8 , 223u8 , 199u8 , 169u8 , 203u8 , 64u8 , 101u8 , 217u8 , 73u8 , 185u8 , 93u8 , 109u8 , 22u8 , 184u8 , 146u8 , 73u8 ,]) } # [doc = "Remove an account's identity and sub-account information and slash the deposits."] # [doc = ""] # [doc = "Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by"] # [doc = "`Slash`. Verification request deposits are not returned; they should be cancelled"] # [doc = "manually using `cancel_request`."] # [doc = ""] # [doc = "The dispatch origin for this call must match `T::ForceOrigin`."] # [doc = ""] # [doc = "- `target`: the account whose identity the judgement is upon. This must be an account"] # [doc = "  with a registered identity."] # [doc = ""] # [doc = "Emits `IdentityKilled` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R + S + X)`."] # [doc = "- One balance-reserve operation."] # [doc = "- `S + 2` storage mutations."] # [doc = "- One event."] # [doc = "# </weight>"] pub fn kill_identity (& self , target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < KillIdentity > { :: subxt :: tx :: StaticTxPayload :: new ("Identity" , "kill_identity" , KillIdentity { target , } , [76u8 , 13u8 , 158u8 , 219u8 , 221u8 , 0u8 , 151u8 , 241u8 , 137u8 , 136u8 , 179u8 , 194u8 , 188u8 , 230u8 , 56u8 , 16u8 , 254u8 , 28u8 , 127u8 , 216u8 , 205u8 , 117u8 , 224u8 , 121u8 , 240u8 , 231u8 , 126u8 , 181u8 , 230u8 , 68u8 , 13u8 , 174u8 ,]) } # [doc = "Add the given account to the sender's subs."] # [doc = ""] # [doc = "Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated"] # [doc = "to the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "sub identity of `sub`."] pub fn add_sub (& self , sub : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , data : runtime_types :: pallet_identity :: types :: Data ,) -> :: subxt :: tx :: StaticTxPayload < AddSub > { :: subxt :: tx :: StaticTxPayload :: new ("Identity" , "add_sub" , AddSub { sub , data , } , [122u8 , 218u8 , 25u8 , 93u8 , 33u8 , 176u8 , 191u8 , 254u8 , 223u8 , 147u8 , 100u8 , 135u8 , 86u8 , 71u8 , 47u8 , 163u8 , 105u8 , 222u8 , 162u8 , 173u8 , 207u8 , 182u8 , 130u8 , 128u8 , 214u8 , 242u8 , 101u8 , 250u8 , 242u8 , 24u8 , 17u8 , 84u8 ,]) } # [doc = "Alter the associated name of the given sub-account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "sub identity of `sub`."] pub fn rename_sub (& self , sub : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , data : runtime_types :: pallet_identity :: types :: Data ,) -> :: subxt :: tx :: StaticTxPayload < RenameSub > { :: subxt :: tx :: StaticTxPayload :: new ("Identity" , "rename_sub" , RenameSub { sub , data , } , [166u8 , 167u8 , 49u8 , 114u8 , 199u8 , 168u8 , 187u8 , 221u8 , 100u8 , 85u8 , 147u8 , 211u8 , 157u8 , 31u8 , 109u8 , 135u8 , 194u8 , 135u8 , 15u8 , 89u8 , 59u8 , 57u8 , 252u8 , 163u8 , 9u8 , 138u8 , 216u8 , 189u8 , 177u8 , 42u8 , 96u8 , 34u8 ,]) } # [doc = "Remove the given account from the sender's subs."] # [doc = ""] # [doc = "Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated"] # [doc = "to the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "sub identity of `sub`."] pub fn remove_sub (& self , sub : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < RemoveSub > { :: subxt :: tx :: StaticTxPayload :: new ("Identity" , "remove_sub" , RemoveSub { sub , } , [106u8 , 223u8 , 210u8 , 67u8 , 54u8 , 11u8 , 144u8 , 222u8 , 42u8 , 46u8 , 157u8 , 33u8 , 13u8 , 245u8 , 166u8 , 195u8 , 227u8 , 81u8 , 224u8 , 149u8 , 154u8 , 158u8 , 187u8 , 203u8 , 215u8 , 91u8 , 43u8 , 105u8 , 69u8 , 213u8 , 141u8 , 124u8 ,]) } # [doc = "Remove the sender as a sub-account."] # [doc = ""] # [doc = "Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated"] # [doc = "to the sender (*not* the original depositor)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "super-identity."] # [doc = ""] # [doc = "NOTE: This should not normally be used, but is provided in the case that the non-"] # [doc = "controller of an account is maliciously registered as a sub-account."] pub fn quit_sub (& self ,) -> :: subxt :: tx :: StaticTxPayload < QuitSub > { :: subxt :: tx :: StaticTxPayload :: new ("Identity" , "quit_sub" , QuitSub { } , [62u8 , 57u8 , 73u8 , 72u8 , 119u8 , 216u8 , 250u8 , 155u8 , 57u8 , 169u8 , 157u8 , 44u8 , 87u8 , 51u8 , 63u8 , 231u8 , 77u8 , 7u8 , 0u8 , 119u8 , 244u8 , 42u8 , 179u8 , 51u8 , 254u8 , 240u8 , 55u8 , 25u8 , 142u8 , 38u8 , 87u8 , 44u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_identity :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A name was set or reset (which will remove all judgements)."] pub struct IdentitySet { pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for IdentitySet { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "IdentitySet" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A name was cleared, and the given balance returned."] pub struct IdentityCleared { pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub deposit : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for IdentityCleared { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "IdentityCleared" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A name was removed and the given balance slashed."] pub struct IdentityKilled { pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub deposit : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for IdentityKilled { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "IdentityKilled" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A judgement was asked from a registrar."] pub struct JudgementRequested { pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub registrar_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for JudgementRequested { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "JudgementRequested" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A judgement request was retracted."] pub struct JudgementUnrequested { pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub registrar_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for JudgementUnrequested { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "JudgementUnrequested" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A judgement was given by a registrar."] pub struct JudgementGiven { pub target : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub registrar_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for JudgementGiven { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "JudgementGiven" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A registrar was added."] pub struct RegistrarAdded { pub registrar_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for RegistrarAdded { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "RegistrarAdded" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A sub-identity was added to an identity and the deposit paid."] pub struct SubIdentityAdded { pub sub : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub main : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub deposit : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for SubIdentityAdded { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "SubIdentityAdded" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A sub-identity was removed from an identity and the deposit freed."] pub struct SubIdentityRemoved { pub sub : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub main : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub deposit : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for SubIdentityRemoved { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "SubIdentityRemoved" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A sub-identity was cleared, and the given deposit repatriated from the"] # [doc = "main identity account to the sub-identity account."] pub struct SubIdentityRevoked { pub sub : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub main : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub deposit : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for SubIdentityRevoked { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "SubIdentityRevoked" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Information that is pertinent to identify the entity behind an account."] # [doc = ""] # [doc = " TWOX-NOTE: OK  `AccountId` is a secure hash."] pub fn identity_of (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_identity :: types :: Registration < :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Identity" , "IdentityOf" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [193u8 , 195u8 , 180u8 , 188u8 , 129u8 , 250u8 , 180u8 , 219u8 , 22u8 , 95u8 , 175u8 , 170u8 , 143u8 , 188u8 , 80u8 , 124u8 , 234u8 , 228u8 , 245u8 , 39u8 , 72u8 , 153u8 , 107u8 , 199u8 , 23u8 , 75u8 , 47u8 , 247u8 , 104u8 , 208u8 , 171u8 , 82u8 ,]) } # [doc = " Information that is pertinent to identify the entity behind an account."] # [doc = ""] # [doc = " TWOX-NOTE: OK  `AccountId` is a secure hash."] pub fn identity_of_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_identity :: types :: Registration < :: core :: primitive :: u128 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Identity" , "IdentityOf" , Vec :: new () , [193u8 , 195u8 , 180u8 , 188u8 , 129u8 , 250u8 , 180u8 , 219u8 , 22u8 , 95u8 , 175u8 , 170u8 , 143u8 , 188u8 , 80u8 , 124u8 , 234u8 , 228u8 , 245u8 , 39u8 , 72u8 , 153u8 , 107u8 , 199u8 , 23u8 , 75u8 , 47u8 , 247u8 , 104u8 , 208u8 , 171u8 , 82u8 ,]) } # [doc = " The super-identity of an alternative \"sub\" identity together with its name, within that"] # [doc = " context. If the account is not some other account's sub-identity, then just `None`."] pub fn super_of (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_identity :: types :: Data ,) > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Identity" , "SuperOf" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [170u8 , 249u8 , 112u8 , 249u8 , 75u8 , 176u8 , 21u8 , 29u8 , 152u8 , 149u8 , 69u8 , 113u8 , 20u8 , 92u8 , 113u8 , 130u8 , 135u8 , 62u8 , 18u8 , 204u8 , 166u8 , 193u8 , 133u8 , 167u8 , 248u8 , 117u8 , 80u8 , 137u8 , 158u8 , 111u8 , 100u8 , 137u8 ,]) } # [doc = " The super-identity of an alternative \"sub\" identity together with its name, within that"] # [doc = " context. If the account is not some other account's sub-identity, then just `None`."] pub fn super_of_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_identity :: types :: Data ,) > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Identity" , "SuperOf" , Vec :: new () , [170u8 , 249u8 , 112u8 , 249u8 , 75u8 , 176u8 , 21u8 , 29u8 , 152u8 , 149u8 , 69u8 , 113u8 , 20u8 , 92u8 , 113u8 , 130u8 , 135u8 , 62u8 , 18u8 , 204u8 , 166u8 , 193u8 , 133u8 , 167u8 , 248u8 , 117u8 , 80u8 , 137u8 , 158u8 , 111u8 , 100u8 , 137u8 ,]) } # [doc = " Alternative \"sub\" identities of this account."] # [doc = ""] # [doc = " The first item is the deposit, the second is a vector of the accounts."] # [doc = ""] # [doc = " TWOX-NOTE: OK  `AccountId` is a secure hash."] pub fn subs_of (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: core :: primitive :: u128 , runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Identity" , "SubsOf" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Twox64Concat)] , [128u8 , 15u8 , 175u8 , 155u8 , 216u8 , 225u8 , 200u8 , 169u8 , 215u8 , 206u8 , 110u8 , 22u8 , 204u8 , 89u8 , 212u8 , 210u8 , 159u8 , 169u8 , 53u8 , 7u8 , 44u8 , 164u8 , 91u8 , 151u8 , 7u8 , 227u8 , 38u8 , 230u8 , 175u8 , 84u8 , 6u8 , 4u8 ,]) } # [doc = " Alternative \"sub\" identities of this account."] # [doc = ""] # [doc = " The first item is the deposit, the second is a vector of the accounts."] # [doc = ""] # [doc = " TWOX-NOTE: OK  `AccountId` is a secure hash."] pub fn subs_of_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < (:: core :: primitive :: u128 , runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Identity" , "SubsOf" , Vec :: new () , [128u8 , 15u8 , 175u8 , 155u8 , 216u8 , 225u8 , 200u8 , 169u8 , 215u8 , 206u8 , 110u8 , 22u8 , 204u8 , 89u8 , 212u8 , 210u8 , 159u8 , 169u8 , 53u8 , 7u8 , 44u8 , 164u8 , 91u8 , 151u8 , 7u8 , 227u8 , 38u8 , 230u8 , 175u8 , 84u8 , 6u8 , 4u8 ,]) } # [doc = " The set of registrars. Not expected to get very big as can only be added through a"] # [doc = " special origin (likely a council motion)."] # [doc = ""] # [doc = " The index into this can be cast to `RegistrarIndex` to get a valid value."] pub fn registrars (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: option :: Option < runtime_types :: pallet_identity :: types :: RegistrarInfo < :: core :: primitive :: u128 , :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Identity" , "Registrars" , vec ! [] , [157u8 , 87u8 , 39u8 , 240u8 , 154u8 , 54u8 , 241u8 , 229u8 , 76u8 , 9u8 , 62u8 , 252u8 , 40u8 , 143u8 , 186u8 , 182u8 , 233u8 , 187u8 , 251u8 , 61u8 , 236u8 , 229u8 , 19u8 , 55u8 , 42u8 , 36u8 , 82u8 , 173u8 , 215u8 , 155u8 , 229u8 , 111u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The amount held on deposit for a registered identity"] pub fn basic_deposit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Identity" , "BasicDeposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The amount held on deposit per additional field for a registered identity."] pub fn field_deposit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Identity" , "FieldDeposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The amount held on deposit for a registered subaccount. This should account for the fact"] # [doc = " that one storage item's value will increase by the size of an account ID, and there will"] # [doc = " be another trie item whose value is the size of an account ID plus 32 bytes."] pub fn sub_account_deposit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Identity" , "SubAccountDeposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The maximum number of sub-accounts allowed per identified account."] pub fn max_sub_accounts (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Identity" , "MaxSubAccounts" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Maximum number of additional fields that may be stored in an ID. Needed to bound the I/O"] # [doc = " required to access an identity, but can be pretty high."] pub fn max_additional_fields (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Identity" , "MaxAdditionalFields" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Maxmimum number of registrars allowed in the system. Needed to bound the complexity"] # [doc = " of, e.g., updating judgements."] pub fn max_registrars (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Identity" , "MaxRegistrars" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod nft { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CreateNft { pub offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , pub royalty : runtime_types :: sp_arithmetic :: per_things :: Permill , pub collection_id : :: core :: option :: Option < :: core :: primitive :: u32 > , pub is_soulbound : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct BurnNft { pub nft_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct TransferNft { pub nft_id : :: core :: primitive :: u32 , pub recipient : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct DelegateNft { pub nft_id : :: core :: primitive :: u32 , pub recipient : :: core :: option :: Option < :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetRoyalty { pub nft_id : :: core :: primitive :: u32 , pub royalty : runtime_types :: sp_arithmetic :: per_things :: Permill , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetNftMintFee { pub fee : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CreateCollection { pub offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , pub limit : :: core :: option :: Option < :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct BurnCollection { pub collection_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CloseCollection { pub collection_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct LimitCollection { pub collection_id : :: core :: primitive :: u32 , pub limit : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AddNftToCollection { pub nft_id : :: core :: primitive :: u32 , pub collection_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AddSecret { pub nft_id : :: core :: primitive :: u32 , pub offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CreateSecretNft { pub offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , pub secret_offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , pub royalty : runtime_types :: sp_arithmetic :: per_things :: Permill , pub collection_id : :: core :: option :: Option < :: core :: primitive :: u32 > , pub is_soulbound : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AddSecretShard { pub nft_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetSecretNftMintFee { pub fee : :: core :: primitive :: u128 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Create a new NFT with the provided details. An ID will be auto"] # [doc = "generated and logged as an event, The caller of this function"] # [doc = "will become the owner of the new NFT."] pub fn create_nft (& self , offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , royalty : runtime_types :: sp_arithmetic :: per_things :: Permill , collection_id : :: core :: option :: Option < :: core :: primitive :: u32 > , is_soulbound : :: core :: primitive :: bool ,) -> :: subxt :: tx :: StaticTxPayload < CreateNft > { :: subxt :: tx :: StaticTxPayload :: new ("NFT" , "create_nft" , CreateNft { offchain_data , royalty , collection_id , is_soulbound , } , [234u8 , 97u8 , 205u8 , 49u8 , 219u8 , 64u8 , 8u8 , 132u8 , 48u8 , 204u8 , 85u8 , 157u8 , 5u8 , 48u8 , 191u8 , 39u8 , 185u8 , 37u8 , 15u8 , 47u8 , 75u8 , 251u8 , 92u8 , 244u8 , 140u8 , 108u8 , 222u8 , 141u8 , 22u8 , 229u8 , 4u8 , 104u8 ,]) } # [doc = "Remove an NFT from the storage. This operation is irreversible which means"] # [doc = "once the NFT is removed (burned) from the storage there is no way to"] # [doc = "get it back."] # [doc = "Must be called by the owner of the NFT."] pub fn burn_nft (& self , nft_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < BurnNft > { :: subxt :: tx :: StaticTxPayload :: new ("NFT" , "burn_nft" , BurnNft { nft_id , } , [208u8 , 198u8 , 152u8 , 70u8 , 61u8 , 44u8 , 229u8 , 68u8 , 33u8 , 105u8 , 119u8 , 86u8 , 252u8 , 192u8 , 218u8 , 246u8 , 100u8 , 11u8 , 212u8 , 107u8 , 76u8 , 59u8 , 1u8 , 214u8 , 36u8 , 155u8 , 133u8 , 119u8 , 239u8 , 208u8 , 245u8 , 96u8 ,]) } # [doc = "Transfer an NFT from an account to another one. Must be called by the"] # [doc = "owner of the NFT."] pub fn transfer_nft (& self , nft_id : :: core :: primitive :: u32 , recipient : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < TransferNft > { :: subxt :: tx :: StaticTxPayload :: new ("NFT" , "transfer_nft" , TransferNft { nft_id , recipient , } , [99u8 , 83u8 , 20u8 , 201u8 , 189u8 , 27u8 , 21u8 , 13u8 , 128u8 , 12u8 , 98u8 , 7u8 , 40u8 , 108u8 , 13u8 , 7u8 , 113u8 , 179u8 , 26u8 , 196u8 , 220u8 , 227u8 , 21u8 , 136u8 , 240u8 , 13u8 , 174u8 , 128u8 , 244u8 , 35u8 , 30u8 , 8u8 ,]) } # [doc = "Delegate an NFT to a recipient, does not change ownership."] # [doc = "Must be called by NFT owner."] pub fn delegate_nft (& self , nft_id : :: core :: primitive :: u32 , recipient : :: core :: option :: Option < :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > > ,) -> :: subxt :: tx :: StaticTxPayload < DelegateNft > { :: subxt :: tx :: StaticTxPayload :: new ("NFT" , "delegate_nft" , DelegateNft { nft_id , recipient , } , [22u8 , 232u8 , 55u8 , 137u8 , 6u8 , 76u8 , 55u8 , 96u8 , 55u8 , 135u8 , 45u8 , 138u8 , 128u8 , 96u8 , 195u8 , 17u8 , 184u8 , 191u8 , 47u8 , 203u8 , 85u8 , 166u8 , 64u8 , 90u8 , 107u8 , 90u8 , 14u8 , 70u8 , 177u8 , 238u8 , 57u8 , 213u8 ,]) } # [doc = "Set the royalty of an NFT."] # [doc = "Can only be called if the NFT is owned and has been created by the caller."] pub fn set_royalty (& self , nft_id : :: core :: primitive :: u32 , royalty : runtime_types :: sp_arithmetic :: per_things :: Permill ,) -> :: subxt :: tx :: StaticTxPayload < SetRoyalty > { :: subxt :: tx :: StaticTxPayload :: new ("NFT" , "set_royalty" , SetRoyalty { nft_id , royalty , } , [222u8 , 195u8 , 148u8 , 65u8 , 118u8 , 86u8 , 8u8 , 127u8 , 19u8 , 226u8 , 41u8 , 243u8 , 228u8 , 58u8 , 58u8 , 142u8 , 143u8 , 12u8 , 120u8 , 141u8 , 252u8 , 39u8 , 115u8 , 247u8 , 233u8 , 41u8 , 220u8 , 185u8 , 174u8 , 245u8 , 247u8 , 108u8 ,]) } # [doc = "Set the fee for minting an NFT if the caller is root."] pub fn set_nft_mint_fee (& self , fee : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < SetNftMintFee > { :: subxt :: tx :: StaticTxPayload :: new ("NFT" , "set_nft_mint_fee" , SetNftMintFee { fee , } , [164u8 , 196u8 , 50u8 , 102u8 , 40u8 , 176u8 , 140u8 , 15u8 , 75u8 , 95u8 , 22u8 , 203u8 , 68u8 , 68u8 , 45u8 , 148u8 , 221u8 , 238u8 , 174u8 , 102u8 , 113u8 , 19u8 , 153u8 , 66u8 , 201u8 , 148u8 , 190u8 , 252u8 , 119u8 , 197u8 , 220u8 , 53u8 ,]) } # [doc = "Create a new collection with the provided details. An ID will be auto"] # [doc = "generated and logged as an event, the caller of this function"] # [doc = "will become the owner of the new collection."] pub fn create_collection (& self , offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , limit : :: core :: option :: Option < :: core :: primitive :: u32 > ,) -> :: subxt :: tx :: StaticTxPayload < CreateCollection > { :: subxt :: tx :: StaticTxPayload :: new ("NFT" , "create_collection" , CreateCollection { offchain_data , limit , } , [23u8 , 119u8 , 169u8 , 49u8 , 243u8 , 184u8 , 25u8 , 33u8 , 39u8 , 229u8 , 163u8 , 235u8 , 184u8 , 24u8 , 77u8 , 255u8 , 7u8 , 216u8 , 218u8 , 74u8 , 213u8 , 250u8 , 71u8 , 182u8 , 148u8 , 137u8 , 221u8 , 12u8 , 81u8 , 184u8 , 183u8 , 109u8 ,]) } # [doc = "Remove a collection from the storage. This operation is irreversible which means"] # [doc = "once the collection is removed (burned) from the storage there is no way to"] # [doc = "get it back."] # [doc = "Must be called by the owner of the collection and collection must be empty."] pub fn burn_collection (& self , collection_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < BurnCollection > { :: subxt :: tx :: StaticTxPayload :: new ("NFT" , "burn_collection" , BurnCollection { collection_id , } , [174u8 , 197u8 , 81u8 , 244u8 , 113u8 , 244u8 , 66u8 , 60u8 , 107u8 , 241u8 , 17u8 , 250u8 , 181u8 , 211u8 , 34u8 , 82u8 , 154u8 , 148u8 , 120u8 , 90u8 , 186u8 , 236u8 , 12u8 , 120u8 , 43u8 , 91u8 , 241u8 , 149u8 , 246u8 , 194u8 , 134u8 , 96u8 ,]) } # [doc = "Makes the collection closed. This means that it is not anymore"] # [doc = "possible to add new NFTs to the collection."] # [doc = "Can only be called by owner of the collection."] pub fn close_collection (& self , collection_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < CloseCollection > { :: subxt :: tx :: StaticTxPayload :: new ("NFT" , "close_collection" , CloseCollection { collection_id , } , [238u8 , 55u8 , 22u8 , 102u8 , 63u8 , 214u8 , 76u8 , 184u8 , 147u8 , 83u8 , 75u8 , 240u8 , 12u8 , 55u8 , 153u8 , 170u8 , 83u8 , 55u8 , 114u8 , 123u8 , 49u8 , 240u8 , 0u8 , 108u8 , 136u8 , 99u8 , 253u8 , 103u8 , 86u8 , 251u8 , 147u8 , 233u8 ,]) } # [doc = "Set the maximum amount of nfts in the collection."] # [doc = "Caller must be owner of collection, nfts in that collection must be lower or equal to"] # [doc = "new limit."] pub fn limit_collection (& self , collection_id : :: core :: primitive :: u32 , limit : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < LimitCollection > { :: subxt :: tx :: StaticTxPayload :: new ("NFT" , "limit_collection" , LimitCollection { collection_id , limit , } , [110u8 , 158u8 , 125u8 , 53u8 , 81u8 , 159u8 , 125u8 , 221u8 , 2u8 , 124u8 , 249u8 , 51u8 , 115u8 , 2u8 , 149u8 , 46u8 , 245u8 , 185u8 , 225u8 , 250u8 , 167u8 , 230u8 , 22u8 , 40u8 , 253u8 , 103u8 , 212u8 , 240u8 , 231u8 , 208u8 , 242u8 , 95u8 ,]) } # [doc = "Add an NFT to a collection."] # [doc = "Can only be called by owner of the collection, NFT"] # [doc = "must not be in collection and collection must not be closed or has reached limit."] pub fn add_nft_to_collection (& self , nft_id : :: core :: primitive :: u32 , collection_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < AddNftToCollection > { :: subxt :: tx :: StaticTxPayload :: new ("NFT" , "add_nft_to_collection" , AddNftToCollection { nft_id , collection_id , } , [133u8 , 234u8 , 13u8 , 120u8 , 213u8 , 255u8 , 51u8 , 96u8 , 193u8 , 224u8 , 70u8 , 171u8 , 77u8 , 245u8 , 17u8 , 49u8 , 139u8 , 150u8 , 44u8 , 246u8 , 187u8 , 163u8 , 213u8 , 47u8 , 86u8 , 98u8 , 194u8 , 20u8 , 226u8 , 221u8 , 187u8 , 104u8 ,]) } # [doc = "Add a secret to a basic NFT."] # [doc = "Must be called by NFT owner."] pub fn add_secret (& self , nft_id : :: core :: primitive :: u32 , offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: StaticTxPayload < AddSecret > { :: subxt :: tx :: StaticTxPayload :: new ("NFT" , "add_secret" , AddSecret { nft_id , offchain_data , } , [18u8 , 109u8 , 135u8 , 53u8 , 26u8 , 141u8 , 13u8 , 65u8 , 10u8 , 75u8 , 131u8 , 125u8 , 47u8 , 187u8 , 171u8 , 7u8 , 68u8 , 252u8 , 128u8 , 222u8 , 251u8 , 80u8 , 22u8 , 143u8 , 4u8 , 228u8 , 23u8 , 53u8 , 142u8 , 189u8 , 65u8 , 131u8 ,]) } # [doc = "Create a new secret NFT with the provided details. An ID will be auto"] # [doc = "generated and logged as an event, The caller of this function"] # [doc = "will become the owner of the new NFT."] pub fn create_secret_nft (& self , offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , secret_offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , royalty : runtime_types :: sp_arithmetic :: per_things :: Permill , collection_id : :: core :: option :: Option < :: core :: primitive :: u32 > , is_soulbound : :: core :: primitive :: bool ,) -> :: subxt :: tx :: StaticTxPayload < CreateSecretNft > { :: subxt :: tx :: StaticTxPayload :: new ("NFT" , "create_secret_nft" , CreateSecretNft { offchain_data , secret_offchain_data , royalty , collection_id , is_soulbound , } , [81u8 , 116u8 , 202u8 , 73u8 , 132u8 , 229u8 , 124u8 , 79u8 , 120u8 , 230u8 , 130u8 , 122u8 , 28u8 , 212u8 , 128u8 , 127u8 , 252u8 , 172u8 , 216u8 , 174u8 , 139u8 , 43u8 , 71u8 , 252u8 , 140u8 , 90u8 , 99u8 , 129u8 , 5u8 , 84u8 , 67u8 , 7u8 ,]) } # [doc = "Extrinsic called by TEE enclaves to indicate that a shard was received."] # [doc = "Must be called by registered enclaves."] pub fn add_secret_shard (& self , nft_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < AddSecretShard > { :: subxt :: tx :: StaticTxPayload :: new ("NFT" , "add_secret_shard" , AddSecretShard { nft_id , } , [70u8 , 5u8 , 44u8 , 1u8 , 29u8 , 143u8 , 200u8 , 219u8 , 201u8 , 106u8 , 74u8 , 255u8 , 223u8 , 21u8 , 165u8 , 151u8 , 11u8 , 147u8 , 251u8 , 0u8 , 236u8 , 36u8 , 159u8 , 56u8 , 171u8 , 104u8 , 158u8 , 150u8 , 16u8 , 98u8 , 23u8 , 144u8 ,]) } # [doc = "Set the fee for minting a secret NFT if the caller is root."] pub fn set_secret_nft_mint_fee (& self , fee : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < SetSecretNftMintFee > { :: subxt :: tx :: StaticTxPayload :: new ("NFT" , "set_secret_nft_mint_fee" , SetSecretNftMintFee { fee , } , [179u8 , 35u8 , 246u8 , 116u8 , 9u8 , 208u8 , 198u8 , 178u8 , 166u8 , 53u8 , 222u8 , 69u8 , 34u8 , 135u8 , 162u8 , 213u8 , 222u8 , 165u8 , 199u8 , 141u8 , 133u8 , 156u8 , 121u8 , 187u8 , 45u8 , 34u8 , 29u8 , 236u8 , 242u8 , 69u8 , 32u8 , 67u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: ternoa_nft :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A new NFT was created."] pub struct NFTCreated { pub nft_id : :: core :: primitive :: u32 , pub owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , pub royalty : runtime_types :: sp_arithmetic :: per_things :: Permill , pub collection_id : :: core :: option :: Option < :: core :: primitive :: u32 > , pub is_soulbound : :: core :: primitive :: bool , pub mint_fee : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for NFTCreated { const PALLET : & 'static str = "NFT" ; const EVENT : & 'static str = "NFTCreated" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An NFT was burned."] pub struct NFTBurned { pub nft_id : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for NFTBurned { const PALLET : & 'static str = "NFT" ; const EVENT : & 'static str = "NFTBurned" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An NFT was transferred to someone else."] pub struct NFTTransferred { pub nft_id : :: core :: primitive :: u32 , pub sender : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub recipient : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for NFTTransferred { const PALLET : & 'static str = "NFT" ; const EVENT : & 'static str = "NFTTransferred" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An NFT was delegated to someone else."] pub struct NFTDelegated { pub nft_id : :: core :: primitive :: u32 , pub recipient : :: core :: option :: Option < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } impl :: subxt :: events :: StaticEvent for NFTDelegated { const PALLET : & 'static str = "NFT" ; const EVENT : & 'static str = "NFTDelegated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Royalty has been changed for an NFT."] pub struct NFTRoyaltySet { pub nft_id : :: core :: primitive :: u32 , pub royalty : runtime_types :: sp_arithmetic :: per_things :: Permill , } impl :: subxt :: events :: StaticEvent for NFTRoyaltySet { const PALLET : & 'static str = "NFT" ; const EVENT : & 'static str = "NFTRoyaltySet" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "NFT mint fee changed."] pub struct NFTMintFeeSet { pub fee : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for NFTMintFeeSet { const PALLET : & 'static str = "NFT" ; const EVENT : & 'static str = "NFTMintFeeSet" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A collection was created."] pub struct CollectionCreated { pub collection_id : :: core :: primitive :: u32 , pub owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , pub limit : :: core :: option :: Option < :: core :: primitive :: u32 > , } impl :: subxt :: events :: StaticEvent for CollectionCreated { const PALLET : & 'static str = "NFT" ; const EVENT : & 'static str = "CollectionCreated" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A collection was burned."] pub struct CollectionBurned { pub collection_id : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for CollectionBurned { const PALLET : & 'static str = "NFT" ; const EVENT : & 'static str = "CollectionBurned" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A collection was closed."] pub struct CollectionClosed { pub collection_id : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for CollectionClosed { const PALLET : & 'static str = "NFT" ; const EVENT : & 'static str = "CollectionClosed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A collection has limit set."] pub struct CollectionLimited { pub collection_id : :: core :: primitive :: u32 , pub limit : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for CollectionLimited { const PALLET : & 'static str = "NFT" ; const EVENT : & 'static str = "CollectionLimited" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An NFT has been added to a collection."] pub struct NFTAddedToCollection { pub nft_id : :: core :: primitive :: u32 , pub collection_id : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for NFTAddedToCollection { const PALLET : & 'static str = "NFT" ; const EVENT : & 'static str = "NFTAddedToCollection" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A secret was added to a basic NFT."] pub struct SecretAddedToNFT { pub nft_id : :: core :: primitive :: u32 , pub offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , } impl :: subxt :: events :: StaticEvent for SecretAddedToNFT { const PALLET : & 'static str = "NFT" ; const EVENT : & 'static str = "SecretAddedToNFT" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A shard was added for a secret NFT."] pub struct ShardAdded { pub nft_id : :: core :: primitive :: u32 , pub enclave : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for ShardAdded { const PALLET : & 'static str = "NFT" ; const EVENT : & 'static str = "ShardAdded" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A secret NFT has finished syncing shards."] pub struct SecretNFTSynced { pub nft_id : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for SecretNFTSynced { const PALLET : & 'static str = "NFT" ; const EVENT : & 'static str = "SecretNFTSynced" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Secret NFT mint fee changed."] pub struct SecretNFTMintFeeSet { pub fee : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for SecretNFTMintFeeSet { const PALLET : & 'static str = "NFT" ; const EVENT : & 'static str = "SecretNFTMintFeeSet" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " How much does it cost to mint a NFT (extra fee on top of the tx fees)."] pub fn nft_mint_fee (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("NFT" , "NftMintFee" , vec ! [] , [178u8 , 115u8 , 6u8 , 207u8 , 228u8 , 173u8 , 10u8 , 75u8 , 172u8 , 231u8 , 154u8 , 58u8 , 99u8 , 120u8 , 229u8 , 95u8 , 181u8 , 207u8 , 55u8 , 114u8 , 192u8 , 89u8 , 175u8 , 173u8 , 208u8 , 170u8 , 150u8 , 33u8 , 98u8 , 93u8 , 156u8 , 10u8 ,]) } # [doc = " Counter for NFT ids."] pub fn next_nft_id (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("NFT" , "NextNFTId" , vec ! [] , [213u8 , 76u8 , 82u8 , 141u8 , 211u8 , 18u8 , 165u8 , 249u8 , 202u8 , 212u8 , 86u8 , 218u8 , 211u8 , 203u8 , 158u8 , 192u8 , 46u8 , 246u8 , 173u8 , 184u8 , 171u8 , 76u8 , 238u8 , 243u8 , 34u8 , 7u8 , 103u8 , 163u8 , 6u8 , 11u8 , 164u8 , 147u8 ,]) } # [doc = " Counter for collection ids."] pub fn next_collection_id (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("NFT" , "NextCollectionId" , vec ! [] , [115u8 , 105u8 , 45u8 , 229u8 , 88u8 , 104u8 , 57u8 , 99u8 , 228u8 , 134u8 , 188u8 , 143u8 , 58u8 , 165u8 , 147u8 , 189u8 , 246u8 , 239u8 , 193u8 , 181u8 , 102u8 , 24u8 , 179u8 , 63u8 , 209u8 , 217u8 , 170u8 , 178u8 , 94u8 , 169u8 , 239u8 , 195u8 ,]) } # [doc = " Data related to NFTs."] pub fn nfts (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_pallets_primitives :: nfts :: NFTData < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("NFT" , "Nfts" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [251u8 , 148u8 , 230u8 , 9u8 , 23u8 , 158u8 , 121u8 , 203u8 , 132u8 , 125u8 , 105u8 , 183u8 , 93u8 , 76u8 , 161u8 , 31u8 , 138u8 , 79u8 , 26u8 , 26u8 , 166u8 , 177u8 , 150u8 , 1u8 , 127u8 , 40u8 , 118u8 , 236u8 , 123u8 , 158u8 , 62u8 , 235u8 ,]) } # [doc = " Data related to NFTs."] pub fn nfts_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_pallets_primitives :: nfts :: NFTData < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("NFT" , "Nfts" , Vec :: new () , [251u8 , 148u8 , 230u8 , 9u8 , 23u8 , 158u8 , 121u8 , 203u8 , 132u8 , 125u8 , 105u8 , 183u8 , 93u8 , 76u8 , 161u8 , 31u8 , 138u8 , 79u8 , 26u8 , 26u8 , 166u8 , 177u8 , 150u8 , 1u8 , 127u8 , 40u8 , 118u8 , 236u8 , 123u8 , 158u8 , 62u8 , 235u8 ,]) } # [doc = " Data related to collections."] pub fn collections (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_pallets_primitives :: nfts :: Collection < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("NFT" , "Collections" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [106u8 , 155u8 , 79u8 , 192u8 , 128u8 , 132u8 , 229u8 , 56u8 , 5u8 , 164u8 , 229u8 , 32u8 , 205u8 , 56u8 , 30u8 , 116u8 , 206u8 , 200u8 , 146u8 , 122u8 , 138u8 , 114u8 , 230u8 , 57u8 , 92u8 , 165u8 , 103u8 , 191u8 , 255u8 , 129u8 , 119u8 , 130u8 ,]) } # [doc = " Data related to collections."] pub fn collections_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_pallets_primitives :: nfts :: Collection < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("NFT" , "Collections" , Vec :: new () , [106u8 , 155u8 , 79u8 , 192u8 , 128u8 , 132u8 , 229u8 , 56u8 , 5u8 , 164u8 , 229u8 , 32u8 , 205u8 , 56u8 , 30u8 , 116u8 , 206u8 , 200u8 , 146u8 , 122u8 , 138u8 , 114u8 , 230u8 , 57u8 , 92u8 , 165u8 , 103u8 , 191u8 , 255u8 , 129u8 , 119u8 , 130u8 ,]) } # [doc = " Host a map of delegated NFTs and the recipient."] pub fn delegated_nf_ts (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("NFT" , "DelegatedNFTs" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [29u8 , 19u8 , 173u8 , 162u8 , 86u8 , 185u8 , 26u8 , 130u8 , 189u8 , 228u8 , 70u8 , 31u8 , 136u8 , 204u8 , 122u8 , 26u8 , 65u8 , 137u8 , 74u8 , 157u8 , 93u8 , 62u8 , 97u8 , 67u8 , 22u8 , 220u8 , 219u8 , 221u8 , 130u8 , 193u8 , 35u8 , 154u8 ,]) } # [doc = " Host a map of delegated NFTs and the recipient."] pub fn delegated_nf_ts_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("NFT" , "DelegatedNFTs" , Vec :: new () , [29u8 , 19u8 , 173u8 , 162u8 , 86u8 , 185u8 , 26u8 , 130u8 , 189u8 , 228u8 , 70u8 , 31u8 , 136u8 , 204u8 , 122u8 , 26u8 , 65u8 , 137u8 , 74u8 , 157u8 , 93u8 , 62u8 , 97u8 , 67u8 , 22u8 , 220u8 , 219u8 , 221u8 , 130u8 , 193u8 , 35u8 , 154u8 ,]) } # [doc = " How much does it cost to mint a secret NFT (extra fee on top of the tx fees and basic NFT"] # [doc = " fee)."] pub fn secret_nft_mint_fee (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("NFT" , "SecretNftMintFee" , vec ! [] , [17u8 , 86u8 , 22u8 , 26u8 , 10u8 , 246u8 , 162u8 , 65u8 , 185u8 , 123u8 , 19u8 , 67u8 , 95u8 , 6u8 , 4u8 , 47u8 , 147u8 , 96u8 , 89u8 , 195u8 , 93u8 , 153u8 , 197u8 , 8u8 , 253u8 , 149u8 , 135u8 , 145u8 , 16u8 , 30u8 , 185u8 , 146u8 ,]) } # [doc = " Host a map of secret NFTs and their secret_offchain_data."] pub fn secret_nfts_offchain_data (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("NFT" , "SecretNftsOffchainData" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [68u8 , 178u8 , 71u8 , 236u8 , 214u8 , 129u8 , 186u8 , 68u8 , 57u8 , 169u8 , 162u8 , 20u8 , 196u8 , 61u8 , 37u8 , 46u8 , 255u8 , 222u8 , 146u8 , 100u8 , 139u8 , 87u8 , 103u8 , 8u8 , 24u8 , 237u8 , 9u8 , 29u8 , 114u8 , 150u8 , 24u8 , 122u8 ,]) } # [doc = " Host a map of secret NFTs and their secret_offchain_data."] pub fn secret_nfts_offchain_data_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("NFT" , "SecretNftsOffchainData" , Vec :: new () , [68u8 , 178u8 , 71u8 , 236u8 , 214u8 , 129u8 , 186u8 , 68u8 , 57u8 , 169u8 , 162u8 , 20u8 , 196u8 , 61u8 , 37u8 , 46u8 , 255u8 , 222u8 , 146u8 , 100u8 , 139u8 , 87u8 , 103u8 , 8u8 , 24u8 , 237u8 , 9u8 , 29u8 , 114u8 , 150u8 , 24u8 , 122u8 ,]) } # [doc = " Host a map of secret NFTs and a vector of enclave addresses that sent a shard."] pub fn secret_nfts_shards_count (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("NFT" , "SecretNftsShardsCount" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [96u8 , 230u8 , 125u8 , 203u8 , 151u8 , 186u8 , 176u8 , 24u8 , 175u8 , 103u8 , 226u8 , 29u8 , 228u8 , 190u8 , 151u8 , 165u8 , 69u8 , 140u8 , 176u8 , 226u8 , 172u8 , 44u8 , 106u8 , 159u8 , 187u8 , 199u8 , 244u8 , 196u8 , 239u8 , 29u8 , 118u8 , 191u8 ,]) } # [doc = " Host a map of secret NFTs and a vector of enclave addresses that sent a shard."] pub fn secret_nfts_shards_count_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("NFT" , "SecretNftsShardsCount" , Vec :: new () , [96u8 , 230u8 , 125u8 , 203u8 , 151u8 , 186u8 , 176u8 , 24u8 , 175u8 , 103u8 , 226u8 , 29u8 , 228u8 , 190u8 , 151u8 , 165u8 , 69u8 , 140u8 , 176u8 , 226u8 , 172u8 , 44u8 , 106u8 , 159u8 , 187u8 , 199u8 , 244u8 , 196u8 , 239u8 , 29u8 , 118u8 , 191u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Default fee for minting NFTs."] pub fn initial_mint_fee (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("NFT" , "InitialMintFee" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " Maximum offchain data length."] pub fn nft_offchain_data_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("NFT" , "NFTOffchainDataLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Maximum collection length."] pub fn collection_size_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("NFT" , "CollectionSizeLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Maximum collection offchain data length."] pub fn collection_offchain_data_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("NFT" , "CollectionOffchainDataLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Default fee for minting secret NFTs."] pub fn initial_secret_mint_fee (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("NFT" , "InitialSecretMintFee" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The number of necessary shards to consider the Secret NFT valid."] pub fn shards_number (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("NFT" , "ShardsNumber" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod marketplace { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CreateMarketplace { pub kind : runtime_types :: ternoa_pallets_primitives :: marketplace :: MarketplaceType , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetMarketplaceOwner { pub marketplace_id : :: core :: primitive :: u32 , pub recipient : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetMarketplaceKind { pub marketplace_id : :: core :: primitive :: u32 , pub kind : runtime_types :: ternoa_pallets_primitives :: marketplace :: MarketplaceType , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetMarketplaceConfiguration { pub marketplace_id : :: core :: primitive :: u32 , pub commission_fee : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: ternoa_pallets_primitives :: common :: CompoundFee < :: core :: primitive :: u128 > > , pub listing_fee : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: ternoa_pallets_primitives :: common :: CompoundFee < :: core :: primitive :: u128 > > , pub account_list : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , pub offchain_data : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > , pub collection_list : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > > , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetMarketplaceMintFee { pub fee : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ListNft { pub nft_id : :: core :: primitive :: u32 , pub marketplace_id : :: core :: primitive :: u32 , pub price : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct UnlistNft { pub nft_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct BuyNft { pub nft_id : :: core :: primitive :: u32 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Create a new marketplace with the provided details. An ID will be auto"] # [doc = "generated and logged as an event, The caller of this function"] # [doc = "will become the owner of the new marketplace."] pub fn create_marketplace (& self , kind : runtime_types :: ternoa_pallets_primitives :: marketplace :: MarketplaceType ,) -> :: subxt :: tx :: StaticTxPayload < CreateMarketplace > { :: subxt :: tx :: StaticTxPayload :: new ("Marketplace" , "create_marketplace" , CreateMarketplace { kind , } , [192u8 , 186u8 , 150u8 , 94u8 , 10u8 , 29u8 , 90u8 , 1u8 , 135u8 , 115u8 , 221u8 , 246u8 , 15u8 , 252u8 , 13u8 , 90u8 , 203u8 , 66u8 , 145u8 , 157u8 , 190u8 , 181u8 , 155u8 , 111u8 , 89u8 , 226u8 , 127u8 , 144u8 , 50u8 , 238u8 , 80u8 , 87u8 ,]) } # [doc = "Transfer the ownership of the marketplace to the recipient. Must be called by the"] # [doc = "owner of the marketplace."] pub fn set_marketplace_owner (& self , marketplace_id : :: core :: primitive :: u32 , recipient : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < SetMarketplaceOwner > { :: subxt :: tx :: StaticTxPayload :: new ("Marketplace" , "set_marketplace_owner" , SetMarketplaceOwner { marketplace_id , recipient , } , [144u8 , 84u8 , 47u8 , 64u8 , 16u8 , 111u8 , 153u8 , 196u8 , 234u8 , 1u8 , 92u8 , 248u8 , 45u8 , 55u8 , 212u8 , 49u8 , 215u8 , 24u8 , 51u8 , 122u8 , 52u8 , 190u8 , 238u8 , 236u8 , 123u8 , 91u8 , 172u8 , 112u8 , 18u8 , 184u8 , 188u8 , 243u8 ,]) } # [doc = "Change the kind of the marketplace, can be private or public."] # [doc = "Must be called by the owner of the marketplace."] pub fn set_marketplace_kind (& self , marketplace_id : :: core :: primitive :: u32 , kind : runtime_types :: ternoa_pallets_primitives :: marketplace :: MarketplaceType ,) -> :: subxt :: tx :: StaticTxPayload < SetMarketplaceKind > { :: subxt :: tx :: StaticTxPayload :: new ("Marketplace" , "set_marketplace_kind" , SetMarketplaceKind { marketplace_id , kind , } , [237u8 , 72u8 , 6u8 , 185u8 , 112u8 , 133u8 , 53u8 , 6u8 , 152u8 , 18u8 , 252u8 , 32u8 , 20u8 , 194u8 , 194u8 , 100u8 , 255u8 , 32u8 , 26u8 , 221u8 , 22u8 , 169u8 , 198u8 , 221u8 , 51u8 , 104u8 , 198u8 , 18u8 , 213u8 , 230u8 , 168u8 , 9u8 ,]) } # [doc = "Set the configuration parameters of the marketplace (eg. commission_fee, listing_fee,"] # [doc = "account_list, offchain_data). Must be called by the owner of the marketplace."] pub fn set_marketplace_configuration (& self , marketplace_id : :: core :: primitive :: u32 , commission_fee : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: ternoa_pallets_primitives :: common :: CompoundFee < :: core :: primitive :: u128 > > , listing_fee : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: ternoa_pallets_primitives :: common :: CompoundFee < :: core :: primitive :: u128 > > , account_list : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , offchain_data : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > , collection_list : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > > ,) -> :: subxt :: tx :: StaticTxPayload < SetMarketplaceConfiguration > { :: subxt :: tx :: StaticTxPayload :: new ("Marketplace" , "set_marketplace_configuration" , SetMarketplaceConfiguration { marketplace_id , commission_fee , listing_fee , account_list , offchain_data , collection_list , } , [125u8 , 233u8 , 120u8 , 64u8 , 197u8 , 254u8 , 158u8 , 79u8 , 121u8 , 183u8 , 59u8 , 80u8 , 99u8 , 7u8 , 57u8 , 192u8 , 5u8 , 192u8 , 98u8 , 12u8 , 169u8 , 172u8 , 75u8 , 191u8 , 145u8 , 71u8 , 29u8 , 87u8 , 97u8 , 165u8 , 216u8 , 194u8 ,]) } # [doc = "Sets the marketplace mint fee. Can only be called by Root."] pub fn set_marketplace_mint_fee (& self , fee : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < SetMarketplaceMintFee > { :: subxt :: tx :: StaticTxPayload :: new ("Marketplace" , "set_marketplace_mint_fee" , SetMarketplaceMintFee { fee , } , [169u8 , 201u8 , 80u8 , 93u8 , 81u8 , 209u8 , 91u8 , 91u8 , 203u8 , 136u8 , 164u8 , 147u8 , 124u8 , 243u8 , 165u8 , 242u8 , 136u8 , 164u8 , 113u8 , 185u8 , 118u8 , 140u8 , 26u8 , 208u8 , 112u8 , 95u8 , 32u8 , 220u8 , 54u8 , 74u8 , 149u8 , 216u8 ,]) } # [doc = "Put an NFT on sale on a marketplace."] pub fn list_nft (& self , nft_id : :: core :: primitive :: u32 , marketplace_id : :: core :: primitive :: u32 , price : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < ListNft > { :: subxt :: tx :: StaticTxPayload :: new ("Marketplace" , "list_nft" , ListNft { nft_id , marketplace_id , price , } , [129u8 , 247u8 , 42u8 , 222u8 , 27u8 , 194u8 , 85u8 , 194u8 , 154u8 , 148u8 , 129u8 , 34u8 , 35u8 , 26u8 , 121u8 , 188u8 , 245u8 , 184u8 , 59u8 , 170u8 , 225u8 , 223u8 , 109u8 , 9u8 , 35u8 , 53u8 , 72u8 , 109u8 , 134u8 , 205u8 , 73u8 , 159u8 ,]) } # [doc = "Remove an NFT from sale."] pub fn unlist_nft (& self , nft_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < UnlistNft > { :: subxt :: tx :: StaticTxPayload :: new ("Marketplace" , "unlist_nft" , UnlistNft { nft_id , } , [158u8 , 5u8 , 20u8 , 35u8 , 248u8 , 11u8 , 157u8 , 123u8 , 164u8 , 100u8 , 169u8 , 125u8 , 184u8 , 19u8 , 41u8 , 44u8 , 251u8 , 242u8 , 197u8 , 189u8 , 250u8 , 209u8 , 150u8 , 37u8 , 75u8 , 192u8 , 64u8 , 32u8 , 52u8 , 117u8 , 50u8 , 209u8 ,]) } # [doc = "Buy a listed nft"] pub fn buy_nft (& self , nft_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < BuyNft > { :: subxt :: tx :: StaticTxPayload :: new ("Marketplace" , "buy_nft" , BuyNft { nft_id , } , [229u8 , 194u8 , 1u8 , 149u8 , 244u8 , 5u8 , 105u8 , 226u8 , 217u8 , 83u8 , 242u8 , 236u8 , 7u8 , 113u8 , 106u8 , 76u8 , 220u8 , 9u8 , 105u8 , 161u8 , 200u8 , 171u8 , 216u8 , 6u8 , 186u8 , 171u8 , 213u8 , 237u8 , 214u8 , 96u8 , 32u8 , 75u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: ternoa_marketplace :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Marketplace created"] pub struct MarketplaceCreated { pub marketplace_id : :: core :: primitive :: u32 , pub owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub kind : runtime_types :: ternoa_pallets_primitives :: marketplace :: MarketplaceType , } impl :: subxt :: events :: StaticEvent for MarketplaceCreated { const PALLET : & 'static str = "Marketplace" ; const EVENT : & 'static str = "MarketplaceCreated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Marketplace owner set"] pub struct MarketplaceOwnerSet { pub marketplace_id : :: core :: primitive :: u32 , pub owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for MarketplaceOwnerSet { const PALLET : & 'static str = "Marketplace" ; const EVENT : & 'static str = "MarketplaceOwnerSet" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Marketplace kind set"] pub struct MarketplaceKindSet { pub marketplace_id : :: core :: primitive :: u32 , pub kind : runtime_types :: ternoa_pallets_primitives :: marketplace :: MarketplaceType , } impl :: subxt :: events :: StaticEvent for MarketplaceKindSet { const PALLET : & 'static str = "Marketplace" ; const EVENT : & 'static str = "MarketplaceKindSet" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Marketplace config set"] pub struct MarketplaceConfigSet { pub marketplace_id : :: core :: primitive :: u32 , pub commission_fee : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: ternoa_pallets_primitives :: common :: CompoundFee < :: core :: primitive :: u128 > > , pub listing_fee : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: ternoa_pallets_primitives :: common :: CompoundFee < :: core :: primitive :: u128 > > , pub account_list : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , pub offchain_data : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > , pub collection_list : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > > , } impl :: subxt :: events :: StaticEvent for MarketplaceConfigSet { const PALLET : & 'static str = "Marketplace" ; const EVENT : & 'static str = "MarketplaceConfigSet" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Marketplace mint fee set"] pub struct MarketplaceMintFeeSet { pub fee : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for MarketplaceMintFeeSet { const PALLET : & 'static str = "Marketplace" ; const EVENT : & 'static str = "MarketplaceMintFeeSet" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "NFT listed"] pub struct NFTListed { pub nft_id : :: core :: primitive :: u32 , pub marketplace_id : :: core :: primitive :: u32 , pub price : :: core :: primitive :: u128 , pub commission_fee : :: core :: option :: Option < runtime_types :: ternoa_pallets_primitives :: common :: CompoundFee < :: core :: primitive :: u128 > > , } impl :: subxt :: events :: StaticEvent for NFTListed { const PALLET : & 'static str = "Marketplace" ; const EVENT : & 'static str = "NFTListed" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "NFT unlisted"] pub struct NFTUnlisted { pub nft_id : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for NFTUnlisted { const PALLET : & 'static str = "Marketplace" ; const EVENT : & 'static str = "NFTUnlisted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "NFT sold"] pub struct NFTSold { pub nft_id : :: core :: primitive :: u32 , pub marketplace_id : :: core :: primitive :: u32 , pub buyer : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub listed_price : :: core :: primitive :: u128 , pub marketplace_cut : :: core :: primitive :: u128 , pub royalty_cut : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for NFTSold { const PALLET : & 'static str = "Marketplace" ; const EVENT : & 'static str = "NFTSold" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " How much does it cost to create a marketplace."] pub fn marketplace_mint_fee (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Marketplace" , "MarketplaceMintFee" , vec ! [] , [214u8 , 39u8 , 136u8 , 114u8 , 19u8 , 76u8 , 89u8 , 12u8 , 67u8 , 128u8 , 84u8 , 190u8 , 144u8 , 255u8 , 122u8 , 47u8 , 50u8 , 229u8 , 68u8 , 89u8 , 32u8 , 235u8 , 197u8 , 186u8 , 108u8 , 103u8 , 2u8 , 200u8 , 11u8 , 64u8 , 23u8 , 247u8 ,]) } # [doc = " Counter for marketplace ids."] pub fn next_marketplace_id (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Marketplace" , "NextMarketplaceId" , vec ! [] , [91u8 , 43u8 , 252u8 , 160u8 , 240u8 , 60u8 , 174u8 , 108u8 , 255u8 , 187u8 , 185u8 , 125u8 , 95u8 , 174u8 , 78u8 , 95u8 , 234u8 , 209u8 , 214u8 , 127u8 , 212u8 , 208u8 , 81u8 , 173u8 , 217u8 , 221u8 , 46u8 , 50u8 , 90u8 , 167u8 , 106u8 , 80u8 ,]) } # [doc = " Data related to marketplaces"] pub fn marketplaces (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_pallets_primitives :: marketplace :: MarketplaceData < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Marketplace" , "Marketplaces" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [108u8 , 221u8 , 221u8 , 172u8 , 230u8 , 170u8 , 207u8 , 53u8 , 128u8 , 44u8 , 241u8 , 51u8 , 244u8 , 64u8 , 118u8 , 104u8 , 4u8 , 9u8 , 129u8 , 139u8 , 247u8 , 241u8 , 160u8 , 218u8 , 98u8 , 138u8 , 251u8 , 7u8 , 28u8 , 202u8 , 17u8 , 246u8 ,]) } # [doc = " Data related to marketplaces"] pub fn marketplaces_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_pallets_primitives :: marketplace :: MarketplaceData < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Marketplace" , "Marketplaces" , Vec :: new () , [108u8 , 221u8 , 221u8 , 172u8 , 230u8 , 170u8 , 207u8 , 53u8 , 128u8 , 44u8 , 241u8 , 51u8 , 244u8 , 64u8 , 118u8 , 104u8 , 4u8 , 9u8 , 129u8 , 139u8 , 247u8 , 241u8 , 160u8 , 218u8 , 98u8 , 138u8 , 251u8 , 7u8 , 28u8 , 202u8 , 17u8 , 246u8 ,]) } # [doc = " Data related to sales"] pub fn listed_nfts (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_marketplace :: types :: Sale < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Marketplace" , "ListedNfts" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [1u8 , 81u8 , 87u8 , 114u8 , 205u8 , 207u8 , 34u8 , 225u8 , 242u8 , 215u8 , 62u8 , 203u8 , 43u8 , 167u8 , 179u8 , 230u8 , 170u8 , 205u8 , 160u8 , 100u8 , 173u8 , 207u8 , 190u8 , 216u8 , 112u8 , 117u8 , 131u8 , 3u8 , 18u8 , 104u8 , 210u8 , 142u8 ,]) } # [doc = " Data related to sales"] pub fn listed_nfts_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_marketplace :: types :: Sale < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Marketplace" , "ListedNfts" , Vec :: new () , [1u8 , 81u8 , 87u8 , 114u8 , 205u8 , 207u8 , 34u8 , 225u8 , 242u8 , 215u8 , 62u8 , 203u8 , 43u8 , 167u8 , 179u8 , 230u8 , 170u8 , 205u8 , 160u8 , 100u8 , 173u8 , 207u8 , 190u8 , 216u8 , 112u8 , 117u8 , 131u8 , 3u8 , 18u8 , 104u8 , 210u8 , 142u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Default fee for minting Marketplaces."] pub fn initial_mint_fee (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Marketplace" , "InitialMintFee" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The maximum number of accounts that can be stored inside the account list."] pub fn account_size_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Marketplace" , "AccountSizeLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Maximum offchain data length."] pub fn offchain_data_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Marketplace" , "OffchainDataLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of collection ids that can be stored inside the collection list."] pub fn collection_size_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Marketplace" , "CollectionSizeLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod assets { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Create { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub admin : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub min_balance : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ForceCreate { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub owner : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub is_sufficient : :: core :: primitive :: bool , # [codec (compact)] pub min_balance : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Destroy { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub witness : runtime_types :: pallet_assets :: types :: DestroyWitness , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Mint { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub beneficiary : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] pub amount : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Burn { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] pub amount : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Transfer { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] pub amount : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct TransferKeepAlive { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] pub amount : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ForceTransfer { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub source : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub dest : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] pub amount : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Freeze { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Thaw { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct FreezeAsset { # [codec (compact)] pub id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ThawAsset { # [codec (compact)] pub id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct TransferOwnership { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub owner : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetTeam { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub issuer : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub admin : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub freezer : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SetMetadata { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub name : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub symbol : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub decimals : :: core :: primitive :: u8 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ClearMetadata { # [codec (compact)] pub id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ForceSetMetadata { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub name : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub symbol : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub decimals : :: core :: primitive :: u8 , pub is_frozen : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ForceClearMetadata { # [codec (compact)] pub id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ForceAssetStatus { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub owner : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub issuer : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub admin : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub freezer : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] pub min_balance : :: core :: primitive :: u128 , pub is_sufficient : :: core :: primitive :: bool , pub is_frozen : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ApproveTransfer { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub delegate : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] pub amount : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CancelApproval { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub delegate : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ForceCancelApproval { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub owner : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub delegate : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct TransferApproved { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub owner : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , pub destination : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] pub amount : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Touch { # [codec (compact)] pub id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Refund { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub allow_burn : :: core :: primitive :: bool , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Issue a new class of fungible assets from a public origin."] # [doc = ""] # [doc = "This new asset class has no assets initially and its owner is the origin."] # [doc = ""] # [doc = "The origin must be Signed and the sender must have sufficient funds free."] # [doc = ""] # [doc = "Funds of sender are reserved by `AssetDeposit`."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `id`: The identifier of the new asset. This must not be currently in use to identify"] # [doc = "an existing asset."] # [doc = "- `admin`: The admin of this class of assets. The admin is the initial address of each"] # [doc = "member of the asset class's admin team."] # [doc = "- `min_balance`: The minimum balance of this new asset that any single account must"] # [doc = "have. If an account's balance is reduced below this, then it collapses to zero."] # [doc = ""] # [doc = "Emits `Created` event when successful."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn create (& self , id : :: core :: primitive :: u32 , admin : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , min_balance : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < Create > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "create" , Create { id , admin , min_balance , } , [173u8 , 91u8 , 250u8 , 119u8 , 145u8 , 115u8 , 29u8 , 163u8 , 99u8 , 95u8 , 89u8 , 231u8 , 200u8 , 205u8 , 3u8 , 226u8 , 144u8 , 66u8 , 168u8 , 39u8 , 63u8 , 69u8 , 255u8 , 116u8 , 61u8 , 67u8 , 195u8 , 219u8 , 102u8 , 112u8 , 155u8 , 67u8 ,]) } # [doc = "Issue a new class of fungible assets from a privileged origin."] # [doc = ""] # [doc = "This new asset class has no assets initially."] # [doc = ""] # [doc = "The origin must conform to `ForceOrigin`."] # [doc = ""] # [doc = "Unlike `create`, no funds are reserved."] # [doc = ""] # [doc = "- `id`: The identifier of the new asset. This must not be currently in use to identify"] # [doc = "an existing asset."] # [doc = "- `owner`: The owner of this class of assets. The owner has full superuser permissions"] # [doc = "over this asset, but may later change and configure the permissions using"] # [doc = "`transfer_ownership` and `set_team`."] # [doc = "- `min_balance`: The minimum balance of this new asset that any single account must"] # [doc = "have. If an account's balance is reduced below this, then it collapses to zero."] # [doc = ""] # [doc = "Emits `ForceCreated` event when successful."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn force_create (& self , id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , is_sufficient : :: core :: primitive :: bool , min_balance : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < ForceCreate > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "force_create" , ForceCreate { id , owner , is_sufficient , min_balance , } , [45u8 , 129u8 , 55u8 , 141u8 , 100u8 , 83u8 , 74u8 , 183u8 , 70u8 , 83u8 , 158u8 , 89u8 , 86u8 , 102u8 , 228u8 , 71u8 , 182u8 , 43u8 , 22u8 , 126u8 , 42u8 , 195u8 , 204u8 , 173u8 , 178u8 , 166u8 , 155u8 , 105u8 , 13u8 , 178u8 , 4u8 , 254u8 ,]) } # [doc = "Destroy a class of fungible assets."] # [doc = ""] # [doc = "The origin must conform to `ForceOrigin` or must be Signed and the sender must be the"] # [doc = "owner of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to be destroyed. This must identify an existing"] # [doc = "asset."] # [doc = ""] # [doc = "Emits `Destroyed` event when successful."] # [doc = ""] # [doc = "NOTE: It can be helpful to first freeze an asset before destroying it so that you"] # [doc = "can provide accurate witness information and prevent users from manipulating state"] # [doc = "in a way that can make it harder to destroy."] # [doc = ""] # [doc = "Weight: `O(c + p + a)` where:"] # [doc = "- `c = (witness.accounts - witness.sufficients)`"] # [doc = "- `s = witness.sufficients`"] # [doc = "- `a = witness.approvals`"] pub fn destroy (& self , id : :: core :: primitive :: u32 , witness : runtime_types :: pallet_assets :: types :: DestroyWitness ,) -> :: subxt :: tx :: StaticTxPayload < Destroy > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "destroy" , Destroy { id , witness , } , [243u8 , 230u8 , 96u8 , 223u8 , 56u8 , 13u8 , 69u8 , 28u8 , 165u8 , 163u8 , 192u8 , 203u8 , 100u8 , 170u8 , 10u8 , 85u8 , 85u8 , 144u8 , 108u8 , 32u8 , 64u8 , 84u8 , 149u8 , 15u8 , 75u8 , 57u8 , 24u8 , 249u8 , 146u8 , 157u8 , 52u8 , 166u8 ,]) } # [doc = "Mint assets of a particular class."] # [doc = ""] # [doc = "The origin must be Signed and the sender must be the Issuer of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to have some amount minted."] # [doc = "- `beneficiary`: The account to be credited with the minted assets."] # [doc = "- `amount`: The amount of the asset to be minted."] # [doc = ""] # [doc = "Emits `Issued` event when successful."] # [doc = ""] # [doc = "Weight: `O(1)`"] # [doc = "Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`."] pub fn mint (& self , id : :: core :: primitive :: u32 , beneficiary : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , amount : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < Mint > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "mint" , Mint { id , beneficiary , amount , } , [142u8 , 88u8 , 145u8 , 221u8 , 194u8 , 149u8 , 206u8 , 99u8 , 206u8 , 71u8 , 101u8 , 130u8 , 175u8 , 218u8 , 130u8 , 9u8 , 169u8 , 28u8 , 82u8 , 41u8 , 102u8 , 159u8 , 131u8 , 145u8 , 249u8 , 54u8 , 38u8 , 168u8 , 48u8 , 15u8 , 2u8 , 96u8 ,]) } # [doc = "Reduce the balance of `who` by as much as possible up to `amount` assets of `id`."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Manager of the asset `id`."] # [doc = ""] # [doc = "Bails with `NoAccount` if the `who` is already dead."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to have some amount burned."] # [doc = "- `who`: The account to be debited from."] # [doc = "- `amount`: The maximum amount by which `who`'s balance should be reduced."] # [doc = ""] # [doc = "Emits `Burned` with the actual amount burned. If this takes the balance to below the"] # [doc = "minimum for the asset, then the amount burned is increased to take it to zero."] # [doc = ""] # [doc = "Weight: `O(1)`"] # [doc = "Modes: Post-existence of `who`; Pre & post Zombie-status of `who`."] pub fn burn (& self , id : :: core :: primitive :: u32 , who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , amount : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < Burn > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "burn" , Burn { id , who , amount , } , [27u8 , 30u8 , 250u8 , 220u8 , 38u8 , 224u8 , 142u8 , 28u8 , 70u8 , 122u8 , 241u8 , 79u8 , 31u8 , 163u8 , 54u8 , 87u8 , 44u8 , 6u8 , 14u8 , 161u8 , 32u8 , 181u8 , 94u8 , 117u8 , 34u8 , 161u8 , 97u8 , 161u8 , 7u8 , 163u8 , 223u8 , 124u8 ,]) } # [doc = "Move some assets from the sender account to another."] # [doc = ""] # [doc = "Origin must be Signed."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to have some amount transferred."] # [doc = "- `target`: The account to be credited."] # [doc = "- `amount`: The amount by which the sender's balance of assets should be reduced and"] # [doc = "`target`'s balance increased. The amount actually transferred may be slightly greater in"] # [doc = "the case that the transfer would otherwise take the sender balance above zero but below"] # [doc = "the minimum balance. Must be greater than zero."] # [doc = ""] # [doc = "Emits `Transferred` with the actual amount transferred. If this takes the source balance"] # [doc = "to below the minimum for the asset, then the amount transferred is increased to take it"] # [doc = "to zero."] # [doc = ""] # [doc = "Weight: `O(1)`"] # [doc = "Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of"] # [doc = "`target`."] pub fn transfer (& self , id : :: core :: primitive :: u32 , target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , amount : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < Transfer > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "transfer" , Transfer { id , target , amount , } , [211u8 , 37u8 , 7u8 , 179u8 , 233u8 , 146u8 , 149u8 , 140u8 , 54u8 , 97u8 , 141u8 , 213u8 , 149u8 , 84u8 , 127u8 , 185u8 , 205u8 , 93u8 , 119u8 , 179u8 , 47u8 , 112u8 , 7u8 , 17u8 , 94u8 , 125u8 , 44u8 , 28u8 , 103u8 , 17u8 , 209u8 , 61u8 ,]) } # [doc = "Move some assets from the sender account to another, keeping the sender account alive."] # [doc = ""] # [doc = "Origin must be Signed."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to have some amount transferred."] # [doc = "- `target`: The account to be credited."] # [doc = "- `amount`: The amount by which the sender's balance of assets should be reduced and"] # [doc = "`target`'s balance increased. The amount actually transferred may be slightly greater in"] # [doc = "the case that the transfer would otherwise take the sender balance above zero but below"] # [doc = "the minimum balance. Must be greater than zero."] # [doc = ""] # [doc = "Emits `Transferred` with the actual amount transferred. If this takes the source balance"] # [doc = "to below the minimum for the asset, then the amount transferred is increased to take it"] # [doc = "to zero."] # [doc = ""] # [doc = "Weight: `O(1)`"] # [doc = "Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of"] # [doc = "`target`."] pub fn transfer_keep_alive (& self , id : :: core :: primitive :: u32 , target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , amount : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < TransferKeepAlive > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "transfer_keep_alive" , TransferKeepAlive { id , target , amount , } , [45u8 , 221u8 , 40u8 , 14u8 , 110u8 , 12u8 , 134u8 , 20u8 , 220u8 , 73u8 , 131u8 , 43u8 , 6u8 , 214u8 , 34u8 , 13u8 , 200u8 , 198u8 , 44u8 , 150u8 , 58u8 , 252u8 , 2u8 , 136u8 , 238u8 , 253u8 , 118u8 , 238u8 , 241u8 , 172u8 , 151u8 , 153u8 ,]) } # [doc = "Move some assets from one account to another."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Admin of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to have some amount transferred."] # [doc = "- `source`: The account to be debited."] # [doc = "- `dest`: The account to be credited."] # [doc = "- `amount`: The amount by which the `source`'s balance of assets should be reduced and"] # [doc = "`dest`'s balance increased. The amount actually transferred may be slightly greater in"] # [doc = "the case that the transfer would otherwise take the `source` balance above zero but"] # [doc = "below the minimum balance. Must be greater than zero."] # [doc = ""] # [doc = "Emits `Transferred` with the actual amount transferred. If this takes the source balance"] # [doc = "to below the minimum for the asset, then the amount transferred is increased to take it"] # [doc = "to zero."] # [doc = ""] # [doc = "Weight: `O(1)`"] # [doc = "Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of"] # [doc = "`dest`."] pub fn force_transfer (& self , id : :: core :: primitive :: u32 , source : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , dest : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , amount : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < ForceTransfer > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "force_transfer" , ForceTransfer { id , source , dest , amount , } , [203u8 , 81u8 , 11u8 , 97u8 , 79u8 , 101u8 , 170u8 , 89u8 , 107u8 , 10u8 , 220u8 , 133u8 , 229u8 , 94u8 , 228u8 , 255u8 , 216u8 , 239u8 , 161u8 , 15u8 , 50u8 , 113u8 , 6u8 , 131u8 , 107u8 , 60u8 , 112u8 , 146u8 , 245u8 , 67u8 , 15u8 , 220u8 ,]) } # [doc = "Disallow further unprivileged transfers from an account."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Freezer of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to be frozen."] # [doc = "- `who`: The account to be frozen."] # [doc = ""] # [doc = "Emits `Frozen`."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn freeze (& self , id : :: core :: primitive :: u32 , who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < Freeze > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "freeze" , Freeze { id , who , } , [9u8 , 164u8 , 132u8 , 206u8 , 71u8 , 56u8 , 255u8 , 255u8 , 169u8 , 236u8 , 79u8 , 148u8 , 201u8 , 242u8 , 125u8 , 120u8 , 179u8 , 148u8 , 225u8 , 7u8 , 139u8 , 193u8 , 33u8 , 68u8 , 61u8 , 133u8 , 230u8 , 13u8 , 232u8 , 2u8 , 235u8 , 112u8 ,]) } # [doc = "Allow unprivileged transfers from an account again."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Admin of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to be frozen."] # [doc = "- `who`: The account to be unfrozen."] # [doc = ""] # [doc = "Emits `Thawed`."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn thaw (& self , id : :: core :: primitive :: u32 , who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < Thaw > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "thaw" , Thaw { id , who , } , [121u8 , 134u8 , 54u8 , 1u8 , 81u8 , 234u8 , 61u8 , 112u8 , 120u8 , 213u8 , 153u8 , 137u8 , 206u8 , 129u8 , 87u8 , 90u8 , 135u8 , 211u8 , 151u8 , 2u8 , 195u8 , 40u8 , 218u8 , 16u8 , 87u8 , 119u8 , 204u8 , 180u8 , 97u8 , 233u8 , 14u8 , 168u8 ,]) } # [doc = "Disallow further unprivileged transfers for the asset class."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Freezer of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to be frozen."] # [doc = ""] # [doc = "Emits `Frozen`."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn freeze_asset (& self , id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < FreezeAsset > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "freeze_asset" , FreezeAsset { id , } , [208u8 , 101u8 , 0u8 , 73u8 , 41u8 , 192u8 , 227u8 , 44u8 , 189u8 , 231u8 , 40u8 , 124u8 , 189u8 , 147u8 , 136u8 , 210u8 , 76u8 , 32u8 , 249u8 , 183u8 , 68u8 , 58u8 , 150u8 , 136u8 , 192u8 , 47u8 , 173u8 , 178u8 , 225u8 , 84u8 , 110u8 , 1u8 ,]) } # [doc = "Allow unprivileged transfers for the asset again."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Admin of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to be thawed."] # [doc = ""] # [doc = "Emits `Thawed`."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn thaw_asset (& self , id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < ThawAsset > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "thaw_asset" , ThawAsset { id , } , [18u8 , 198u8 , 141u8 , 158u8 , 182u8 , 167u8 , 160u8 , 227u8 , 20u8 , 74u8 , 80u8 , 164u8 , 89u8 , 46u8 , 168u8 , 139u8 , 251u8 , 83u8 , 155u8 , 91u8 , 91u8 , 46u8 , 205u8 , 55u8 , 171u8 , 175u8 , 167u8 , 188u8 , 116u8 , 155u8 , 79u8 , 117u8 ,]) } # [doc = "Change the Owner of an asset."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Owner of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset."] # [doc = "- `owner`: The new Owner of this asset."] # [doc = ""] # [doc = "Emits `OwnerChanged`."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn transfer_ownership (& self , id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < TransferOwnership > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "transfer_ownership" , TransferOwnership { id , owner , } , [146u8 , 254u8 , 44u8 , 100u8 , 99u8 , 215u8 , 140u8 , 15u8 , 152u8 , 73u8 , 84u8 , 213u8 , 7u8 , 176u8 , 63u8 , 202u8 , 58u8 , 94u8 , 133u8 , 58u8 , 191u8 , 108u8 , 137u8 , 137u8 , 76u8 , 131u8 , 145u8 , 188u8 , 241u8 , 45u8 , 88u8 , 87u8 ,]) } # [doc = "Change the Issuer, Admin and Freezer of an asset."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Owner of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to be frozen."] # [doc = "- `issuer`: The new Issuer of this asset."] # [doc = "- `admin`: The new Admin of this asset."] # [doc = "- `freezer`: The new Freezer of this asset."] # [doc = ""] # [doc = "Emits `TeamChanged`."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn set_team (& self , id : :: core :: primitive :: u32 , issuer : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , admin : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , freezer : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < SetTeam > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "set_team" , SetTeam { id , issuer , admin , freezer , } , [206u8 , 78u8 , 41u8 , 85u8 , 189u8 , 77u8 , 76u8 , 150u8 , 213u8 , 233u8 , 68u8 , 12u8 , 75u8 , 181u8 , 158u8 , 105u8 , 158u8 , 209u8 , 94u8 , 155u8 , 100u8 , 91u8 , 95u8 , 77u8 , 10u8 , 192u8 , 138u8 , 243u8 , 42u8 , 155u8 , 253u8 , 165u8 ,]) } # [doc = "Set the metadata for an asset."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Owner of the asset `id`."] # [doc = ""] # [doc = "Funds of sender are reserved according to the formula:"] # [doc = "`MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into"] # [doc = "account any already reserved funds."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to update."] # [doc = "- `name`: The user friendly name of this asset. Limited in length by `StringLimit`."] # [doc = "- `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`."] # [doc = "- `decimals`: The number of decimals this asset uses to represent one unit."] # [doc = ""] # [doc = "Emits `MetadataSet`."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn set_metadata (& self , id : :: core :: primitive :: u32 , name : :: std :: vec :: Vec < :: core :: primitive :: u8 > , symbol : :: std :: vec :: Vec < :: core :: primitive :: u8 > , decimals : :: core :: primitive :: u8 ,) -> :: subxt :: tx :: StaticTxPayload < SetMetadata > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "set_metadata" , SetMetadata { id , name , symbol , decimals , } , [15u8 , 184u8 , 50u8 , 46u8 , 164u8 , 27u8 , 105u8 , 186u8 , 35u8 , 115u8 , 194u8 , 247u8 , 74u8 , 252u8 , 139u8 , 242u8 , 108u8 , 221u8 , 122u8 , 15u8 , 139u8 , 74u8 , 123u8 , 17u8 , 192u8 , 138u8 , 182u8 , 163u8 , 77u8 , 7u8 , 124u8 , 18u8 ,]) } # [doc = "Clear the metadata for an asset."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Owner of the asset `id`."] # [doc = ""] # [doc = "Any deposit is freed for the asset owner."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to clear."] # [doc = ""] # [doc = "Emits `MetadataCleared`."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn clear_metadata (& self , id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < ClearMetadata > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "clear_metadata" , ClearMetadata { id , } , [192u8 , 41u8 , 71u8 , 183u8 , 13u8 , 128u8 , 244u8 , 255u8 , 175u8 , 36u8 , 99u8 , 175u8 , 15u8 , 129u8 , 228u8 , 76u8 , 107u8 , 214u8 , 166u8 , 116u8 , 244u8 , 139u8 , 60u8 , 31u8 , 123u8 , 61u8 , 203u8 , 59u8 , 213u8 , 146u8 , 116u8 , 126u8 ,]) } # [doc = "Force the metadata for an asset to some value."] # [doc = ""] # [doc = "Origin must be ForceOrigin."] # [doc = ""] # [doc = "Any deposit is left alone."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to update."] # [doc = "- `name`: The user friendly name of this asset. Limited in length by `StringLimit`."] # [doc = "- `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`."] # [doc = "- `decimals`: The number of decimals this asset uses to represent one unit."] # [doc = ""] # [doc = "Emits `MetadataSet`."] # [doc = ""] # [doc = "Weight: `O(N + S)` where N and S are the length of the name and symbol respectively."] pub fn force_set_metadata (& self , id : :: core :: primitive :: u32 , name : :: std :: vec :: Vec < :: core :: primitive :: u8 > , symbol : :: std :: vec :: Vec < :: core :: primitive :: u8 > , decimals : :: core :: primitive :: u8 , is_frozen : :: core :: primitive :: bool ,) -> :: subxt :: tx :: StaticTxPayload < ForceSetMetadata > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "force_set_metadata" , ForceSetMetadata { id , name , symbol , decimals , is_frozen , } , [7u8 , 30u8 , 55u8 , 233u8 , 217u8 , 113u8 , 196u8 , 21u8 , 29u8 , 122u8 , 168u8 , 225u8 , 63u8 , 104u8 , 57u8 , 78u8 , 76u8 , 145u8 , 121u8 , 118u8 , 91u8 , 149u8 , 87u8 , 26u8 , 26u8 , 125u8 , 44u8 , 241u8 , 143u8 , 138u8 , 144u8 , 8u8 ,]) } # [doc = "Clear the metadata for an asset."] # [doc = ""] # [doc = "Origin must be ForceOrigin."] # [doc = ""] # [doc = "Any deposit is returned."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to clear."] # [doc = ""] # [doc = "Emits `MetadataCleared`."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn force_clear_metadata (& self , id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < ForceClearMetadata > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "force_clear_metadata" , ForceClearMetadata { id , } , [71u8 , 191u8 , 101u8 , 72u8 , 188u8 , 223u8 , 215u8 , 187u8 , 200u8 , 206u8 , 3u8 , 42u8 , 4u8 , 62u8 , 117u8 , 106u8 , 26u8 , 2u8 , 68u8 , 202u8 , 162u8 , 142u8 , 172u8 , 123u8 , 48u8 , 196u8 , 247u8 , 89u8 , 147u8 , 75u8 , 84u8 , 109u8 ,]) } # [doc = "Alter the attributes of a given asset."] # [doc = ""] # [doc = "Origin must be `ForceOrigin`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset."] # [doc = "- `owner`: The new Owner of this asset."] # [doc = "- `issuer`: The new Issuer of this asset."] # [doc = "- `admin`: The new Admin of this asset."] # [doc = "- `freezer`: The new Freezer of this asset."] # [doc = "- `min_balance`: The minimum balance of this new asset that any single account must"] # [doc = "have. If an account's balance is reduced below this, then it collapses to zero."] # [doc = "- `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient"] # [doc = "value to account for the state bloat associated with its balance storage. If set to"] # [doc = "`true`, then non-zero balances may be stored without a `consumer` reference (and thus"] # [doc = "an ED in the Balances pallet or whatever else is used to control user-account state"] # [doc = "growth)."] # [doc = "- `is_frozen`: Whether this asset class is frozen except for permissioned/admin"] # [doc = "instructions."] # [doc = ""] # [doc = "Emits `AssetStatusChanged` with the identity of the asset."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn force_asset_status (& self , id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , issuer : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , admin : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , freezer : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , min_balance : :: core :: primitive :: u128 , is_sufficient : :: core :: primitive :: bool , is_frozen : :: core :: primitive :: bool ,) -> :: subxt :: tx :: StaticTxPayload < ForceAssetStatus > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "force_asset_status" , ForceAssetStatus { id , owner , issuer , admin , freezer , min_balance , is_sufficient , is_frozen , } , [181u8 , 168u8 , 215u8 , 229u8 , 27u8 , 78u8 , 26u8 , 171u8 , 50u8 , 95u8 , 9u8 , 112u8 , 142u8 , 125u8 , 230u8 , 68u8 , 188u8 , 24u8 , 208u8 , 203u8 , 226u8 , 17u8 , 231u8 , 69u8 , 172u8 , 24u8 , 119u8 , 22u8 , 232u8 , 11u8 , 70u8 , 248u8 ,]) } # [doc = "Approve an amount of asset for transfer by a delegated third-party account."] # [doc = ""] # [doc = "Origin must be Signed."] # [doc = ""] # [doc = "Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account"] # [doc = "for the purpose of holding the approval. If some non-zero amount of assets is already"] # [doc = "approved from signing account to `delegate`, then it is topped up or unreserved to"] # [doc = "meet the right value."] # [doc = ""] # [doc = "NOTE: The signing account does not need to own `amount` of assets at the point of"] # [doc = "making this call."] # [doc = ""] # [doc = "- `id`: The identifier of the asset."] # [doc = "- `delegate`: The account to delegate permission to transfer asset."] # [doc = "- `amount`: The amount of asset that may be transferred by `delegate`. If there is"] # [doc = "already an approval in place, then this acts additively."] # [doc = ""] # [doc = "Emits `ApprovedTransfer` on success."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn approve_transfer (& self , id : :: core :: primitive :: u32 , delegate : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , amount : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < ApproveTransfer > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "approve_transfer" , ApproveTransfer { id , delegate , amount , } , [188u8 , 247u8 , 242u8 , 152u8 , 209u8 , 38u8 , 128u8 , 25u8 , 79u8 , 17u8 , 31u8 , 236u8 , 171u8 , 237u8 , 175u8 , 49u8 , 86u8 , 157u8 , 164u8 , 220u8 , 5u8 , 225u8 , 124u8 , 157u8 , 174u8 , 61u8 , 39u8 , 78u8 , 22u8 , 2u8 , 37u8 , 31u8 ,]) } # [doc = "Cancel all of some asset approved for delegated transfer by a third-party account."] # [doc = ""] # [doc = "Origin must be Signed and there must be an approval in place between signer and"] # [doc = "`delegate`."] # [doc = ""] # [doc = "Unreserves any deposit previously reserved by `approve_transfer` for the approval."] # [doc = ""] # [doc = "- `id`: The identifier of the asset."] # [doc = "- `delegate`: The account delegated permission to transfer asset."] # [doc = ""] # [doc = "Emits `ApprovalCancelled` on success."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn cancel_approval (& self , id : :: core :: primitive :: u32 , delegate : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < CancelApproval > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "cancel_approval" , CancelApproval { id , delegate , } , [176u8 , 30u8 , 130u8 , 224u8 , 220u8 , 236u8 , 186u8 , 160u8 , 21u8 , 177u8 , 57u8 , 65u8 , 12u8 , 85u8 , 195u8 , 254u8 , 189u8 , 180u8 , 229u8 , 25u8 , 240u8 , 200u8 , 101u8 , 223u8 , 110u8 , 66u8 , 246u8 , 81u8 , 44u8 , 135u8 , 228u8 , 220u8 ,]) } # [doc = "Cancel all of some asset approved for delegated transfer by a third-party account."] # [doc = ""] # [doc = "Origin must be either ForceOrigin or Signed origin with the signer being the Admin"] # [doc = "account of the asset `id`."] # [doc = ""] # [doc = "Unreserves any deposit previously reserved by `approve_transfer` for the approval."] # [doc = ""] # [doc = "- `id`: The identifier of the asset."] # [doc = "- `delegate`: The account delegated permission to transfer asset."] # [doc = ""] # [doc = "Emits `ApprovalCancelled` on success."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn force_cancel_approval (& self , id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , delegate : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > ,) -> :: subxt :: tx :: StaticTxPayload < ForceCancelApproval > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "force_cancel_approval" , ForceCancelApproval { id , owner , delegate , } , [6u8 , 80u8 , 184u8 , 209u8 , 50u8 , 16u8 , 2u8 , 236u8 , 101u8 , 140u8 , 94u8 , 0u8 , 56u8 , 77u8 , 119u8 , 220u8 , 141u8 , 144u8 , 82u8 , 189u8 , 6u8 , 52u8 , 212u8 , 102u8 , 170u8 , 143u8 , 171u8 , 140u8 , 150u8 , 86u8 , 247u8 , 17u8 ,]) } # [doc = "Transfer some asset balance from a previously delegated account to some third-party"] # [doc = "account."] # [doc = ""] # [doc = "Origin must be Signed and there must be an approval in place by the `owner` to the"] # [doc = "signer."] # [doc = ""] # [doc = "If the entire amount approved for transfer is transferred, then any deposit previously"] # [doc = "reserved by `approve_transfer` is unreserved."] # [doc = ""] # [doc = "- `id`: The identifier of the asset."] # [doc = "- `owner`: The account which previously approved for a transfer of at least `amount` and"] # [doc = "from which the asset balance will be withdrawn."] # [doc = "- `destination`: The account to which the asset balance of `amount` will be transferred."] # [doc = "- `amount`: The amount of assets to transfer."] # [doc = ""] # [doc = "Emits `TransferredApproved` on success."] # [doc = ""] # [doc = "Weight: `O(1)`"] pub fn transfer_approved (& self , id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , destination : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , amount : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < TransferApproved > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "transfer_approved" , TransferApproved { id , owner , destination , amount , } , [159u8 , 239u8 , 168u8 , 140u8 , 203u8 , 198u8 , 2u8 , 11u8 , 113u8 , 160u8 , 63u8 , 131u8 , 204u8 , 70u8 , 84u8 , 41u8 , 161u8 , 166u8 , 87u8 , 79u8 , 106u8 , 14u8 , 136u8 , 53u8 , 14u8 , 239u8 , 28u8 , 188u8 , 172u8 , 242u8 , 249u8 , 129u8 ,]) } # [doc = "Create an asset account for non-provider assets."] # [doc = ""] # [doc = "A deposit will be taken from the signer account."] # [doc = ""] # [doc = "- `origin`: Must be Signed; the signer account must have sufficient funds for a deposit"] # [doc = "  to be taken."] # [doc = "- `id`: The identifier of the asset for the account to be created."] # [doc = ""] # [doc = "Emits `Touched` event when successful."] pub fn touch (& self , id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < Touch > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "touch" , Touch { id , } , [114u8 , 149u8 , 179u8 , 168u8 , 115u8 , 117u8 , 32u8 , 50u8 , 39u8 , 77u8 , 148u8 , 238u8 , 123u8 , 96u8 , 193u8 , 174u8 , 113u8 , 141u8 , 34u8 , 228u8 , 228u8 , 214u8 , 71u8 , 111u8 , 55u8 , 126u8 , 103u8 , 181u8 , 133u8 , 77u8 , 116u8 , 105u8 ,]) } # [doc = "Return the deposit (if any) of an asset account."] # [doc = ""] # [doc = "The origin must be Signed."] # [doc = ""] # [doc = "- `id`: The identifier of the asset for the account to be created."] # [doc = "- `allow_burn`: If `true` then assets may be destroyed in order to complete the refund."] # [doc = ""] # [doc = "Emits `Refunded` event when successful."] pub fn refund (& self , id : :: core :: primitive :: u32 , allow_burn : :: core :: primitive :: bool ,) -> :: subxt :: tx :: StaticTxPayload < Refund > { :: subxt :: tx :: StaticTxPayload :: new ("Assets" , "refund" , Refund { id , allow_burn , } , [20u8 , 139u8 , 248u8 , 67u8 , 123u8 , 221u8 , 7u8 , 106u8 , 239u8 , 156u8 , 68u8 , 59u8 , 81u8 , 184u8 , 47u8 , 188u8 , 195u8 , 227u8 , 75u8 , 168u8 , 126u8 , 176u8 , 91u8 , 187u8 , 30u8 , 34u8 , 24u8 , 223u8 , 108u8 , 101u8 , 88u8 , 83u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_assets :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some asset class was created."] pub struct Created { pub asset_id : :: core :: primitive :: u32 , pub creator : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for Created { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "Created" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some assets were issued."] pub struct Issued { pub asset_id : :: core :: primitive :: u32 , pub owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub total_supply : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Issued { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "Issued" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some assets were transferred."] pub struct Transferred { pub asset_id : :: core :: primitive :: u32 , pub from : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub to : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Transferred { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "Transferred" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some assets were destroyed."] pub struct Burned { pub asset_id : :: core :: primitive :: u32 , pub owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub balance : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Burned { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "Burned" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "The management team changed."] pub struct TeamChanged { pub asset_id : :: core :: primitive :: u32 , pub issuer : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub admin : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub freezer : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for TeamChanged { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "TeamChanged" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "The owner changed."] pub struct OwnerChanged { pub asset_id : :: core :: primitive :: u32 , pub owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for OwnerChanged { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "OwnerChanged" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some account `who` was frozen."] pub struct Frozen { pub asset_id : :: core :: primitive :: u32 , pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for Frozen { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "Frozen" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some account `who` was thawed."] pub struct Thawed { pub asset_id : :: core :: primitive :: u32 , pub who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for Thawed { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "Thawed" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some asset `asset_id` was frozen."] pub struct AssetFrozen { pub asset_id : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for AssetFrozen { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "AssetFrozen" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some asset `asset_id` was thawed."] pub struct AssetThawed { pub asset_id : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for AssetThawed { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "AssetThawed" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An asset class was destroyed."] pub struct Destroyed { pub asset_id : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for Destroyed { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "Destroyed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Some asset class was force-created."] pub struct ForceCreated { pub asset_id : :: core :: primitive :: u32 , pub owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for ForceCreated { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "ForceCreated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "New metadata has been set for an asset."] pub struct MetadataSet { pub asset_id : :: core :: primitive :: u32 , pub name : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub symbol : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub decimals : :: core :: primitive :: u8 , pub is_frozen : :: core :: primitive :: bool , } impl :: subxt :: events :: StaticEvent for MetadataSet { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "MetadataSet" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Metadata has been cleared for an asset."] pub struct MetadataCleared { pub asset_id : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for MetadataCleared { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "MetadataCleared" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "(Additional) funds have been approved for transfer to a destination account."] pub struct ApprovedTransfer { pub asset_id : :: core :: primitive :: u32 , pub source : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub delegate : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for ApprovedTransfer { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "ApprovedTransfer" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An approval for account `delegate` was cancelled by `owner`."] pub struct ApprovalCancelled { pub asset_id : :: core :: primitive :: u32 , pub owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub delegate : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for ApprovalCancelled { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "ApprovalCancelled" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An `amount` was transferred in its entirety from `owner` to `destination` by"] # [doc = "the approved `delegate`."] pub struct TransferredApproved { pub asset_id : :: core :: primitive :: u32 , pub owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub delegate : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub destination : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for TransferredApproved { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "TransferredApproved" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An asset has had its attributes changed by the `Force` origin."] pub struct AssetStatusChanged { pub asset_id : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for AssetStatusChanged { const PALLET : & 'static str = "Assets" ; const EVENT : & 'static str = "AssetStatusChanged" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Details of an asset."] pub fn asset (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_assets :: types :: AssetDetails < :: core :: primitive :: u128 , :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Assets" , "Asset" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [65u8 , 19u8 , 120u8 , 233u8 , 154u8 , 59u8 , 71u8 , 35u8 , 10u8 , 35u8 , 125u8 , 99u8 , 186u8 , 18u8 , 239u8 , 118u8 , 169u8 , 104u8 , 80u8 , 204u8 , 85u8 , 193u8 , 145u8 , 83u8 , 132u8 , 19u8 , 117u8 , 227u8 , 67u8 , 62u8 , 123u8 , 109u8 ,]) } # [doc = " Details of an asset."] pub fn asset_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_assets :: types :: AssetDetails < :: core :: primitive :: u128 , :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Assets" , "Asset" , Vec :: new () , [65u8 , 19u8 , 120u8 , 233u8 , 154u8 , 59u8 , 71u8 , 35u8 , 10u8 , 35u8 , 125u8 , 99u8 , 186u8 , 18u8 , 239u8 , 118u8 , 169u8 , 104u8 , 80u8 , 204u8 , 85u8 , 193u8 , 145u8 , 83u8 , 132u8 , 19u8 , 117u8 , 227u8 , 67u8 , 62u8 , 123u8 , 109u8 ,]) } # [doc = " The holdings of a specific account for a specific asset."] pub fn account (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > , _1 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_assets :: types :: AssetAccount < :: core :: primitive :: u128 , :: core :: primitive :: u128 , () > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Assets" , "Account" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat) , :: subxt :: storage :: address :: StorageMapKey :: new (_1 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [109u8 , 245u8 , 93u8 , 133u8 , 206u8 , 68u8 , 94u8 , 233u8 , 29u8 , 113u8 , 245u8 , 201u8 , 241u8 , 2u8 , 200u8 , 179u8 , 37u8 , 199u8 , 128u8 , 243u8 , 49u8 , 50u8 , 122u8 , 139u8 , 135u8 , 48u8 , 201u8 , 109u8 , 195u8 , 38u8 , 205u8 , 32u8 ,]) } # [doc = " The holdings of a specific account for a specific asset."] pub fn account_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_assets :: types :: AssetAccount < :: core :: primitive :: u128 , :: core :: primitive :: u128 , () > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Assets" , "Account" , Vec :: new () , [109u8 , 245u8 , 93u8 , 133u8 , 206u8 , 68u8 , 94u8 , 233u8 , 29u8 , 113u8 , 245u8 , 201u8 , 241u8 , 2u8 , 200u8 , 179u8 , 37u8 , 199u8 , 128u8 , 243u8 , 49u8 , 50u8 , 122u8 , 139u8 , 135u8 , 48u8 , 201u8 , 109u8 , 195u8 , 38u8 , 205u8 , 32u8 ,]) } # [doc = " Approved balance transfers. First balance is the amount approved for transfer. Second"] # [doc = " is the amount of `T::Currency` reserved for storing this."] # [doc = " First key is the asset ID, second key is the owner and third key is the delegate."] pub fn approvals (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > , _1 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , _2 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_assets :: types :: Approval < :: core :: primitive :: u128 , :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Assets" , "Approvals" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat) , :: subxt :: storage :: address :: StorageMapKey :: new (_1 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat) , :: subxt :: storage :: address :: StorageMapKey :: new (_2 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [210u8 , 147u8 , 203u8 , 49u8 , 232u8 , 215u8 , 116u8 , 154u8 , 43u8 , 154u8 , 69u8 , 159u8 , 241u8 , 28u8 , 238u8 , 101u8 , 108u8 , 162u8 , 242u8 , 121u8 , 138u8 , 164u8 , 217u8 , 243u8 , 72u8 , 173u8 , 75u8 , 109u8 , 194u8 , 9u8 , 196u8 , 163u8 ,]) } # [doc = " Approved balance transfers. First balance is the amount approved for transfer. Second"] # [doc = " is the amount of `T::Currency` reserved for storing this."] # [doc = " First key is the asset ID, second key is the owner and third key is the delegate."] pub fn approvals_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_assets :: types :: Approval < :: core :: primitive :: u128 , :: core :: primitive :: u128 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Assets" , "Approvals" , Vec :: new () , [210u8 , 147u8 , 203u8 , 49u8 , 232u8 , 215u8 , 116u8 , 154u8 , 43u8 , 154u8 , 69u8 , 159u8 , 241u8 , 28u8 , 238u8 , 101u8 , 108u8 , 162u8 , 242u8 , 121u8 , 138u8 , 164u8 , 217u8 , 243u8 , 72u8 , 173u8 , 75u8 , 109u8 , 194u8 , 9u8 , 196u8 , 163u8 ,]) } # [doc = " Metadata of an asset."] pub fn metadata (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_assets :: types :: AssetMetadata < :: core :: primitive :: u128 , runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Assets" , "Metadata" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [80u8 , 115u8 , 155u8 , 115u8 , 136u8 , 108u8 , 82u8 , 93u8 , 65u8 , 130u8 , 143u8 , 228u8 , 170u8 , 234u8 , 182u8 , 170u8 , 229u8 , 217u8 , 168u8 , 71u8 , 81u8 , 80u8 , 16u8 , 112u8 , 209u8 , 82u8 , 8u8 , 165u8 , 80u8 , 137u8 , 58u8 , 170u8 ,]) } # [doc = " Metadata of an asset."] pub fn metadata_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: pallet_assets :: types :: AssetMetadata < :: core :: primitive :: u128 , runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Assets" , "Metadata" , Vec :: new () , [80u8 , 115u8 , 155u8 , 115u8 , 136u8 , 108u8 , 82u8 , 93u8 , 65u8 , 130u8 , 143u8 , 228u8 , 170u8 , 234u8 , 182u8 , 170u8 , 229u8 , 217u8 , 168u8 , 71u8 , 81u8 , 80u8 , 16u8 , 112u8 , 209u8 , 82u8 , 8u8 , 165u8 , 80u8 , 137u8 , 58u8 , 170u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The basic amount of funds that must be reserved for an asset."] pub fn asset_deposit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Assets" , "AssetDeposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The amount of funds that must be reserved for a non-provider asset account to be"] # [doc = " maintained."] pub fn asset_account_deposit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Assets" , "AssetAccountDeposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The basic amount of funds that must be reserved when adding metadata to your asset."] pub fn metadata_deposit_base (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Assets" , "MetadataDepositBase" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The additional funds that must be reserved for the number of bytes you store in your"] # [doc = " metadata."] pub fn metadata_deposit_per_byte (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Assets" , "MetadataDepositPerByte" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The amount of funds that must be reserved when creating a new approval."] pub fn approval_deposit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Assets" , "ApprovalDeposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The maximum length of a name or symbol stored on-chain."] pub fn string_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Assets" , "StringLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod auction { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CreateAuction { pub nft_id : :: core :: primitive :: u32 , pub marketplace_id : :: core :: primitive :: u32 , pub start_block : :: core :: primitive :: u32 , pub end_block : :: core :: primitive :: u32 , pub start_price : :: core :: primitive :: u128 , pub buy_it_price : :: core :: option :: Option < :: core :: primitive :: u128 > , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CancelAuction { pub nft_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct EndAuction { pub nft_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AddBid { pub nft_id : :: core :: primitive :: u32 , pub amount : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RemoveBid { pub nft_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct BuyItNow { pub nft_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Claim ; pub struct TransactionApi ; impl TransactionApi { pub fn create_auction (& self , nft_id : :: core :: primitive :: u32 , marketplace_id : :: core :: primitive :: u32 , start_block : :: core :: primitive :: u32 , end_block : :: core :: primitive :: u32 , start_price : :: core :: primitive :: u128 , buy_it_price : :: core :: option :: Option < :: core :: primitive :: u128 > ,) -> :: subxt :: tx :: StaticTxPayload < CreateAuction > { :: subxt :: tx :: StaticTxPayload :: new ("Auction" , "create_auction" , CreateAuction { nft_id , marketplace_id , start_block , end_block , start_price , buy_it_price , } , [78u8 , 29u8 , 3u8 , 145u8 , 195u8 , 142u8 , 176u8 , 157u8 , 129u8 , 229u8 , 50u8 , 222u8 , 165u8 , 11u8 , 102u8 , 130u8 , 162u8 , 246u8 , 157u8 , 131u8 , 3u8 , 184u8 , 64u8 , 97u8 , 139u8 , 151u8 , 145u8 , 172u8 , 104u8 , 196u8 , 243u8 , 196u8 ,]) } pub fn cancel_auction (& self , nft_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < CancelAuction > { :: subxt :: tx :: StaticTxPayload :: new ("Auction" , "cancel_auction" , CancelAuction { nft_id , } , [65u8 , 26u8 , 76u8 , 73u8 , 3u8 , 92u8 , 223u8 , 8u8 , 249u8 , 33u8 , 139u8 , 230u8 , 184u8 , 40u8 , 186u8 , 112u8 , 177u8 , 218u8 , 131u8 , 247u8 , 51u8 , 226u8 , 225u8 , 99u8 , 221u8 , 175u8 , 65u8 , 51u8 , 232u8 , 43u8 , 120u8 , 105u8 ,]) } pub fn end_auction (& self , nft_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < EndAuction > { :: subxt :: tx :: StaticTxPayload :: new ("Auction" , "end_auction" , EndAuction { nft_id , } , [39u8 , 158u8 , 146u8 , 168u8 , 130u8 , 91u8 , 240u8 , 207u8 , 152u8 , 32u8 , 42u8 , 107u8 , 65u8 , 157u8 , 204u8 , 27u8 , 167u8 , 228u8 , 155u8 , 193u8 , 249u8 , 140u8 , 64u8 , 172u8 , 8u8 , 37u8 , 113u8 , 147u8 , 160u8 , 49u8 , 161u8 , 181u8 ,]) } pub fn add_bid (& self , nft_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: StaticTxPayload < AddBid > { :: subxt :: tx :: StaticTxPayload :: new ("Auction" , "add_bid" , AddBid { nft_id , amount , } , [64u8 , 41u8 , 207u8 , 109u8 , 235u8 , 186u8 , 241u8 , 190u8 , 209u8 , 83u8 , 53u8 , 185u8 , 65u8 , 192u8 , 0u8 , 110u8 , 221u8 , 31u8 , 206u8 , 247u8 , 198u8 , 242u8 , 159u8 , 9u8 , 15u8 , 27u8 , 43u8 , 172u8 , 129u8 , 227u8 , 104u8 , 204u8 ,]) } pub fn remove_bid (& self , nft_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < RemoveBid > { :: subxt :: tx :: StaticTxPayload :: new ("Auction" , "remove_bid" , RemoveBid { nft_id , } , [118u8 , 78u8 , 9u8 , 204u8 , 209u8 , 249u8 , 187u8 , 177u8 , 178u8 , 241u8 , 167u8 , 115u8 , 42u8 , 237u8 , 225u8 , 108u8 , 49u8 , 218u8 , 108u8 , 82u8 , 47u8 , 111u8 , 68u8 , 211u8 , 201u8 , 237u8 , 34u8 , 66u8 , 91u8 , 88u8 , 243u8 , 187u8 ,]) } pub fn buy_it_now (& self , nft_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < BuyItNow > { :: subxt :: tx :: StaticTxPayload :: new ("Auction" , "buy_it_now" , BuyItNow { nft_id , } , [172u8 , 115u8 , 5u8 , 119u8 , 254u8 , 199u8 , 91u8 , 185u8 , 175u8 , 125u8 , 17u8 , 189u8 , 80u8 , 89u8 , 113u8 , 1u8 , 0u8 , 165u8 , 20u8 , 17u8 , 203u8 , 75u8 , 59u8 , 83u8 , 226u8 , 39u8 , 173u8 , 17u8 , 125u8 , 164u8 , 176u8 , 21u8 ,]) } pub fn claim (& self ,) -> :: subxt :: tx :: StaticTxPayload < Claim > { :: subxt :: tx :: StaticTxPayload :: new ("Auction" , "claim" , Claim { } , [45u8 , 97u8 , 229u8 , 222u8 , 255u8 , 43u8 , 179u8 , 22u8 , 163u8 , 231u8 , 33u8 , 96u8 , 167u8 , 206u8 , 213u8 , 116u8 , 80u8 , 254u8 , 184u8 , 3u8 , 96u8 , 5u8 , 160u8 , 81u8 , 148u8 , 30u8 , 117u8 , 255u8 , 107u8 , 177u8 , 200u8 , 78u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: ternoa_auction :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A new auction was created."] pub struct AuctionCreated { pub nft_id : :: core :: primitive :: u32 , pub marketplace_id : :: core :: primitive :: u32 , pub creator : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub start_price : :: core :: primitive :: u128 , pub buy_it_price : :: core :: option :: Option < :: core :: primitive :: u128 > , pub start_block : :: core :: primitive :: u32 , pub end_block : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for AuctionCreated { const PALLET : & 'static str = "Auction" ; const EVENT : & 'static str = "AuctionCreated" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An existing auction was cancelled."] pub struct AuctionCancelled { pub nft_id : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for AuctionCancelled { const PALLET : & 'static str = "Auction" ; const EVENT : & 'static str = "AuctionCancelled" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An auction has completed and no more bids can be placed."] pub struct AuctionCompleted { pub nft_id : :: core :: primitive :: u32 , pub new_owner : :: core :: option :: Option < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , pub paid_amount : :: core :: option :: Option < :: core :: primitive :: u128 > , pub marketplace_cut : :: core :: option :: Option < :: core :: primitive :: u128 > , pub royalty_cut : :: core :: option :: Option < :: core :: primitive :: u128 > , pub auctioneer_cut : :: core :: option :: Option < :: core :: primitive :: u128 > , } impl :: subxt :: events :: StaticEvent for AuctionCompleted { const PALLET : & 'static str = "Auction" ; const EVENT : & 'static str = "AuctionCompleted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A new bid was created."] pub struct BidAdded { pub nft_id : :: core :: primitive :: u32 , pub bidder : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for BidAdded { const PALLET : & 'static str = "Auction" ; const EVENT : & 'static str = "BidAdded" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An existing bid was removed."] pub struct BidRemoved { pub nft_id : :: core :: primitive :: u32 , pub bidder : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for BidRemoved { const PALLET : & 'static str = "Auction" ; const EVENT : & 'static str = "BidRemoved" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An existing bid was updated."] pub struct BidUpdated { pub nft_id : :: core :: primitive :: u32 , pub bidder : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for BidUpdated { const PALLET : & 'static str = "Auction" ; const EVENT : & 'static str = "BidUpdated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An existing bid was dropped."] pub struct BidDropped { pub nft_id : :: core :: primitive :: u32 , pub bidder : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for BidDropped { const PALLET : & 'static str = "Auction" ; const EVENT : & 'static str = "BidDropped" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Balance claimed."] pub struct BalanceClaimed { pub account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for BalanceClaimed { const PALLET : & 'static str = "Auction" ; const EVENT : & 'static str = "BalanceClaimed" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { pub fn auctions (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_auction :: types :: AuctionData < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 , :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Auction" , "Auctions" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [67u8 , 163u8 , 121u8 , 33u8 , 131u8 , 60u8 , 255u8 , 21u8 , 227u8 , 5u8 , 121u8 , 124u8 , 229u8 , 224u8 , 185u8 , 110u8 , 227u8 , 251u8 , 254u8 , 252u8 , 181u8 , 64u8 , 38u8 , 253u8 , 112u8 , 163u8 , 122u8 , 144u8 , 113u8 , 103u8 , 137u8 , 80u8 ,]) } pub fn auctions_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_auction :: types :: AuctionData < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 , :: core :: primitive :: u128 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Auction" , "Auctions" , Vec :: new () , [67u8 , 163u8 , 121u8 , 33u8 , 131u8 , 60u8 , 255u8 , 21u8 , 227u8 , 5u8 , 121u8 , 124u8 , 229u8 , 224u8 , 185u8 , 110u8 , 227u8 , 251u8 , 254u8 , 252u8 , 181u8 , 64u8 , 38u8 , 253u8 , 112u8 , 163u8 , 122u8 , 144u8 , 113u8 , 103u8 , 137u8 , 80u8 ,]) } pub fn deadlines (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_auction :: types :: DeadlineList < :: core :: primitive :: u32 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Auction" , "Deadlines" , vec ! [] , [27u8 , 6u8 , 33u8 , 92u8 , 92u8 , 3u8 , 252u8 , 238u8 , 16u8 , 224u8 , 92u8 , 193u8 , 111u8 , 39u8 , 199u8 , 156u8 , 208u8 , 73u8 , 73u8 , 153u8 , 22u8 , 221u8 , 213u8 , 242u8 , 190u8 , 55u8 , 119u8 , 82u8 , 220u8 , 149u8 , 194u8 , 255u8 ,]) } pub fn claims (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Auction" , "Claims" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [245u8 , 18u8 , 228u8 , 144u8 , 123u8 , 97u8 , 4u8 , 120u8 , 118u8 , 165u8 , 191u8 , 86u8 , 231u8 , 179u8 , 242u8 , 252u8 , 251u8 , 79u8 , 88u8 , 148u8 , 84u8 , 48u8 , 128u8 , 178u8 , 236u8 , 197u8 , 253u8 , 250u8 , 175u8 , 42u8 , 46u8 , 203u8 ,]) } pub fn claims_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u128 > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Auction" , "Claims" , Vec :: new () , [245u8 , 18u8 , 228u8 , 144u8 , 123u8 , 97u8 , 4u8 , 120u8 , 118u8 , 165u8 , 191u8 , 86u8 , 231u8 , 179u8 , 242u8 , 252u8 , 251u8 , 79u8 , 88u8 , 148u8 , 84u8 , 48u8 , 128u8 , 178u8 , 236u8 , 197u8 , 253u8 , 250u8 , 175u8 , 42u8 , 46u8 , 203u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Minimum required length of auction."] pub fn min_auction_duration (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Auction" , "MinAuctionDuration" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Maximum permitted length of auction."] pub fn max_auction_duration (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Auction" , "MaxAuctionDuration" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Maximum distance between the current block and the start block of an auction."] pub fn max_auction_delay (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Auction" , "MaxAuctionDelay" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Grace period to extend auction by if new bid received."] pub fn auction_grace_period (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Auction" , "AuctionGracePeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Ending period during which an auction can be extended."] pub fn auction_ending_period (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Auction" , "AuctionEndingPeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The auctions pallet id - will be used to generate account id."] pub fn pallet_id (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < runtime_types :: frame_support :: PalletId >> { :: subxt :: constants :: StaticConstantAddress :: new ("Auction" , "PalletId" , [139u8 , 109u8 , 228u8 , 151u8 , 252u8 , 32u8 , 130u8 , 69u8 , 112u8 , 154u8 , 174u8 , 45u8 , 83u8 , 245u8 , 51u8 , 132u8 , 173u8 , 5u8 , 186u8 , 24u8 , 243u8 , 9u8 , 12u8 , 214u8 , 80u8 , 74u8 , 69u8 , 189u8 , 30u8 , 94u8 , 22u8 , 39u8 ,]) } # [doc = " Total amount of accounts that can be in the bidder list."] pub fn bidder_list_length_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Auction" , "BidderListLengthLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Maximum amount of auctions that can be active at the same time."] pub fn parallel_auction_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Auction" , "ParallelAuctionLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Maximum number of related automatic auction actions in block."] pub fn actions_in_block_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Auction" , "ActionsInBlockLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod rent { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CreateContract { pub nft_id : :: core :: primitive :: u32 , pub duration : runtime_types :: ternoa_rent :: types :: DurationInput < :: core :: primitive :: u32 > , pub acceptance_type : runtime_types :: ternoa_rent :: types :: AcceptanceType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , pub renter_can_revoke : :: core :: primitive :: bool , pub rent_fee : runtime_types :: ternoa_rent :: types :: RentFee < :: core :: primitive :: u128 > , pub renter_cancellation_fee : runtime_types :: ternoa_rent :: types :: CancellationFee < :: core :: primitive :: u128 > , pub rentee_cancellation_fee : runtime_types :: ternoa_rent :: types :: CancellationFee < :: core :: primitive :: u128 > , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CancelContract { pub nft_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RevokeContract { pub nft_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Rent { pub nft_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct MakeRentOffer { pub nft_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AcceptRentOffer { pub nft_id : :: core :: primitive :: u32 , pub rentee : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RetractRentOffer { pub nft_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ChangeSubscriptionTerms { pub nft_id : :: core :: primitive :: u32 , pub rent_fee : :: core :: primitive :: u128 , pub period : :: core :: primitive :: u32 , pub max_duration : :: core :: option :: Option < :: core :: primitive :: u32 > , pub is_changeable : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AcceptSubscriptionTerms { pub nft_id : :: core :: primitive :: u32 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Create a new rent contract with the provided details."] pub fn create_contract (& self , nft_id : :: core :: primitive :: u32 , duration : runtime_types :: ternoa_rent :: types :: DurationInput < :: core :: primitive :: u32 > , acceptance_type : runtime_types :: ternoa_rent :: types :: AcceptanceType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , renter_can_revoke : :: core :: primitive :: bool , rent_fee : runtime_types :: ternoa_rent :: types :: RentFee < :: core :: primitive :: u128 > , renter_cancellation_fee : runtime_types :: ternoa_rent :: types :: CancellationFee < :: core :: primitive :: u128 > , rentee_cancellation_fee : runtime_types :: ternoa_rent :: types :: CancellationFee < :: core :: primitive :: u128 > ,) -> :: subxt :: tx :: StaticTxPayload < CreateContract > { :: subxt :: tx :: StaticTxPayload :: new ("Rent" , "create_contract" , CreateContract { nft_id , duration , acceptance_type , renter_can_revoke , rent_fee , renter_cancellation_fee , rentee_cancellation_fee , } , [7u8 , 197u8 , 239u8 , 2u8 , 181u8 , 11u8 , 128u8 , 56u8 , 163u8 , 226u8 , 25u8 , 95u8 , 145u8 , 100u8 , 182u8 , 110u8 , 232u8 , 34u8 , 217u8 , 18u8 , 48u8 , 20u8 , 227u8 , 196u8 , 49u8 , 34u8 , 71u8 , 162u8 , 17u8 , 106u8 , 67u8 , 196u8 ,]) } # [doc = "Cancel a contract that is not running."] pub fn cancel_contract (& self , nft_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < CancelContract > { :: subxt :: tx :: StaticTxPayload :: new ("Rent" , "cancel_contract" , CancelContract { nft_id , } , [198u8 , 97u8 , 127u8 , 73u8 , 53u8 , 165u8 , 122u8 , 26u8 , 8u8 , 129u8 , 111u8 , 172u8 , 108u8 , 80u8 , 39u8 , 218u8 , 141u8 , 246u8 , 182u8 , 83u8 , 27u8 , 61u8 , 163u8 , 127u8 , 190u8 , 152u8 , 249u8 , 57u8 , 89u8 , 171u8 , 153u8 , 240u8 ,]) } # [doc = "Revoke a running contract."] pub fn revoke_contract (& self , nft_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < RevokeContract > { :: subxt :: tx :: StaticTxPayload :: new ("Rent" , "revoke_contract" , RevokeContract { nft_id , } , [21u8 , 155u8 , 229u8 , 131u8 , 199u8 , 7u8 , 103u8 , 75u8 , 42u8 , 106u8 , 30u8 , 63u8 , 187u8 , 20u8 , 139u8 , 46u8 , 91u8 , 11u8 , 186u8 , 249u8 , 52u8 , 60u8 , 177u8 , 163u8 , 24u8 , 70u8 , 146u8 , 146u8 , 33u8 , 137u8 , 43u8 , 206u8 ,]) } # [doc = "Rent an NFT."] pub fn rent (& self , nft_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < Rent > { :: subxt :: tx :: StaticTxPayload :: new ("Rent" , "rent" , Rent { nft_id , } , [62u8 , 81u8 , 224u8 , 214u8 , 188u8 , 62u8 , 252u8 , 15u8 , 166u8 , 120u8 , 164u8 , 78u8 , 184u8 , 81u8 , 99u8 , 50u8 , 42u8 , 221u8 , 90u8 , 185u8 , 113u8 , 175u8 , 227u8 , 253u8 , 178u8 , 96u8 , 71u8 , 94u8 , 108u8 , 126u8 , 137u8 , 96u8 ,]) } # [doc = "Make a offer."] pub fn make_rent_offer (& self , nft_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < MakeRentOffer > { :: subxt :: tx :: StaticTxPayload :: new ("Rent" , "make_rent_offer" , MakeRentOffer { nft_id , } , [131u8 , 24u8 , 53u8 , 138u8 , 228u8 , 180u8 , 12u8 , 60u8 , 235u8 , 254u8 , 144u8 , 120u8 , 227u8 , 105u8 , 68u8 , 66u8 , 26u8 , 0u8 , 28u8 , 105u8 , 141u8 , 234u8 , 46u8 , 39u8 , 172u8 , 151u8 , 71u8 , 88u8 , 226u8 , 240u8 , 45u8 , 214u8 ,]) } # [doc = "Accept a rent offer for manual acceptance contract."] pub fn accept_rent_offer (& self , nft_id : :: core :: primitive :: u32 , rentee : :: subxt :: ext :: sp_core :: crypto :: AccountId32 ,) -> :: subxt :: tx :: StaticTxPayload < AcceptRentOffer > { :: subxt :: tx :: StaticTxPayload :: new ("Rent" , "accept_rent_offer" , AcceptRentOffer { nft_id , rentee , } , [36u8 , 201u8 , 102u8 , 69u8 , 171u8 , 28u8 , 211u8 , 143u8 , 208u8 , 1u8 , 191u8 , 63u8 , 227u8 , 236u8 , 213u8 , 116u8 , 64u8 , 253u8 , 230u8 , 109u8 , 25u8 , 170u8 , 97u8 , 84u8 , 106u8 , 62u8 , 74u8 , 254u8 , 109u8 , 138u8 , 141u8 , 126u8 ,]) } # [doc = "Retract a rent offer for manual acceptance contract."] pub fn retract_rent_offer (& self , nft_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < RetractRentOffer > { :: subxt :: tx :: StaticTxPayload :: new ("Rent" , "retract_rent_offer" , RetractRentOffer { nft_id , } , [33u8 , 192u8 , 232u8 , 245u8 , 30u8 , 147u8 , 229u8 , 91u8 , 19u8 , 53u8 , 230u8 , 16u8 , 132u8 , 147u8 , 223u8 , 204u8 , 134u8 , 246u8 , 241u8 , 179u8 , 140u8 , 78u8 , 113u8 , 215u8 , 159u8 , 79u8 , 180u8 , 32u8 , 4u8 , 240u8 , 119u8 , 129u8 ,]) } # [doc = "Change the subscription terms for subscription contracts."] pub fn change_subscription_terms (& self , nft_id : :: core :: primitive :: u32 , rent_fee : :: core :: primitive :: u128 , period : :: core :: primitive :: u32 , max_duration : :: core :: option :: Option < :: core :: primitive :: u32 > , is_changeable : :: core :: primitive :: bool ,) -> :: subxt :: tx :: StaticTxPayload < ChangeSubscriptionTerms > { :: subxt :: tx :: StaticTxPayload :: new ("Rent" , "change_subscription_terms" , ChangeSubscriptionTerms { nft_id , rent_fee , period , max_duration , is_changeable , } , [1u8 , 141u8 , 64u8 , 203u8 , 233u8 , 160u8 , 201u8 , 175u8 , 51u8 , 112u8 , 108u8 , 47u8 , 135u8 , 184u8 , 21u8 , 23u8 , 33u8 , 78u8 , 117u8 , 175u8 , 10u8 , 254u8 , 226u8 , 74u8 , 152u8 , 99u8 , 13u8 , 192u8 , 62u8 , 226u8 , 149u8 , 241u8 ,]) } # [doc = "Accept the new contract terms."] pub fn accept_subscription_terms (& self , nft_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: StaticTxPayload < AcceptSubscriptionTerms > { :: subxt :: tx :: StaticTxPayload :: new ("Rent" , "accept_subscription_terms" , AcceptSubscriptionTerms { nft_id , } , [131u8 , 89u8 , 155u8 , 82u8 , 73u8 , 16u8 , 39u8 , 40u8 , 242u8 , 145u8 , 122u8 , 222u8 , 171u8 , 16u8 , 93u8 , 253u8 , 186u8 , 236u8 , 231u8 , 45u8 , 190u8 , 120u8 , 186u8 , 164u8 , 27u8 , 104u8 , 245u8 , 54u8 , 138u8 , 190u8 , 108u8 , 111u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: ternoa_rent :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contract Created."] pub struct ContractCreated { pub nft_id : :: core :: primitive :: u32 , pub renter : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub duration : runtime_types :: ternoa_rent :: types :: Duration < :: core :: primitive :: u32 > , pub acceptance_type : runtime_types :: ternoa_rent :: types :: AcceptanceType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , pub renter_can_revoke : :: core :: primitive :: bool , pub rent_fee : runtime_types :: ternoa_rent :: types :: RentFee < :: core :: primitive :: u128 > , pub renter_cancellation_fee : runtime_types :: ternoa_rent :: types :: CancellationFee < :: core :: primitive :: u128 > , pub rentee_cancellation_fee : runtime_types :: ternoa_rent :: types :: CancellationFee < :: core :: primitive :: u128 > , } impl :: subxt :: events :: StaticEvent for ContractCreated { const PALLET : & 'static str = "Rent" ; const EVENT : & 'static str = "ContractCreated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contract was accepted and has started."] pub struct ContractStarted { pub nft_id : :: core :: primitive :: u32 , pub rentee : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for ContractStarted { const PALLET : & 'static str = "Rent" ; const EVENT : & 'static str = "ContractStarted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contract was revoked by either renter or rentee."] pub struct ContractRevoked { pub nft_id : :: core :: primitive :: u32 , pub revoked_by : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for ContractRevoked { const PALLET : & 'static str = "Rent" ; const EVENT : & 'static str = "ContractRevoked" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An offer was made for manual acceptance rent contract."] pub struct ContractOfferCreated { pub nft_id : :: core :: primitive :: u32 , pub rentee : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for ContractOfferCreated { const PALLET : & 'static str = "Rent" ; const EVENT : & 'static str = "ContractOfferCreated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "An offer was retracted for manual acceptance rent contract."] pub struct ContractOfferRetracted { pub nft_id : :: core :: primitive :: u32 , pub rentee : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } impl :: subxt :: events :: StaticEvent for ContractOfferRetracted { const PALLET : & 'static str = "Rent" ; const EVENT : & 'static str = "ContractOfferRetracted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A contract subscription's terms were changed by renter."] pub struct ContractSubscriptionTermsChanged { pub nft_id : :: core :: primitive :: u32 , pub period : :: core :: primitive :: u32 , pub max_duration : :: core :: primitive :: u32 , pub is_changeable : :: core :: primitive :: bool , pub rent_fee : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for ContractSubscriptionTermsChanged { const PALLET : & 'static str = "Rent" ; const EVENT : & 'static str = "ContractSubscriptionTermsChanged" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A contract new subscription's terms were accpeted by rentee."] pub struct ContractSubscriptionTermsAccepted { pub nft_id : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for ContractSubscriptionTermsAccepted { const PALLET : & 'static str = "Rent" ; const EVENT : & 'static str = "ContractSubscriptionTermsAccepted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A contract has ended."] pub struct ContractEnded { pub nft_id : :: core :: primitive :: u32 , pub revoked_by : :: core :: option :: Option < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } impl :: subxt :: events :: StaticEvent for ContractEnded { const PALLET : & 'static str = "Rent" ; const EVENT : & 'static str = "ContractEnded" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A contract's subscription period has started."] pub struct ContractSubscriptionPeriodStarted { pub nft_id : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for ContractSubscriptionPeriodStarted { const PALLET : & 'static str = "Rent" ; const EVENT : & 'static str = "ContractSubscriptionPeriodStarted" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "A contract available for sale was expired before its acceptance."] pub struct ContractExpired { pub nft_id : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for ContractExpired { const PALLET : & 'static str = "Rent" ; const EVENT : & 'static str = "ContractExpired" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contract was canceled."] pub struct ContractCanceled { pub nft_id : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for ContractCanceled { const PALLET : & 'static str = "Rent" ; const EVENT : & 'static str = "ContractCanceled" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Data related to rent contracts."] pub fn contracts (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_rent :: types :: RentContractData < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 , :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Rent" , "Contracts" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [81u8 , 160u8 , 244u8 , 125u8 , 248u8 , 147u8 , 203u8 , 152u8 , 146u8 , 115u8 , 180u8 , 61u8 , 170u8 , 207u8 , 1u8 , 205u8 , 158u8 , 191u8 , 187u8 , 165u8 , 217u8 , 48u8 , 126u8 , 43u8 , 65u8 , 31u8 , 26u8 , 117u8 , 186u8 , 25u8 , 53u8 , 131u8 ,]) } # [doc = " Data related to rent contracts."] pub fn contracts_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_rent :: types :: RentContractData < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 , :: core :: primitive :: u128 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Rent" , "Contracts" , Vec :: new () , [81u8 , 160u8 , 244u8 , 125u8 , 248u8 , 147u8 , 203u8 , 152u8 , 146u8 , 115u8 , 180u8 , 61u8 , 170u8 , 207u8 , 1u8 , 205u8 , 158u8 , 191u8 , 187u8 , 165u8 , 217u8 , 48u8 , 126u8 , 43u8 , 65u8 , 31u8 , 26u8 , 117u8 , 186u8 , 25u8 , 53u8 , 131u8 ,]) } # [doc = " Data related to contracts queues."] pub fn queues (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: ternoa_rent :: types :: RentingQueues < :: core :: primitive :: u32 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Rent" , "Queues" , vec ! [] , [224u8 , 153u8 , 70u8 , 75u8 , 123u8 , 174u8 , 88u8 , 229u8 , 187u8 , 18u8 , 23u8 , 254u8 , 161u8 , 59u8 , 174u8 , 48u8 , 137u8 , 62u8 , 4u8 , 189u8 , 21u8 , 144u8 , 119u8 , 143u8 , 33u8 , 170u8 , 61u8 , 88u8 , 16u8 , 149u8 , 10u8 , 38u8 ,]) } # [doc = " Data related to rent contracts offers."] pub fn offers (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Rent" , "Offers" , vec ! [:: subxt :: storage :: address :: StorageMapKey :: new (_0 . borrow () , :: subxt :: storage :: address :: StorageHasher :: Blake2_128Concat)] , [92u8 , 238u8 , 239u8 , 29u8 , 222u8 , 89u8 , 8u8 , 51u8 , 11u8 , 251u8 , 231u8 , 89u8 , 237u8 , 30u8 , 80u8 , 202u8 , 170u8 , 139u8 , 29u8 , 248u8 , 77u8 , 81u8 , 66u8 , 8u8 , 216u8 , 209u8 , 32u8 , 82u8 , 155u8 , 80u8 , 82u8 , 9u8 ,]) } # [doc = " Data related to rent contracts offers."] pub fn offers_root (& self ,) -> :: subxt :: storage :: address :: StaticStorageAddress :: < :: subxt :: metadata :: DecodeStaticType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: StaticStorageAddress :: new ("Rent" , "Offers" , Vec :: new () , [92u8 , 238u8 , 239u8 , 29u8 , 222u8 , 89u8 , 8u8 , 51u8 , 11u8 , 251u8 , 231u8 , 89u8 , 237u8 , 30u8 , 80u8 , 202u8 , 170u8 , 139u8 , 29u8 , 248u8 , 77u8 , 81u8 , 66u8 , 8u8 , 216u8 , 209u8 , 32u8 , 82u8 , 155u8 , 80u8 , 82u8 , 9u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The auctions pallet id - will be used to generate account id."] pub fn pallet_id (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < runtime_types :: frame_support :: PalletId >> { :: subxt :: constants :: StaticConstantAddress :: new ("Rent" , "PalletId" , [139u8 , 109u8 , 228u8 , 151u8 , 252u8 , 32u8 , 130u8 , 69u8 , 112u8 , 154u8 , 174u8 , 45u8 , 83u8 , 245u8 , 51u8 , 132u8 , 173u8 , 5u8 , 186u8 , 24u8 , 243u8 , 9u8 , 12u8 , 214u8 , 80u8 , 74u8 , 69u8 , 189u8 , 30u8 , 94u8 , 22u8 , 39u8 ,]) } # [doc = " The maximum number of accounts that can be stored inside the account list."] pub fn account_size_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Rent" , "AccountSizeLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Maximum number of simultaneous rent contract."] pub fn simultaneous_contract_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Rent" , "SimultaneousContractLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Maximum number of related automatic rent actions in block."] pub fn actions_in_block_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Rent" , "ActionsInBlockLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Maximum number of blocks during which a rent contract is available for acceptance."] pub fn maximum_contract_availability_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Rent" , "MaximumContractAvailabilityLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Maximum number of blocks that a contract can last for."] pub fn maximum_contract_duration_limit (& self) -> :: subxt :: constants :: StaticConstantAddress < :: subxt :: metadata :: DecodeStaticType < :: core :: primitive :: u32 >> { :: subxt :: constants :: StaticConstantAddress :: new ("Rent" , "MaximumContractDurationLimit" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod runtime_types { use super :: runtime_types ; pub mod alphanet_runtime { use super :: runtime_types ; pub mod pallets { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SessionKeys { pub grandpa : runtime_types :: sp_finality_grandpa :: app :: Public , pub babe : runtime_types :: sp_consensus_babe :: app :: Public , pub im_online : runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Public , pub authority_discovery : runtime_types :: sp_authority_discovery :: app :: Public , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum OriginCaller { # [codec (index = 0)] system (runtime_types :: frame_support :: dispatch :: RawOrigin < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) , # [codec (index = 24)] Council (runtime_types :: pallet_collective :: RawOrigin < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) , # [codec (index = 17)] TechnicalCommittee (runtime_types :: pallet_collective :: RawOrigin < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) , # [codec (index = 3)] Void (runtime_types :: sp_core :: Void ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Runtime ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum RuntimeCall { # [codec (index = 0)] System (runtime_types :: frame_system :: pallet :: Call ,) , # [codec (index = 1)] Scheduler (runtime_types :: pallet_scheduler :: pallet :: Call ,) , # [codec (index = 2)] Babe (runtime_types :: pallet_babe :: pallet :: Call ,) , # [codec (index = 3)] Timestamp (runtime_types :: pallet_timestamp :: pallet :: Call ,) , # [codec (index = 4)] Balances (runtime_types :: pallet_balances :: pallet :: Call ,) , # [codec (index = 6)] Authorship (runtime_types :: pallet_authorship :: pallet :: Call ,) , # [codec (index = 9)] Session (runtime_types :: pallet_session :: pallet :: Call ,) , # [codec (index = 10)] Grandpa (runtime_types :: pallet_grandpa :: pallet :: Call ,) , # [codec (index = 11)] ImOnline (runtime_types :: pallet_im_online :: pallet :: Call ,) , # [codec (index = 24)] Council (runtime_types :: pallet_collective :: pallet :: Call ,) , # [codec (index = 25)] PhragmenElection (runtime_types :: pallet_elections_phragmen :: pallet :: Call ,) , # [codec (index = 26)] Democracy (runtime_types :: pallet_democracy :: pallet :: Call ,) , # [codec (index = 13)] Staking (runtime_types :: pallet_staking :: pallet :: pallet :: Call ,) , # [codec (index = 14)] StakingRewards (runtime_types :: ternoa_staking_rewards :: pallet :: Call ,) , # [codec (index = 15)] ElectionProviderMultiPhase (runtime_types :: pallet_election_provider_multi_phase :: pallet :: Call ,) , # [codec (index = 16)] BagsList (runtime_types :: pallet_bags_list :: pallet :: Call ,) , # [codec (index = 17)] TechnicalCommittee (runtime_types :: pallet_collective :: pallet :: Call ,) , # [codec (index = 18)] TechnicalMembership (runtime_types :: pallet_membership :: pallet :: Call ,) , # [codec (index = 19)] Mandate (runtime_types :: ternoa_mandate :: pallet :: Call ,) , # [codec (index = 20)] Treasury (runtime_types :: pallet_treasury :: pallet :: Call ,) , # [codec (index = 21)] Utility (runtime_types :: pallet_utility :: pallet :: Call ,) , # [codec (index = 22)] Preimage (runtime_types :: pallet_preimage :: pallet :: Call ,) , # [codec (index = 23)] Bridge (runtime_types :: ternoa_bridge :: pallet :: Call ,) , # [codec (index = 27)] Multisig (runtime_types :: pallet_multisig :: pallet :: Call ,) , # [codec (index = 28)] Identity (runtime_types :: pallet_identity :: pallet :: Call ,) , # [codec (index = 29)] NFT (runtime_types :: ternoa_nft :: pallet :: Call ,) , # [codec (index = 30)] Marketplace (runtime_types :: ternoa_marketplace :: pallet :: Call ,) , # [codec (index = 31)] Assets (runtime_types :: pallet_assets :: pallet :: Call ,) , # [codec (index = 32)] Auction (runtime_types :: ternoa_auction :: pallet :: Call ,) , # [codec (index = 33)] Rent (runtime_types :: ternoa_rent :: pallet :: Call ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum RuntimeEvent { # [codec (index = 0)] System (runtime_types :: frame_system :: pallet :: Event ,) , # [codec (index = 1)] Scheduler (runtime_types :: pallet_scheduler :: pallet :: Event ,) , # [codec (index = 4)] Balances (runtime_types :: pallet_balances :: pallet :: Event ,) , # [codec (index = 5)] TransactionPayment (runtime_types :: pallet_transaction_payment :: pallet :: Event ,) , # [codec (index = 7)] Offences (runtime_types :: pallet_offences :: pallet :: Event ,) , # [codec (index = 9)] Session (runtime_types :: pallet_session :: pallet :: Event ,) , # [codec (index = 10)] Grandpa (runtime_types :: pallet_grandpa :: pallet :: Event ,) , # [codec (index = 11)] ImOnline (runtime_types :: pallet_im_online :: pallet :: Event ,) , # [codec (index = 24)] Council (runtime_types :: pallet_collective :: pallet :: Event ,) , # [codec (index = 25)] PhragmenElection (runtime_types :: pallet_elections_phragmen :: pallet :: Event ,) , # [codec (index = 26)] Democracy (runtime_types :: pallet_democracy :: pallet :: Event ,) , # [codec (index = 13)] Staking (runtime_types :: pallet_staking :: pallet :: pallet :: Event ,) , # [codec (index = 14)] StakingRewards (runtime_types :: ternoa_staking_rewards :: pallet :: Event ,) , # [codec (index = 15)] ElectionProviderMultiPhase (runtime_types :: pallet_election_provider_multi_phase :: pallet :: Event ,) , # [codec (index = 16)] BagsList (runtime_types :: pallet_bags_list :: pallet :: Event ,) , # [codec (index = 17)] TechnicalCommittee (runtime_types :: pallet_collective :: pallet :: Event ,) , # [codec (index = 18)] TechnicalMembership (runtime_types :: pallet_membership :: pallet :: Event ,) , # [codec (index = 19)] Mandate (runtime_types :: ternoa_mandate :: pallet :: Event ,) , # [codec (index = 20)] Treasury (runtime_types :: pallet_treasury :: pallet :: Event ,) , # [codec (index = 21)] Utility (runtime_types :: pallet_utility :: pallet :: Event ,) , # [codec (index = 22)] Preimage (runtime_types :: pallet_preimage :: pallet :: Event ,) , # [codec (index = 23)] Bridge (runtime_types :: ternoa_bridge :: pallet :: Event ,) , # [codec (index = 27)] Multisig (runtime_types :: pallet_multisig :: pallet :: Event ,) , # [codec (index = 28)] Identity (runtime_types :: pallet_identity :: pallet :: Event ,) , # [codec (index = 29)] NFT (runtime_types :: ternoa_nft :: pallet :: Event ,) , # [codec (index = 30)] Marketplace (runtime_types :: ternoa_marketplace :: pallet :: Event ,) , # [codec (index = 31)] Assets (runtime_types :: pallet_assets :: pallet :: Event ,) , # [codec (index = 32)] Auction (runtime_types :: ternoa_auction :: pallet :: Event ,) , # [codec (index = 33)] Rent (runtime_types :: ternoa_rent :: pallet :: Event ,) , } } pub mod finality_grandpa { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Equivocation < _0 , _1 , _2 > { pub round_number : :: core :: primitive :: u64 , pub identity : _0 , pub first : (_1 , _2 ,) , pub second : (_1 , _2 ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Precommit < _0 , _1 > { pub target_hash : _0 , pub target_number : _1 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Prevote < _0 , _1 > { pub target_hash : _0 , pub target_number : _1 , } } pub mod frame_support { use super :: runtime_types ; pub mod dispatch { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum DispatchClass { # [codec (index = 0)] Normal , # [codec (index = 1)] Operational , # [codec (index = 2)] Mandatory , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct DispatchInfo { pub weight : runtime_types :: sp_weights :: weight_v2 :: Weight , pub class : runtime_types :: frame_support :: dispatch :: DispatchClass , pub pays_fee : runtime_types :: frame_support :: dispatch :: Pays , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Pays { # [codec (index = 0)] Yes , # [codec (index = 1)] No , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct PerDispatchClass < _0 > { pub normal : _0 , pub operational : _0 , pub mandatory : _0 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum RawOrigin < _0 > { # [codec (index = 0)] Root , # [codec (index = 1)] Signed (_0 ,) , # [codec (index = 2)] None , } } pub mod traits { use super :: runtime_types ; pub mod misc { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct WrapperKeepOpaque < _0 > (# [codec (compact)] pub :: core :: primitive :: u32 , pub _0 ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct WrapperOpaque < _0 > (# [codec (compact)] pub :: core :: primitive :: u32 , pub _0 ,) ; } pub mod schedule { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum LookupError { # [codec (index = 0)] Unknown , # [codec (index = 1)] BadFormat , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum MaybeHashed < _0 , _1 > { # [codec (index = 0)] Value (_0 ,) , # [codec (index = 1)] Hash (_1 ,) , } } pub mod tokens { use super :: runtime_types ; pub mod misc { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum BalanceStatus { # [codec (index = 0)] Free , # [codec (index = 1)] Reserved , } } } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct PalletId (pub [:: core :: primitive :: u8 ; 8usize] ,) ; } pub mod frame_system { use super :: runtime_types ; pub mod extensions { use super :: runtime_types ; pub mod check_genesis { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CheckGenesis ; } pub mod check_mortality { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CheckMortality (pub runtime_types :: sp_runtime :: generic :: era :: Era ,) ; } pub mod check_nonce { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CheckNonce (# [codec (compact)] pub :: core :: primitive :: u32 ,) ; } pub mod check_spec_version { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CheckSpecVersion ; } pub mod check_tx_version { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CheckTxVersion ; } pub mod check_weight { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct CheckWeight ; } } pub mod limits { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct BlockLength { pub max : runtime_types :: frame_support :: dispatch :: PerDispatchClass < :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct BlockWeights { pub base_block : runtime_types :: sp_weights :: weight_v2 :: Weight , pub max_block : runtime_types :: sp_weights :: weight_v2 :: Weight , pub per_class : runtime_types :: frame_support :: dispatch :: PerDispatchClass < runtime_types :: frame_system :: limits :: WeightsPerClass > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct WeightsPerClass { pub base_extrinsic : runtime_types :: sp_weights :: weight_v2 :: Weight , pub max_extrinsic : :: core :: option :: Option < runtime_types :: sp_weights :: weight_v2 :: Weight > , pub max_total : :: core :: option :: Option < runtime_types :: sp_weights :: weight_v2 :: Weight > , pub reserved : :: core :: option :: Option < runtime_types :: sp_weights :: weight_v2 :: Weight > , } } pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "A dispatch that will fill the block weight up to the given ratio."] fill_block { ratio : runtime_types :: sp_arithmetic :: per_things :: Perbill , } , # [codec (index = 1)] # [doc = "Make some on-chain remark."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)`"] # [doc = "# </weight>"] remark { remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 2)] # [doc = "Set the number of pages in the WebAssembly environment's heap."] set_heap_pages { pages : :: core :: primitive :: u64 , } , # [codec (index = 3)] # [doc = "Set the new runtime code."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`"] # [doc = "- 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is"] # [doc = "  expensive)."] # [doc = "- 1 storage write (codec `O(C)`)."] # [doc = "- 1 digest item."] # [doc = "- 1 event."] # [doc = "The weight of this function is dependent on the runtime, but generally this is very"] # [doc = "expensive. We will treat this as a full block."] # [doc = "# </weight>"] set_code { code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 4)] # [doc = "Set the new runtime code without doing any checks of the given `code`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(C)` where `C` length of `code`"] # [doc = "- 1 storage write (codec `O(C)`)."] # [doc = "- 1 digest item."] # [doc = "- 1 event."] # [doc = "The weight of this function is dependent on the runtime. We will treat this as a full"] # [doc = "block. # </weight>"] set_code_without_checks { code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 5)] # [doc = "Set some items of storage."] set_storage { items : :: std :: vec :: Vec < (:: std :: vec :: Vec < :: core :: primitive :: u8 > , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) > , } , # [codec (index = 6)] # [doc = "Kill some items from storage."] kill_storage { keys : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , } , # [codec (index = 7)] # [doc = "Kill all storage items with a key that starts with the given prefix."] # [doc = ""] # [doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"] # [doc = "the prefix we are removing to accurately calculate the weight of this function."] kill_prefix { prefix : :: std :: vec :: Vec < :: core :: primitive :: u8 > , subkeys : :: core :: primitive :: u32 , } , # [codec (index = 8)] # [doc = "Make some on-chain remark and emit event."] remark_with_event { remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Error for the System pallet"] pub enum Error { # [codec (index = 0)] # [doc = "The name of specification does not match between the current runtime"] # [doc = "and the new runtime."] InvalidSpecName , # [codec (index = 1)] # [doc = "The specification version is not allowed to decrease between the current runtime"] # [doc = "and the new runtime."] SpecVersionNeedsToIncrease , # [codec (index = 2)] # [doc = "Failed to extract the runtime version from the new runtime."] # [doc = ""] # [doc = "Either calling `Core_version` or decoding `RuntimeVersion` failed."] FailedToExtractRuntimeVersion , # [codec (index = 3)] # [doc = "Suicide called when the account has non-default composite data."] NonDefaultComposite , # [codec (index = 4)] # [doc = "There is a non-zero reference count preventing the account from being purged."] NonZeroRefCount , # [codec (index = 5)] # [doc = "The origin filter prevent the call to be dispatched."] CallFiltered , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Event for the System pallet."] pub enum Event { # [codec (index = 0)] # [doc = "An extrinsic completed successfully."] ExtrinsicSuccess { dispatch_info : runtime_types :: frame_support :: dispatch :: DispatchInfo , } , # [codec (index = 1)] # [doc = "An extrinsic failed."] ExtrinsicFailed { dispatch_error : runtime_types :: sp_runtime :: DispatchError , dispatch_info : runtime_types :: frame_support :: dispatch :: DispatchInfo , } , # [codec (index = 2)] # [doc = "`:code` was updated."] CodeUpdated , # [codec (index = 3)] # [doc = "A new account was created."] NewAccount { account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 4)] # [doc = "An account was reaped."] KilledAccount { account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 5)] # [doc = "On on-chain remark happened."] Remarked { sender : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , hash : :: subxt :: ext :: sp_core :: H256 , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AccountInfo < _0 , _1 > { pub nonce : _0 , pub consumers : _0 , pub providers : _0 , pub sufficients : _0 , pub data : _1 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct EventRecord < _0 , _1 > { pub phase : runtime_types :: frame_system :: Phase , pub event : _0 , pub topics : :: std :: vec :: Vec < _1 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct LastRuntimeUpgradeInfo { # [codec (compact)] pub spec_version : :: core :: primitive :: u32 , pub spec_name : :: std :: string :: String , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Phase { # [codec (index = 0)] ApplyExtrinsic (:: core :: primitive :: u32 ,) , # [codec (index = 1)] Finalization , # [codec (index = 2)] Initialization , } } pub mod pallet_assets { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Issue a new class of fungible assets from a public origin."] # [doc = ""] # [doc = "This new asset class has no assets initially and its owner is the origin."] # [doc = ""] # [doc = "The origin must be Signed and the sender must have sufficient funds free."] # [doc = ""] # [doc = "Funds of sender are reserved by `AssetDeposit`."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `id`: The identifier of the new asset. This must not be currently in use to identify"] # [doc = "an existing asset."] # [doc = "- `admin`: The admin of this class of assets. The admin is the initial address of each"] # [doc = "member of the asset class's admin team."] # [doc = "- `min_balance`: The minimum balance of this new asset that any single account must"] # [doc = "have. If an account's balance is reduced below this, then it collapses to zero."] # [doc = ""] # [doc = "Emits `Created` event when successful."] # [doc = ""] # [doc = "Weight: `O(1)`"] create { # [codec (compact)] id : :: core :: primitive :: u32 , admin : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , min_balance : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Issue a new class of fungible assets from a privileged origin."] # [doc = ""] # [doc = "This new asset class has no assets initially."] # [doc = ""] # [doc = "The origin must conform to `ForceOrigin`."] # [doc = ""] # [doc = "Unlike `create`, no funds are reserved."] # [doc = ""] # [doc = "- `id`: The identifier of the new asset. This must not be currently in use to identify"] # [doc = "an existing asset."] # [doc = "- `owner`: The owner of this class of assets. The owner has full superuser permissions"] # [doc = "over this asset, but may later change and configure the permissions using"] # [doc = "`transfer_ownership` and `set_team`."] # [doc = "- `min_balance`: The minimum balance of this new asset that any single account must"] # [doc = "have. If an account's balance is reduced below this, then it collapses to zero."] # [doc = ""] # [doc = "Emits `ForceCreated` event when successful."] # [doc = ""] # [doc = "Weight: `O(1)`"] force_create { # [codec (compact)] id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , is_sufficient : :: core :: primitive :: bool , # [codec (compact)] min_balance : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Destroy a class of fungible assets."] # [doc = ""] # [doc = "The origin must conform to `ForceOrigin` or must be Signed and the sender must be the"] # [doc = "owner of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to be destroyed. This must identify an existing"] # [doc = "asset."] # [doc = ""] # [doc = "Emits `Destroyed` event when successful."] # [doc = ""] # [doc = "NOTE: It can be helpful to first freeze an asset before destroying it so that you"] # [doc = "can provide accurate witness information and prevent users from manipulating state"] # [doc = "in a way that can make it harder to destroy."] # [doc = ""] # [doc = "Weight: `O(c + p + a)` where:"] # [doc = "- `c = (witness.accounts - witness.sufficients)`"] # [doc = "- `s = witness.sufficients`"] # [doc = "- `a = witness.approvals`"] destroy { # [codec (compact)] id : :: core :: primitive :: u32 , witness : runtime_types :: pallet_assets :: types :: DestroyWitness , } , # [codec (index = 3)] # [doc = "Mint assets of a particular class."] # [doc = ""] # [doc = "The origin must be Signed and the sender must be the Issuer of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to have some amount minted."] # [doc = "- `beneficiary`: The account to be credited with the minted assets."] # [doc = "- `amount`: The amount of the asset to be minted."] # [doc = ""] # [doc = "Emits `Issued` event when successful."] # [doc = ""] # [doc = "Weight: `O(1)`"] # [doc = "Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`."] mint { # [codec (compact)] id : :: core :: primitive :: u32 , beneficiary : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] amount : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "Reduce the balance of `who` by as much as possible up to `amount` assets of `id`."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Manager of the asset `id`."] # [doc = ""] # [doc = "Bails with `NoAccount` if the `who` is already dead."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to have some amount burned."] # [doc = "- `who`: The account to be debited from."] # [doc = "- `amount`: The maximum amount by which `who`'s balance should be reduced."] # [doc = ""] # [doc = "Emits `Burned` with the actual amount burned. If this takes the balance to below the"] # [doc = "minimum for the asset, then the amount burned is increased to take it to zero."] # [doc = ""] # [doc = "Weight: `O(1)`"] # [doc = "Modes: Post-existence of `who`; Pre & post Zombie-status of `who`."] burn { # [codec (compact)] id : :: core :: primitive :: u32 , who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] amount : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "Move some assets from the sender account to another."] # [doc = ""] # [doc = "Origin must be Signed."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to have some amount transferred."] # [doc = "- `target`: The account to be credited."] # [doc = "- `amount`: The amount by which the sender's balance of assets should be reduced and"] # [doc = "`target`'s balance increased. The amount actually transferred may be slightly greater in"] # [doc = "the case that the transfer would otherwise take the sender balance above zero but below"] # [doc = "the minimum balance. Must be greater than zero."] # [doc = ""] # [doc = "Emits `Transferred` with the actual amount transferred. If this takes the source balance"] # [doc = "to below the minimum for the asset, then the amount transferred is increased to take it"] # [doc = "to zero."] # [doc = ""] # [doc = "Weight: `O(1)`"] # [doc = "Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of"] # [doc = "`target`."] transfer { # [codec (compact)] id : :: core :: primitive :: u32 , target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] amount : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "Move some assets from the sender account to another, keeping the sender account alive."] # [doc = ""] # [doc = "Origin must be Signed."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to have some amount transferred."] # [doc = "- `target`: The account to be credited."] # [doc = "- `amount`: The amount by which the sender's balance of assets should be reduced and"] # [doc = "`target`'s balance increased. The amount actually transferred may be slightly greater in"] # [doc = "the case that the transfer would otherwise take the sender balance above zero but below"] # [doc = "the minimum balance. Must be greater than zero."] # [doc = ""] # [doc = "Emits `Transferred` with the actual amount transferred. If this takes the source balance"] # [doc = "to below the minimum for the asset, then the amount transferred is increased to take it"] # [doc = "to zero."] # [doc = ""] # [doc = "Weight: `O(1)`"] # [doc = "Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of"] # [doc = "`target`."] transfer_keep_alive { # [codec (compact)] id : :: core :: primitive :: u32 , target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] amount : :: core :: primitive :: u128 , } , # [codec (index = 7)] # [doc = "Move some assets from one account to another."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Admin of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to have some amount transferred."] # [doc = "- `source`: The account to be debited."] # [doc = "- `dest`: The account to be credited."] # [doc = "- `amount`: The amount by which the `source`'s balance of assets should be reduced and"] # [doc = "`dest`'s balance increased. The amount actually transferred may be slightly greater in"] # [doc = "the case that the transfer would otherwise take the `source` balance above zero but"] # [doc = "below the minimum balance. Must be greater than zero."] # [doc = ""] # [doc = "Emits `Transferred` with the actual amount transferred. If this takes the source balance"] # [doc = "to below the minimum for the asset, then the amount transferred is increased to take it"] # [doc = "to zero."] # [doc = ""] # [doc = "Weight: `O(1)`"] # [doc = "Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of"] # [doc = "`dest`."] force_transfer { # [codec (compact)] id : :: core :: primitive :: u32 , source : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , dest : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] amount : :: core :: primitive :: u128 , } , # [codec (index = 8)] # [doc = "Disallow further unprivileged transfers from an account."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Freezer of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to be frozen."] # [doc = "- `who`: The account to be frozen."] # [doc = ""] # [doc = "Emits `Frozen`."] # [doc = ""] # [doc = "Weight: `O(1)`"] freeze { # [codec (compact)] id : :: core :: primitive :: u32 , who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 9)] # [doc = "Allow unprivileged transfers from an account again."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Admin of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to be frozen."] # [doc = "- `who`: The account to be unfrozen."] # [doc = ""] # [doc = "Emits `Thawed`."] # [doc = ""] # [doc = "Weight: `O(1)`"] thaw { # [codec (compact)] id : :: core :: primitive :: u32 , who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 10)] # [doc = "Disallow further unprivileged transfers for the asset class."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Freezer of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to be frozen."] # [doc = ""] # [doc = "Emits `Frozen`."] # [doc = ""] # [doc = "Weight: `O(1)`"] freeze_asset { # [codec (compact)] id : :: core :: primitive :: u32 , } , # [codec (index = 11)] # [doc = "Allow unprivileged transfers for the asset again."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Admin of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to be thawed."] # [doc = ""] # [doc = "Emits `Thawed`."] # [doc = ""] # [doc = "Weight: `O(1)`"] thaw_asset { # [codec (compact)] id : :: core :: primitive :: u32 , } , # [codec (index = 12)] # [doc = "Change the Owner of an asset."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Owner of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset."] # [doc = "- `owner`: The new Owner of this asset."] # [doc = ""] # [doc = "Emits `OwnerChanged`."] # [doc = ""] # [doc = "Weight: `O(1)`"] transfer_ownership { # [codec (compact)] id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 13)] # [doc = "Change the Issuer, Admin and Freezer of an asset."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Owner of the asset `id`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to be frozen."] # [doc = "- `issuer`: The new Issuer of this asset."] # [doc = "- `admin`: The new Admin of this asset."] # [doc = "- `freezer`: The new Freezer of this asset."] # [doc = ""] # [doc = "Emits `TeamChanged`."] # [doc = ""] # [doc = "Weight: `O(1)`"] set_team { # [codec (compact)] id : :: core :: primitive :: u32 , issuer : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , admin : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , freezer : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 14)] # [doc = "Set the metadata for an asset."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Owner of the asset `id`."] # [doc = ""] # [doc = "Funds of sender are reserved according to the formula:"] # [doc = "`MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into"] # [doc = "account any already reserved funds."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to update."] # [doc = "- `name`: The user friendly name of this asset. Limited in length by `StringLimit`."] # [doc = "- `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`."] # [doc = "- `decimals`: The number of decimals this asset uses to represent one unit."] # [doc = ""] # [doc = "Emits `MetadataSet`."] # [doc = ""] # [doc = "Weight: `O(1)`"] set_metadata { # [codec (compact)] id : :: core :: primitive :: u32 , name : :: std :: vec :: Vec < :: core :: primitive :: u8 > , symbol : :: std :: vec :: Vec < :: core :: primitive :: u8 > , decimals : :: core :: primitive :: u8 , } , # [codec (index = 15)] # [doc = "Clear the metadata for an asset."] # [doc = ""] # [doc = "Origin must be Signed and the sender should be the Owner of the asset `id`."] # [doc = ""] # [doc = "Any deposit is freed for the asset owner."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to clear."] # [doc = ""] # [doc = "Emits `MetadataCleared`."] # [doc = ""] # [doc = "Weight: `O(1)`"] clear_metadata { # [codec (compact)] id : :: core :: primitive :: u32 , } , # [codec (index = 16)] # [doc = "Force the metadata for an asset to some value."] # [doc = ""] # [doc = "Origin must be ForceOrigin."] # [doc = ""] # [doc = "Any deposit is left alone."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to update."] # [doc = "- `name`: The user friendly name of this asset. Limited in length by `StringLimit`."] # [doc = "- `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`."] # [doc = "- `decimals`: The number of decimals this asset uses to represent one unit."] # [doc = ""] # [doc = "Emits `MetadataSet`."] # [doc = ""] # [doc = "Weight: `O(N + S)` where N and S are the length of the name and symbol respectively."] force_set_metadata { # [codec (compact)] id : :: core :: primitive :: u32 , name : :: std :: vec :: Vec < :: core :: primitive :: u8 > , symbol : :: std :: vec :: Vec < :: core :: primitive :: u8 > , decimals : :: core :: primitive :: u8 , is_frozen : :: core :: primitive :: bool , } , # [codec (index = 17)] # [doc = "Clear the metadata for an asset."] # [doc = ""] # [doc = "Origin must be ForceOrigin."] # [doc = ""] # [doc = "Any deposit is returned."] # [doc = ""] # [doc = "- `id`: The identifier of the asset to clear."] # [doc = ""] # [doc = "Emits `MetadataCleared`."] # [doc = ""] # [doc = "Weight: `O(1)`"] force_clear_metadata { # [codec (compact)] id : :: core :: primitive :: u32 , } , # [codec (index = 18)] # [doc = "Alter the attributes of a given asset."] # [doc = ""] # [doc = "Origin must be `ForceOrigin`."] # [doc = ""] # [doc = "- `id`: The identifier of the asset."] # [doc = "- `owner`: The new Owner of this asset."] # [doc = "- `issuer`: The new Issuer of this asset."] # [doc = "- `admin`: The new Admin of this asset."] # [doc = "- `freezer`: The new Freezer of this asset."] # [doc = "- `min_balance`: The minimum balance of this new asset that any single account must"] # [doc = "have. If an account's balance is reduced below this, then it collapses to zero."] # [doc = "- `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient"] # [doc = "value to account for the state bloat associated with its balance storage. If set to"] # [doc = "`true`, then non-zero balances may be stored without a `consumer` reference (and thus"] # [doc = "an ED in the Balances pallet or whatever else is used to control user-account state"] # [doc = "growth)."] # [doc = "- `is_frozen`: Whether this asset class is frozen except for permissioned/admin"] # [doc = "instructions."] # [doc = ""] # [doc = "Emits `AssetStatusChanged` with the identity of the asset."] # [doc = ""] # [doc = "Weight: `O(1)`"] force_asset_status { # [codec (compact)] id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , issuer : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , admin : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , freezer : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] min_balance : :: core :: primitive :: u128 , is_sufficient : :: core :: primitive :: bool , is_frozen : :: core :: primitive :: bool , } , # [codec (index = 19)] # [doc = "Approve an amount of asset for transfer by a delegated third-party account."] # [doc = ""] # [doc = "Origin must be Signed."] # [doc = ""] # [doc = "Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account"] # [doc = "for the purpose of holding the approval. If some non-zero amount of assets is already"] # [doc = "approved from signing account to `delegate`, then it is topped up or unreserved to"] # [doc = "meet the right value."] # [doc = ""] # [doc = "NOTE: The signing account does not need to own `amount` of assets at the point of"] # [doc = "making this call."] # [doc = ""] # [doc = "- `id`: The identifier of the asset."] # [doc = "- `delegate`: The account to delegate permission to transfer asset."] # [doc = "- `amount`: The amount of asset that may be transferred by `delegate`. If there is"] # [doc = "already an approval in place, then this acts additively."] # [doc = ""] # [doc = "Emits `ApprovedTransfer` on success."] # [doc = ""] # [doc = "Weight: `O(1)`"] approve_transfer { # [codec (compact)] id : :: core :: primitive :: u32 , delegate : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] amount : :: core :: primitive :: u128 , } , # [codec (index = 20)] # [doc = "Cancel all of some asset approved for delegated transfer by a third-party account."] # [doc = ""] # [doc = "Origin must be Signed and there must be an approval in place between signer and"] # [doc = "`delegate`."] # [doc = ""] # [doc = "Unreserves any deposit previously reserved by `approve_transfer` for the approval."] # [doc = ""] # [doc = "- `id`: The identifier of the asset."] # [doc = "- `delegate`: The account delegated permission to transfer asset."] # [doc = ""] # [doc = "Emits `ApprovalCancelled` on success."] # [doc = ""] # [doc = "Weight: `O(1)`"] cancel_approval { # [codec (compact)] id : :: core :: primitive :: u32 , delegate : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 21)] # [doc = "Cancel all of some asset approved for delegated transfer by a third-party account."] # [doc = ""] # [doc = "Origin must be either ForceOrigin or Signed origin with the signer being the Admin"] # [doc = "account of the asset `id`."] # [doc = ""] # [doc = "Unreserves any deposit previously reserved by `approve_transfer` for the approval."] # [doc = ""] # [doc = "- `id`: The identifier of the asset."] # [doc = "- `delegate`: The account delegated permission to transfer asset."] # [doc = ""] # [doc = "Emits `ApprovalCancelled` on success."] # [doc = ""] # [doc = "Weight: `O(1)`"] force_cancel_approval { # [codec (compact)] id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , delegate : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 22)] # [doc = "Transfer some asset balance from a previously delegated account to some third-party"] # [doc = "account."] # [doc = ""] # [doc = "Origin must be Signed and there must be an approval in place by the `owner` to the"] # [doc = "signer."] # [doc = ""] # [doc = "If the entire amount approved for transfer is transferred, then any deposit previously"] # [doc = "reserved by `approve_transfer` is unreserved."] # [doc = ""] # [doc = "- `id`: The identifier of the asset."] # [doc = "- `owner`: The account which previously approved for a transfer of at least `amount` and"] # [doc = "from which the asset balance will be withdrawn."] # [doc = "- `destination`: The account to which the asset balance of `amount` will be transferred."] # [doc = "- `amount`: The amount of assets to transfer."] # [doc = ""] # [doc = "Emits `TransferredApproved` on success."] # [doc = ""] # [doc = "Weight: `O(1)`"] transfer_approved { # [codec (compact)] id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , destination : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] amount : :: core :: primitive :: u128 , } , # [codec (index = 23)] # [doc = "Create an asset account for non-provider assets."] # [doc = ""] # [doc = "A deposit will be taken from the signer account."] # [doc = ""] # [doc = "- `origin`: Must be Signed; the signer account must have sufficient funds for a deposit"] # [doc = "  to be taken."] # [doc = "- `id`: The identifier of the asset for the account to be created."] # [doc = ""] # [doc = "Emits `Touched` event when successful."] touch { # [codec (compact)] id : :: core :: primitive :: u32 , } , # [codec (index = 24)] # [doc = "Return the deposit (if any) of an asset account."] # [doc = ""] # [doc = "The origin must be Signed."] # [doc = ""] # [doc = "- `id`: The identifier of the asset for the account to be created."] # [doc = "- `allow_burn`: If `true` then assets may be destroyed in order to complete the refund."] # [doc = ""] # [doc = "Emits `Refunded` event when successful."] refund { # [codec (compact)] id : :: core :: primitive :: u32 , allow_burn : :: core :: primitive :: bool , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Account balance must be greater than or equal to the transfer amount."] BalanceLow , # [codec (index = 1)] # [doc = "The account to alter does not exist."] NoAccount , # [codec (index = 2)] # [doc = "The signing account has no permission to do the operation."] NoPermission , # [codec (index = 3)] # [doc = "The given asset ID is unknown."] Unknown , # [codec (index = 4)] # [doc = "The origin account is frozen."] Frozen , # [codec (index = 5)] # [doc = "The asset ID is already taken."] InUse , # [codec (index = 6)] # [doc = "Invalid witness data given."] BadWitness , # [codec (index = 7)] # [doc = "Minimum balance should be non-zero."] MinBalanceZero , # [codec (index = 8)] # [doc = "Unable to increment the consumer reference counters on the account. Either no provider"] # [doc = "reference exists to allow a non-zero balance of a non-self-sufficient asset, or the"] # [doc = "maximum number of consumers has been reached."] NoProvider , # [codec (index = 9)] # [doc = "Invalid metadata given."] BadMetadata , # [codec (index = 10)] # [doc = "No approval exists that would allow the transfer."] Unapproved , # [codec (index = 11)] # [doc = "The source account would not survive the transfer and it needs to stay alive."] WouldDie , # [codec (index = 12)] # [doc = "The asset-account already exists."] AlreadyExists , # [codec (index = 13)] # [doc = "The asset-account doesn't have an associated deposit."] NoDeposit , # [codec (index = 14)] # [doc = "The operation would result in funds being burned."] WouldBurn , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "Some asset class was created."] Created { asset_id : :: core :: primitive :: u32 , creator : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 1)] # [doc = "Some assets were issued."] Issued { asset_id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , total_supply : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Some assets were transferred."] Transferred { asset_id : :: core :: primitive :: u32 , from : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , to : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "Some assets were destroyed."] Burned { asset_id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , balance : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "The management team changed."] TeamChanged { asset_id : :: core :: primitive :: u32 , issuer : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , admin : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , freezer : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 5)] # [doc = "The owner changed."] OwnerChanged { asset_id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 6)] # [doc = "Some account `who` was frozen."] Frozen { asset_id : :: core :: primitive :: u32 , who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 7)] # [doc = "Some account `who` was thawed."] Thawed { asset_id : :: core :: primitive :: u32 , who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 8)] # [doc = "Some asset `asset_id` was frozen."] AssetFrozen { asset_id : :: core :: primitive :: u32 , } , # [codec (index = 9)] # [doc = "Some asset `asset_id` was thawed."] AssetThawed { asset_id : :: core :: primitive :: u32 , } , # [codec (index = 10)] # [doc = "An asset class was destroyed."] Destroyed { asset_id : :: core :: primitive :: u32 , } , # [codec (index = 11)] # [doc = "Some asset class was force-created."] ForceCreated { asset_id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 12)] # [doc = "New metadata has been set for an asset."] MetadataSet { asset_id : :: core :: primitive :: u32 , name : :: std :: vec :: Vec < :: core :: primitive :: u8 > , symbol : :: std :: vec :: Vec < :: core :: primitive :: u8 > , decimals : :: core :: primitive :: u8 , is_frozen : :: core :: primitive :: bool , } , # [codec (index = 13)] # [doc = "Metadata has been cleared for an asset."] MetadataCleared { asset_id : :: core :: primitive :: u32 , } , # [codec (index = 14)] # [doc = "(Additional) funds have been approved for transfer to a destination account."] ApprovedTransfer { asset_id : :: core :: primitive :: u32 , source : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , delegate : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 15)] # [doc = "An approval for account `delegate` was cancelled by `owner`."] ApprovalCancelled { asset_id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , delegate : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 16)] # [doc = "An `amount` was transferred in its entirety from `owner` to `destination` by"] # [doc = "the approved `delegate`."] TransferredApproved { asset_id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , delegate : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , destination : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 17)] # [doc = "An asset has had its attributes changed by the `Force` origin."] AssetStatusChanged { asset_id : :: core :: primitive :: u32 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Approval < _0 , _1 > { pub amount : _0 , pub deposit : _0 , # [codec (skip)] pub __subxt_unused_type_params : :: core :: marker :: PhantomData < _1 > } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AssetAccount < _0 , _1 , _2 > { pub balance : _0 , pub is_frozen : :: core :: primitive :: bool , pub reason : runtime_types :: pallet_assets :: types :: ExistenceReason < _0 > , pub extra : _2 , # [codec (skip)] pub __subxt_unused_type_params : :: core :: marker :: PhantomData < _1 > } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AssetDetails < _0 , _1 , _2 > { pub owner : _1 , pub issuer : _1 , pub admin : _1 , pub freezer : _1 , pub supply : _0 , pub deposit : _0 , pub min_balance : _0 , pub is_sufficient : :: core :: primitive :: bool , pub accounts : :: core :: primitive :: u32 , pub sufficients : :: core :: primitive :: u32 , pub approvals : :: core :: primitive :: u32 , pub is_frozen : :: core :: primitive :: bool , # [codec (skip)] pub __subxt_unused_type_params : :: core :: marker :: PhantomData < _2 > } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AssetMetadata < _0 , _1 > { pub deposit : _0 , pub name : _1 , pub symbol : _1 , pub decimals : :: core :: primitive :: u8 , pub is_frozen : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct DestroyWitness { # [codec (compact)] pub accounts : :: core :: primitive :: u32 , # [codec (compact)] pub sufficients : :: core :: primitive :: u32 , # [codec (compact)] pub approvals : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum ExistenceReason < _0 > { # [codec (index = 0)] Consumer , # [codec (index = 1)] Sufficient , # [codec (index = 2)] DepositHeld (_0 ,) , # [codec (index = 3)] DepositRefunded , } } } pub mod pallet_authorship { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Provide a set of uncles."] set_uncles { new_uncles : :: std :: vec :: Vec < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > > , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "The uncle parent not in the chain."] InvalidUncleParent , # [codec (index = 1)] # [doc = "Uncles already set in the block."] UnclesAlreadySet , # [codec (index = 2)] # [doc = "Too many uncles."] TooManyUncles , # [codec (index = 3)] # [doc = "The uncle is genesis."] GenesisUncle , # [codec (index = 4)] # [doc = "The uncle is too high in chain."] TooHighUncle , # [codec (index = 5)] # [doc = "The uncle is already included."] UncleAlreadyIncluded , # [codec (index = 6)] # [doc = "The uncle isn't recent enough to be included."] OldUncle , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum UncleEntryItem < _0 , _1 , _2 > { # [codec (index = 0)] InclusionHeight (_0 ,) , # [codec (index = 1)] Uncle (_1 , :: core :: option :: Option < _2 > ,) , } } pub mod pallet_babe { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Report authority equivocation/misbehavior. This method will verify"] # [doc = "the equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence will"] # [doc = "be reported."] report_equivocation { equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_consensus_slots :: EquivocationProof < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , runtime_types :: sp_consensus_babe :: app :: Public > > , key_owner_proof : runtime_types :: sp_session :: MembershipProof , } , # [codec (index = 1)] # [doc = "Report authority equivocation/misbehavior. This method will verify"] # [doc = "the equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence will"] # [doc = "be reported."] # [doc = "This extrinsic must be called unsigned and it is expected that only"] # [doc = "block authors will call it (validated in `ValidateUnsigned`), as such"] # [doc = "if the block author is defined it will be defined as the equivocation"] # [doc = "reporter."] report_equivocation_unsigned { equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_consensus_slots :: EquivocationProof < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , runtime_types :: sp_consensus_babe :: app :: Public > > , key_owner_proof : runtime_types :: sp_session :: MembershipProof , } , # [codec (index = 2)] # [doc = "Plan an epoch config change. The epoch config change is recorded and will be enacted on"] # [doc = "the next call to `enact_epoch_change`. The config will be activated one epoch after."] # [doc = "Multiple calls to this method will replace any existing planned config change that had"] # [doc = "not been enacted yet."] plan_config_change { config : runtime_types :: sp_consensus_babe :: digests :: NextConfigDescriptor , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "An equivocation proof provided as part of an equivocation report is invalid."] InvalidEquivocationProof , # [codec (index = 1)] # [doc = "A key ownership proof provided as part of an equivocation report is invalid."] InvalidKeyOwnershipProof , # [codec (index = 2)] # [doc = "A given equivocation report is valid but already previously reported."] DuplicateOffenceReport , # [codec (index = 3)] # [doc = "Submitted configuration is invalid."] InvalidConfiguration , } } } pub mod pallet_bags_list { use super :: runtime_types ; pub mod list { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Bag { pub head : :: core :: option :: Option < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , pub tail : :: core :: option :: Option < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum ListError { # [codec (index = 0)] Duplicate , # [codec (index = 1)] NotHeavier , # [codec (index = 2)] NotInSameBag , # [codec (index = 3)] NodeNotFound , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Node { pub id : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , pub prev : :: core :: option :: Option < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , pub next : :: core :: option :: Option < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , pub bag_upper : :: core :: primitive :: u64 , pub score : :: core :: primitive :: u64 , } } pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Declare that some `dislocated` account has, through rewards or penalties, sufficiently"] # [doc = "changed its score that it should properly fall into a different bag than its current"] # [doc = "one."] # [doc = ""] # [doc = "Anyone can call this function about any potentially dislocated account."] # [doc = ""] # [doc = "Will always update the stored score of `dislocated` to the correct score, based on"] # [doc = "`ScoreProvider`."] # [doc = ""] # [doc = "If `dislocated` does not exists, it returns an error."] rebag { dislocated : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 1)] # [doc = "Move the caller's Id directly in front of `lighter`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and can only be called by the Id of"] # [doc = "the account going in front of `lighter`."] # [doc = ""] # [doc = "Only works if"] # [doc = "- both nodes are within the same bag,"] # [doc = "- and `origin` has a greater `Score` than `lighter`."] put_in_front_of { lighter : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "A error in the list interface implementation."] List (runtime_types :: pallet_bags_list :: list :: ListError ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "Moved an account from one bag to another."] Rebagged { who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , from : :: core :: primitive :: u64 , to : :: core :: primitive :: u64 , } , # [codec (index = 1)] # [doc = "Updated the score of some account to the given amount."] ScoreUpdated { who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , new_score : :: core :: primitive :: u64 , } , } } } pub mod pallet_balances { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Transfer some liquid free balance to another account."] # [doc = ""] # [doc = "`transfer` will set the `FreeBalance` of the sender and receiver."] # [doc = "If the sender's account is below the existential deposit as a result"] # [doc = "of the transfer, the account will be reaped."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the transactor."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Dependent on arguments but not critical, given proper implementations for input config"] # [doc = "  types. See related functions below."] # [doc = "- It contains a limited number of reads and writes internally and no complex"] # [doc = "  computation."] # [doc = ""] # [doc = "Related functions:"] # [doc = ""] # [doc = "  - `ensure_can_withdraw` is always called internally but has a bounded complexity."] # [doc = "  - Transferring balances to accounts that did not exist before will cause"] # [doc = "    `T::OnNewAccount::on_new_account` to be called."] # [doc = "  - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`."] # [doc = "  - `transfer_keep_alive` works the same way as `transfer`, but has an additional check"] # [doc = "    that the transfer will not kill the origin account."] # [doc = "---------------------------------"] # [doc = "- Origin account is already in memory, so no DB operations for them."] # [doc = "# </weight>"] transfer { dest : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Set the balances of a given account."] # [doc = ""] # [doc = "This will alter `FreeBalance` and `ReservedBalance` in storage. it will"] # [doc = "also alter the total issuance of the system (`TotalIssuance`) appropriately."] # [doc = "If the new free or reserved balance is below the existential deposit,"] # [doc = "it will reset the account nonce (`frame_system::AccountNonce`)."] # [doc = ""] # [doc = "The dispatch origin for this call is `root`."] set_balance { who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] new_free : :: core :: primitive :: u128 , # [codec (compact)] new_reserved : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Exactly as `transfer`, except the origin must be root and the source account may be"] # [doc = "specified."] # [doc = "# <weight>"] # [doc = "- Same as transfer, but additional read and write because the source account is not"] # [doc = "  assumed to be in the overlay."] # [doc = "# </weight>"] force_transfer { source : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , dest : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "Same as the [`transfer`] call, but with a check that the transfer will not kill the"] # [doc = "origin account."] # [doc = ""] # [doc = "99% of the time you want [`transfer`] instead."] # [doc = ""] # [doc = "[`transfer`]: struct.Pallet.html#method.transfer"] transfer_keep_alive { dest : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "Transfer the entire transferable balance from the caller account."] # [doc = ""] # [doc = "NOTE: This function only attempts to transfer _transferable_ balances. This means that"] # [doc = "any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be"] # [doc = "transferred by this function. To ensure that this function results in a killed account,"] # [doc = "you might need to prepare the account by removing any reference counters, storage"] # [doc = "deposits, etc..."] # [doc = ""] # [doc = "The dispatch origin of this call must be Signed."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all"] # [doc = "  of the funds the account has, causing the sender account to be killed (false), or"] # [doc = "  transfer everything except at least the existential deposit, which will guarantee to"] # [doc = "  keep the sender account alive (true). # <weight>"] # [doc = "- O(1). Just like transfer, but reading the user's transferable balance first."] # [doc = "  #</weight>"] transfer_all { dest : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , keep_alive : :: core :: primitive :: bool , } , # [codec (index = 5)] # [doc = "Unreserve some balance from a user by force."] # [doc = ""] # [doc = "Can only be called by ROOT."] force_unreserve { who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , amount : :: core :: primitive :: u128 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Vesting balance too high to send value"] VestingBalance , # [codec (index = 1)] # [doc = "Account liquidity restrictions prevent withdrawal"] LiquidityRestrictions , # [codec (index = 2)] # [doc = "Balance too low to send value"] InsufficientBalance , # [codec (index = 3)] # [doc = "Value too low to create account due to existential deposit"] ExistentialDeposit , # [codec (index = 4)] # [doc = "Transfer/payment would kill account"] KeepAlive , # [codec (index = 5)] # [doc = "A vesting schedule already exists for this account"] ExistingVestingSchedule , # [codec (index = 6)] # [doc = "Beneficiary account must pre-exist"] DeadAccount , # [codec (index = 7)] # [doc = "Number of named reserves exceed MaxReserves"] TooManyReserves , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "An account was created with some free balance."] Endowed { account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , free_balance : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "An account was removed whose balance was non-zero but below ExistentialDeposit,"] # [doc = "resulting in an outright loss."] DustLost { account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Transfer succeeded."] Transfer { from : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , to : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "A balance was set by root."] BalanceSet { who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , free : :: core :: primitive :: u128 , reserved : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "Some balance was reserved (moved from free to reserved)."] Reserved { who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "Some balance was unreserved (moved from reserved to free)."] Unreserved { who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "Some balance was moved from the reserve of the first account to the second account."] # [doc = "Final argument indicates the destination balance type."] ReserveRepatriated { from : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , to : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , destination_status : runtime_types :: frame_support :: traits :: tokens :: misc :: BalanceStatus , } , # [codec (index = 7)] # [doc = "Some amount was deposited (e.g. for transaction fees)."] Deposit { who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 8)] # [doc = "Some amount was withdrawn from the account (e.g. for transaction fees)."] Withdraw { who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 9)] # [doc = "Some amount was removed from the account (e.g. for misbehavior)."] Slashed { who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AccountData < _0 > { pub free : _0 , pub reserved : _0 , pub misc_frozen : _0 , pub fee_frozen : _0 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct BalanceLock < _0 > { pub id : [:: core :: primitive :: u8 ; 8usize] , pub amount : _0 , pub reasons : runtime_types :: pallet_balances :: Reasons , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Reasons { # [codec (index = 0)] Fee , # [codec (index = 1)] Misc , # [codec (index = 2)] All , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Releases { # [codec (index = 0)] V1_0_0 , # [codec (index = 1)] V2_0_0 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ReserveData < _0 , _1 > { pub id : _0 , pub amount : _1 , } } pub mod pallet_collective { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Set the collective's membership."] # [doc = ""] # [doc = "- `new_members`: The new member list. Be nice to the chain and provide it sorted."] # [doc = "- `prime`: The prime member whose vote sets the default."] # [doc = "- `old_count`: The upper bound for the previous number of members in storage. Used for"] # [doc = "  weight estimation."] # [doc = ""] # [doc = "Requires root origin."] # [doc = ""] # [doc = "NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but"] # [doc = "      the weight estimations rely on it to estimate dispatchable weight."] # [doc = ""] # [doc = "# WARNING:"] # [doc = ""] # [doc = "The `pallet-collective` can also be managed by logic outside of the pallet through the"] # [doc = "implementation of the trait [`ChangeMembers`]."] # [doc = "Any call to `set_members` must be careful that the member set doesn't get out of sync"] # [doc = "with other logic managing the member set."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(MP + N)` where:"] # [doc = "  - `M` old-members-count (code- and governance-bounded)"] # [doc = "  - `N` new-members-count (code- and governance-bounded)"] # [doc = "  - `P` proposals-count (code-bounded)"] # [doc = "- DB:"] # [doc = "  - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the"] # [doc = "    members"] # [doc = "  - 1 storage read (codec `O(P)`) for reading the proposals"] # [doc = "  - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal"] # [doc = "  - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one"] # [doc = "# </weight>"] set_members { new_members : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , prime : :: core :: option :: Option < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , old_count : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Dispatch a proposal from a member using the `Member` origin."] # [doc = ""] # [doc = "Origin must be a member of the collective."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching"] # [doc = "  `proposal`"] # [doc = "- DB: 1 read (codec `O(M)`) + DB access of `proposal`"] # [doc = "- 1 event"] # [doc = "# </weight>"] execute { proposal : :: std :: boxed :: Box < runtime_types :: alphanet_runtime :: RuntimeCall > , # [codec (compact)] length_bound : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Add a new proposal to either be voted on or executed directly."] # [doc = ""] # [doc = "Requires the sender to be member."] # [doc = ""] # [doc = "`threshold` determines whether `proposal` is executed directly (`threshold < 2`)"] # [doc = "or put up for voting."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(B + M + P1)` or `O(B + M + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - branching is influenced by `threshold` where:"] # [doc = "    - `P1` is proposal execution complexity (`threshold < 2`)"] # [doc = "    - `P2` is proposals-count (code-bounded) (`threshold >= 2`)"] # [doc = "- DB:"] # [doc = "  - 1 storage read `is_member` (codec `O(M)`)"] # [doc = "  - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)"] # [doc = "  - DB accesses influenced by `threshold`:"] # [doc = "    - EITHER storage accesses done by `proposal` (`threshold < 2`)"] # [doc = "    - OR proposal insertion (`threshold <= 2`)"] # [doc = "      - 1 storage mutation `Proposals` (codec `O(P2)`)"] # [doc = "      - 1 storage mutation `ProposalCount` (codec `O(1)`)"] # [doc = "      - 1 storage write `ProposalOf` (codec `O(B)`)"] # [doc = "      - 1 storage write `Voting` (codec `O(M)`)"] # [doc = "  - 1 event"] # [doc = "# </weight>"] propose { # [codec (compact)] threshold : :: core :: primitive :: u32 , proposal : :: std :: boxed :: Box < runtime_types :: alphanet_runtime :: RuntimeCall > , # [codec (compact)] length_bound : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "Add an aye or nay vote for the sender to the given proposal."] # [doc = ""] # [doc = "Requires the sender to be a member."] # [doc = ""] # [doc = "Transaction fees will be waived if the member is voting on any particular proposal"] # [doc = "for the first time and the call is successful. Subsequent vote changes will charge a"] # [doc = "fee."] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(M)` where `M` is members-count (code- and governance-bounded)"] # [doc = "- DB:"] # [doc = "  - 1 storage read `Members` (codec `O(M)`)"] # [doc = "  - 1 storage mutation `Voting` (codec `O(M)`)"] # [doc = "- 1 event"] # [doc = "# </weight>"] vote { proposal : :: subxt :: ext :: sp_core :: H256 , # [codec (compact)] index : :: core :: primitive :: u32 , approve : :: core :: primitive :: bool , } , # [codec (index = 4)] # [doc = "Close a vote that is either approved, disapproved or whose voting period has ended."] # [doc = ""] # [doc = "May be called by any signed account in order to finish voting and close the proposal."] # [doc = ""] # [doc = "If called before the end of the voting period it will only close the vote if it is"] # [doc = "has enough votes to be approved or disapproved."] # [doc = ""] # [doc = "If called after the end of the voting period abstentions are counted as rejections"] # [doc = "unless there is a prime member set and the prime member cast an approval."] # [doc = ""] # [doc = "If the close operation completes successfully with disapproval, the transaction fee will"] # [doc = "be waived. Otherwise execution of the approved operation will be charged to the caller."] # [doc = ""] # [doc = "+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed"] # [doc = "proposal."] # [doc = "+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via"] # [doc = "`storage::read` so it is `size_of::<u32>() == 4` larger than the pure length."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(B + M + P1 + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - `P1` is the complexity of `proposal` preimage."] # [doc = "  - `P2` is proposal-count (code-bounded)"] # [doc = "- DB:"] # [doc = " - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)"] # [doc = " - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec"] # [doc = "   `O(P2)`)"] # [doc = " - any mutations done while executing `proposal` (`P1`)"] # [doc = "- up to 3 events"] # [doc = "# </weight>"] close_old_weight { proposal_hash : :: subxt :: ext :: sp_core :: H256 , # [codec (compact)] index : :: core :: primitive :: u32 , # [codec (compact)] proposal_weight_bound : runtime_types :: sp_weights :: OldWeight , # [codec (compact)] length_bound : :: core :: primitive :: u32 , } , # [codec (index = 5)] # [doc = "Disapprove a proposal, close, and remove it from the system, regardless of its current"] # [doc = "state."] # [doc = ""] # [doc = "Must be called by the Root origin."] # [doc = ""] # [doc = "Parameters:"] # [doc = "* `proposal_hash`: The hash of the proposal that should be disapproved."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Complexity: O(P) where P is the number of max proposals"] # [doc = "DB Weight:"] # [doc = "* Reads: Proposals"] # [doc = "* Writes: Voting, Proposals, ProposalOf"] # [doc = "# </weight>"] disapprove_proposal { proposal_hash : :: subxt :: ext :: sp_core :: H256 , } , # [codec (index = 6)] # [doc = "Close a vote that is either approved, disapproved or whose voting period has ended."] # [doc = ""] # [doc = "May be called by any signed account in order to finish voting and close the proposal."] # [doc = ""] # [doc = "If called before the end of the voting period it will only close the vote if it is"] # [doc = "has enough votes to be approved or disapproved."] # [doc = ""] # [doc = "If called after the end of the voting period abstentions are counted as rejections"] # [doc = "unless there is a prime member set and the prime member cast an approval."] # [doc = ""] # [doc = "If the close operation completes successfully with disapproval, the transaction fee will"] # [doc = "be waived. Otherwise execution of the approved operation will be charged to the caller."] # [doc = ""] # [doc = "+ `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed"] # [doc = "proposal."] # [doc = "+ `length_bound`: The upper bound for the length of the proposal in storage. Checked via"] # [doc = "`storage::read` so it is `size_of::<u32>() == 4` larger than the pure length."] # [doc = ""] # [doc = "# <weight>"] # [doc = "## Weight"] # [doc = "- `O(B + M + P1 + P2)` where:"] # [doc = "  - `B` is `proposal` size in bytes (length-fee-bounded)"] # [doc = "  - `M` is members-count (code- and governance-bounded)"] # [doc = "  - `P1` is the complexity of `proposal` preimage."] # [doc = "  - `P2` is proposal-count (code-bounded)"] # [doc = "- DB:"] # [doc = " - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)"] # [doc = " - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec"] # [doc = "   `O(P2)`)"] # [doc = " - any mutations done while executing `proposal` (`P1`)"] # [doc = "- up to 3 events"] # [doc = "# </weight>"] close { proposal_hash : :: subxt :: ext :: sp_core :: H256 , # [codec (compact)] index : :: core :: primitive :: u32 , proposal_weight_bound : runtime_types :: sp_weights :: weight_v2 :: Weight , # [codec (compact)] length_bound : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Account is not a member"] NotMember , # [codec (index = 1)] # [doc = "Duplicate proposals not allowed"] DuplicateProposal , # [codec (index = 2)] # [doc = "Proposal must exist"] ProposalMissing , # [codec (index = 3)] # [doc = "Mismatched index"] WrongIndex , # [codec (index = 4)] # [doc = "Duplicate vote ignored"] DuplicateVote , # [codec (index = 5)] # [doc = "Members are already initialized!"] AlreadyInitialized , # [codec (index = 6)] # [doc = "The close call was made too early, before the end of the voting."] TooEarly , # [codec (index = 7)] # [doc = "There can only be a maximum of `MaxProposals` active proposals."] TooManyProposals , # [codec (index = 8)] # [doc = "The given weight bound for the proposal was too low."] WrongProposalWeight , # [codec (index = 9)] # [doc = "The given length bound for the proposal was too low."] WrongProposalLength , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A motion (given hash) has been proposed (by given account) with a threshold (given"] # [doc = "`MemberCount`)."] Proposed { account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , proposal_index : :: core :: primitive :: u32 , proposal_hash : :: subxt :: ext :: sp_core :: H256 , threshold : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "A motion (given hash) has been voted on by given account, leaving"] # [doc = "a tally (yes votes and no votes given respectively as `MemberCount`)."] Voted { account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , proposal_hash : :: subxt :: ext :: sp_core :: H256 , voted : :: core :: primitive :: bool , yes : :: core :: primitive :: u32 , no : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "A motion was approved by the required threshold."] Approved { proposal_hash : :: subxt :: ext :: sp_core :: H256 , } , # [codec (index = 3)] # [doc = "A motion was not approved by the required threshold."] Disapproved { proposal_hash : :: subxt :: ext :: sp_core :: H256 , } , # [codec (index = 4)] # [doc = "A motion was executed; result will be `Ok` if it returned without error."] Executed { proposal_hash : :: subxt :: ext :: sp_core :: H256 , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 5)] # [doc = "A single member did some action; result will be `Ok` if it returned without error."] MemberExecuted { proposal_hash : :: subxt :: ext :: sp_core :: H256 , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 6)] # [doc = "A proposal was closed because its threshold was reached or after its duration was up."] Closed { proposal_hash : :: subxt :: ext :: sp_core :: H256 , yes : :: core :: primitive :: u32 , no : :: core :: primitive :: u32 , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum RawOrigin < _0 > { # [codec (index = 0)] Members (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , # [codec (index = 1)] Member (_0 ,) , # [codec (index = 2)] _Phantom , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Votes < _0 , _1 > { pub index : _1 , pub threshold : _1 , pub ayes : :: std :: vec :: Vec < _0 > , pub nays : :: std :: vec :: Vec < _0 > , pub end : _1 , } } pub mod pallet_democracy { use super :: runtime_types ; pub mod conviction { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Conviction { # [codec (index = 0)] None , # [codec (index = 1)] Locked1x , # [codec (index = 2)] Locked2x , # [codec (index = 3)] Locked3x , # [codec (index = 4)] Locked4x , # [codec (index = 5)] Locked5x , # [codec (index = 6)] Locked6x , } } pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Propose a sensitive action to be taken."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the sender must"] # [doc = "have funds to cover the deposit."] # [doc = ""] # [doc = "- `proposal_hash`: The hash of the proposal preimage."] # [doc = "- `value`: The amount of deposit (must be at least `MinimumDeposit`)."] # [doc = ""] # [doc = "Emits `Proposed`."] # [doc = ""] # [doc = "Weight: `O(p)`"] propose { proposal_hash : :: subxt :: ext :: sp_core :: H256 , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Signals agreement with a particular proposal."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the sender"] # [doc = "must have funds to cover the deposit, equal to the original deposit."] # [doc = ""] # [doc = "- `proposal`: The index of the proposal to second."] # [doc = "- `seconds_upper_bound`: an upper bound on the current number of seconds on this"] # [doc = "  proposal. Extrinsic is weighted according to this value with no refund."] # [doc = ""] # [doc = "Weight: `O(S)` where S is the number of seconds a proposal already has."] second { # [codec (compact)] proposal : :: core :: primitive :: u32 , # [codec (compact)] seconds_upper_bound : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;"] # [doc = "otherwise it is a vote to keep the status quo."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `ref_index`: The index of the referendum to vote for."] # [doc = "- `vote`: The vote configuration."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter has voted on."] vote { # [codec (compact)] ref_index : :: core :: primitive :: u32 , vote : runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > , } , # [codec (index = 3)] # [doc = "Schedule an emergency cancellation of a referendum. Cannot happen twice to the same"] # [doc = "referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be `CancellationOrigin`."] # [doc = ""] # [doc = "-`ref_index`: The index of the referendum to cancel."] # [doc = ""] # [doc = "Weight: `O(1)`."] emergency_cancel { ref_index : :: core :: primitive :: u32 , } , # [codec (index = 4)] # [doc = "Schedule a referendum to be tabled once it is legal to schedule an external"] # [doc = "referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be `ExternalOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Weight: `O(V)` with V number of vetoers in the blacklist of proposal."] # [doc = "  Decoding vec of length V. Charged as maximum"] external_propose { proposal_hash : :: subxt :: ext :: sp_core :: H256 , } , # [codec (index = 5)] # [doc = "Schedule a majority-carries referendum to be tabled next once it is legal to schedule"] # [doc = "an external referendum."] # [doc = ""] # [doc = "The dispatch of this call must be `ExternalMajorityOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Unlike `external_propose`, blacklisting has no effect on this and it may replace a"] # [doc = "pre-scheduled `external_propose` call."] # [doc = ""] # [doc = "Weight: `O(1)`"] external_propose_majority { proposal_hash : :: subxt :: ext :: sp_core :: H256 , } , # [codec (index = 6)] # [doc = "Schedule a negative-turnout-bias referendum to be tabled next once it is legal to"] # [doc = "schedule an external referendum."] # [doc = ""] # [doc = "The dispatch of this call must be `ExternalDefaultOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal."] # [doc = ""] # [doc = "Unlike `external_propose`, blacklisting has no effect on this and it may replace a"] # [doc = "pre-scheduled `external_propose` call."] # [doc = ""] # [doc = "Weight: `O(1)`"] external_propose_default { proposal_hash : :: subxt :: ext :: sp_core :: H256 , } , # [codec (index = 7)] # [doc = "Schedule the currently externally-proposed majority-carries referendum to be tabled"] # [doc = "immediately. If there is no externally-proposed referendum currently, or if there is one"] # [doc = "but it is not a majority-carries referendum then it fails."] # [doc = ""] # [doc = "The dispatch of this call must be `FastTrackOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The hash of the current external proposal."] # [doc = "- `voting_period`: The period that is allowed for voting on this proposal."] # [doc = "\tMust be always greater than zero."] # [doc = "\tFor `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`."] # [doc = "- `delay`: The number of block after voting has ended in approval and this should be"] # [doc = "  enacted. This doesn't have a minimum amount."] # [doc = ""] # [doc = "Emits `Started`."] # [doc = ""] # [doc = "Weight: `O(1)`"] fast_track { proposal_hash : :: subxt :: ext :: sp_core :: H256 , voting_period : :: core :: primitive :: u32 , delay : :: core :: primitive :: u32 , } , # [codec (index = 8)] # [doc = "Veto and blacklist the external proposal hash."] # [doc = ""] # [doc = "The dispatch origin of this call must be `VetoOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of the proposal to veto and blacklist."] # [doc = ""] # [doc = "Emits `Vetoed`."] # [doc = ""] # [doc = "Weight: `O(V + log(V))` where V is number of `existing vetoers`"] veto_external { proposal_hash : :: subxt :: ext :: sp_core :: H256 , } , # [codec (index = 9)] # [doc = "Remove a referendum."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "- `ref_index`: The index of the referendum to cancel."] # [doc = ""] # [doc = "# Weight: `O(1)`."] cancel_referendum { # [codec (compact)] ref_index : :: core :: primitive :: u32 , } , # [codec (index = 10)] # [doc = "Cancel a proposal queued for enactment."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "- `which`: The index of the referendum to cancel."] # [doc = ""] # [doc = "Weight: `O(D)` where `D` is the items in the dispatch queue. Weighted as `D = 10`."] cancel_queued { which : :: core :: primitive :: u32 , } , # [codec (index = 11)] # [doc = "Delegate the voting power (with some given conviction) of the sending account."] # [doc = ""] # [doc = "The balance delegated is locked for as long as it's delegated, and thereafter for the"] # [doc = "time appropriate for the conviction's lock period."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_, and the signing account must either:"] # [doc = "  - be delegating already; or"] # [doc = "  - have no voting activity (if there is, then it will need to be removed/consolidated"] # [doc = "    through `reap_vote` or `unvote`)."] # [doc = ""] # [doc = "- `to`: The account whose voting the `target` account's voting power will follow."] # [doc = "- `conviction`: The conviction that will be attached to the delegated votes. When the"] # [doc = "  account is undelegated, the funds will be locked for the corresponding period."] # [doc = "- `balance`: The amount of the account's balance to be used in delegating. This must not"] # [doc = "  be more than the account's current balance."] # [doc = ""] # [doc = "Emits `Delegated`."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter delegating to has"] # [doc = "  voted on. Weight is charged as if maximum votes."] delegate { to : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , conviction : runtime_types :: pallet_democracy :: conviction :: Conviction , balance : :: core :: primitive :: u128 , } , # [codec (index = 12)] # [doc = "Undelegate the voting power of the sending account."] # [doc = ""] # [doc = "Tokens may be unlocked following once an amount of time consistent with the lock period"] # [doc = "of the conviction with which the delegation was issued."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_ and the signing account must be"] # [doc = "currently delegating."] # [doc = ""] # [doc = "Emits `Undelegated`."] # [doc = ""] # [doc = "Weight: `O(R)` where R is the number of referendums the voter delegating to has"] # [doc = "  voted on. Weight is charged as if maximum votes."] undelegate , # [codec (index = 13)] # [doc = "Clears all public proposals."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Root_."] # [doc = ""] # [doc = "Weight: `O(1)`."] clear_public_proposals , # [codec (index = 14)] # [doc = "Register the preimage for an upcoming proposal. This doesn't require the proposal to be"] # [doc = "in the dispatch queue but does require a deposit, returned once enacted."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `encoded_proposal`: The preimage of a proposal."] # [doc = ""] # [doc = "Emits `PreimageNoted`."] # [doc = ""] # [doc = "Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."] note_preimage { encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 15)] # [doc = "Same as `note_preimage` but origin is `OperationalPreimageOrigin`."] note_preimage_operational { encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 16)] # [doc = "Register the preimage for an upcoming proposal. This requires the proposal to be"] # [doc = "in the dispatch queue. No deposit is needed. When this call is successful, i.e."] # [doc = "the preimage has not been uploaded before and matches some imminent proposal,"] # [doc = "no fee is paid."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `encoded_proposal`: The preimage of a proposal."] # [doc = ""] # [doc = "Emits `PreimageNoted`."] # [doc = ""] # [doc = "Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."] note_imminent_preimage { encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 17)] # [doc = "Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`."] note_imminent_preimage_operational { encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 18)] # [doc = "Remove an expired proposal preimage and collect the deposit."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `proposal_hash`: The preimage hash of a proposal."] # [doc = "- `proposal_length_upper_bound`: an upper bound on length of the proposal. Extrinsic is"] # [doc = "  weighted according to this value with no refund."] # [doc = ""] # [doc = "This will only work after `VotingPeriod` blocks from the time that the preimage was"] # [doc = "noted, if it's the same account doing it. If it's a different account, then it'll only"] # [doc = "work an additional `EnactmentPeriod` later."] # [doc = ""] # [doc = "Emits `PreimageReaped`."] # [doc = ""] # [doc = "Weight: `O(D)` where D is length of proposal."] reap_preimage { proposal_hash : :: subxt :: ext :: sp_core :: H256 , # [codec (compact)] proposal_len_upper_bound : :: core :: primitive :: u32 , } , # [codec (index = 19)] # [doc = "Unlock tokens that have an expired lock."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account to remove the lock on."] # [doc = ""] # [doc = "Weight: `O(R)` with R number of vote of target."] unlock { target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 20)] # [doc = "Remove a vote for a referendum."] # [doc = ""] # [doc = "If:"] # [doc = "- the referendum was cancelled, or"] # [doc = "- the referendum is ongoing, or"] # [doc = "- the referendum has ended such that"] # [doc = "  - the vote of the account was in opposition to the result; or"] # [doc = "  - there was no conviction to the account's vote; or"] # [doc = "  - the account made a split vote"] # [doc = "...then the vote is removed cleanly and a following call to `unlock` may result in more"] # [doc = "funds being available."] # [doc = ""] # [doc = "If, however, the referendum has ended and:"] # [doc = "- it finished corresponding to the vote of the account, and"] # [doc = "- the account made a standard vote with conviction, and"] # [doc = "- the lock period of the conviction is not over"] # [doc = "...then the lock will be aggregated into the overall account's lock, which may involve"] # [doc = "*overlocking* (where the two locks are combined into a single lock that is the maximum"] # [doc = "of both the amount locked and the time is it locked for)."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_, and the signer must have a vote"] # [doc = "registered for referendum `index`."] # [doc = ""] # [doc = "- `index`: The index of referendum of the vote to be removed."] # [doc = ""] # [doc = "Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on."] # [doc = "  Weight is calculated for the maximum number of vote."] remove_vote { index : :: core :: primitive :: u32 , } , # [codec (index = 21)] # [doc = "Remove a vote for a referendum."] # [doc = ""] # [doc = "If the `target` is equal to the signer, then this function is exactly equivalent to"] # [doc = "`remove_vote`. If not equal to the signer, then the vote must have expired,"] # [doc = "either because the referendum was cancelled, because the voter lost the referendum or"] # [doc = "because the conviction period is over."] # [doc = ""] # [doc = "The dispatch origin of this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account of the vote to be removed; this account must have voted for"] # [doc = "  referendum `index`."] # [doc = "- `index`: The index of referendum of the vote to be removed."] # [doc = ""] # [doc = "Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on."] # [doc = "  Weight is calculated for the maximum number of vote."] remove_other_vote { target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , index : :: core :: primitive :: u32 , } , # [codec (index = 22)] # [doc = "Enact a proposal from a referendum. For now we just make the weight be the maximum."] enact_proposal { proposal_hash : :: subxt :: ext :: sp_core :: H256 , index : :: core :: primitive :: u32 , } , # [codec (index = 23)] # [doc = "Permanently place a proposal into the blacklist. This prevents it from ever being"] # [doc = "proposed again."] # [doc = ""] # [doc = "If called on a queued public or external proposal, then this will result in it being"] # [doc = "removed. If the `ref_index` supplied is an active referendum with the proposal hash,"] # [doc = "then it will be cancelled."] # [doc = ""] # [doc = "The dispatch origin of this call must be `BlacklistOrigin`."] # [doc = ""] # [doc = "- `proposal_hash`: The proposal hash to blacklist permanently."] # [doc = "- `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be"] # [doc = "cancelled."] # [doc = ""] # [doc = "Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a"] # [doc = "  reasonable value)."] blacklist { proposal_hash : :: subxt :: ext :: sp_core :: H256 , maybe_ref_index : :: core :: option :: Option < :: core :: primitive :: u32 > , } , # [codec (index = 24)] # [doc = "Remove a proposal."] # [doc = ""] # [doc = "The dispatch origin of this call must be `CancelProposalOrigin`."] # [doc = ""] # [doc = "- `prop_index`: The index of the proposal to cancel."] # [doc = ""] # [doc = "Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`"] cancel_proposal { # [codec (compact)] prop_index : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Value too low"] ValueLow , # [codec (index = 1)] # [doc = "Proposal does not exist"] ProposalMissing , # [codec (index = 2)] # [doc = "Cannot cancel the same proposal twice"] AlreadyCanceled , # [codec (index = 3)] # [doc = "Proposal already made"] DuplicateProposal , # [codec (index = 4)] # [doc = "Proposal still blacklisted"] ProposalBlacklisted , # [codec (index = 5)] # [doc = "Next external proposal not simple majority"] NotSimpleMajority , # [codec (index = 6)] # [doc = "Invalid hash"] InvalidHash , # [codec (index = 7)] # [doc = "No external proposal"] NoProposal , # [codec (index = 8)] # [doc = "Identity may not veto a proposal twice"] AlreadyVetoed , # [codec (index = 9)] # [doc = "Preimage already noted"] DuplicatePreimage , # [codec (index = 10)] # [doc = "Not imminent"] NotImminent , # [codec (index = 11)] # [doc = "Too early"] TooEarly , # [codec (index = 12)] # [doc = "Imminent"] Imminent , # [codec (index = 13)] # [doc = "Preimage not found"] PreimageMissing , # [codec (index = 14)] # [doc = "Vote given for invalid referendum"] ReferendumInvalid , # [codec (index = 15)] # [doc = "Invalid preimage"] PreimageInvalid , # [codec (index = 16)] # [doc = "No proposals waiting"] NoneWaiting , # [codec (index = 17)] # [doc = "The given account did not vote on the referendum."] NotVoter , # [codec (index = 18)] # [doc = "The actor has no permission to conduct the action."] NoPermission , # [codec (index = 19)] # [doc = "The account is already delegating."] AlreadyDelegating , # [codec (index = 20)] # [doc = "Too high a balance was provided that the account cannot afford."] InsufficientFunds , # [codec (index = 21)] # [doc = "The account is not currently delegating."] NotDelegating , # [codec (index = 22)] # [doc = "The account currently has votes attached to it and the operation cannot succeed until"] # [doc = "these are removed, either through `unvote` or `reap_vote`."] VotesExist , # [codec (index = 23)] # [doc = "The instant referendum origin is currently disallowed."] InstantNotAllowed , # [codec (index = 24)] # [doc = "Delegation to oneself makes no sense."] Nonsense , # [codec (index = 25)] # [doc = "Invalid upper bound."] WrongUpperBound , # [codec (index = 26)] # [doc = "Maximum number of votes reached."] MaxVotesReached , # [codec (index = 27)] # [doc = "Maximum number of proposals reached."] TooManyProposals , # [codec (index = 28)] # [doc = "Voting period too low"] VotingPeriodLow , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A motion has been proposed by a public account."] Proposed { proposal_index : :: core :: primitive :: u32 , deposit : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "A public proposal has been tabled for referendum vote."] Tabled { proposal_index : :: core :: primitive :: u32 , deposit : :: core :: primitive :: u128 , depositors : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 2)] # [doc = "An external proposal has been tabled."] ExternalTabled , # [codec (index = 3)] # [doc = "A referendum has begun."] Started { ref_index : :: core :: primitive :: u32 , threshold : runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold , } , # [codec (index = 4)] # [doc = "A proposal has been approved by referendum."] Passed { ref_index : :: core :: primitive :: u32 , } , # [codec (index = 5)] # [doc = "A proposal has been rejected by referendum."] NotPassed { ref_index : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "A referendum has been cancelled."] Cancelled { ref_index : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "A proposal has been enacted."] Executed { ref_index : :: core :: primitive :: u32 , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 8)] # [doc = "An account has delegated their vote to another account."] Delegated { who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , target : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 9)] # [doc = "An account has cancelled a previous delegation operation."] Undelegated { account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 10)] # [doc = "An external proposal has been vetoed."] Vetoed { who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , proposal_hash : :: subxt :: ext :: sp_core :: H256 , until : :: core :: primitive :: u32 , } , # [codec (index = 11)] # [doc = "A proposal's preimage was noted, and the deposit taken."] PreimageNoted { proposal_hash : :: subxt :: ext :: sp_core :: H256 , who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , deposit : :: core :: primitive :: u128 , } , # [codec (index = 12)] # [doc = "A proposal preimage was removed and used (the deposit was returned)."] PreimageUsed { proposal_hash : :: subxt :: ext :: sp_core :: H256 , provider : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , deposit : :: core :: primitive :: u128 , } , # [codec (index = 13)] # [doc = "A proposal could not be executed because its preimage was invalid."] PreimageInvalid { proposal_hash : :: subxt :: ext :: sp_core :: H256 , ref_index : :: core :: primitive :: u32 , } , # [codec (index = 14)] # [doc = "A proposal could not be executed because its preimage was missing."] PreimageMissing { proposal_hash : :: subxt :: ext :: sp_core :: H256 , ref_index : :: core :: primitive :: u32 , } , # [codec (index = 15)] # [doc = "A registered preimage was removed and the deposit collected by the reaper."] PreimageReaped { proposal_hash : :: subxt :: ext :: sp_core :: H256 , provider : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , deposit : :: core :: primitive :: u128 , reaper : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 16)] # [doc = "A proposal_hash has been blacklisted permanently."] Blacklisted { proposal_hash : :: subxt :: ext :: sp_core :: H256 , } , # [codec (index = 17)] # [doc = "An account has voted in a referendum"] Voted { voter : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , ref_index : :: core :: primitive :: u32 , vote : runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > , } , # [codec (index = 18)] # [doc = "An account has secconded a proposal"] Seconded { seconder : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , prop_index : :: core :: primitive :: u32 , } , # [codec (index = 19)] # [doc = "A proposal got canceled."] ProposalCanceled { prop_index : :: core :: primitive :: u32 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Delegations < _0 > { pub votes : _0 , pub capital : _0 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum ReferendumInfo < _0 , _1 , _2 > { # [codec (index = 0)] Ongoing (runtime_types :: pallet_democracy :: types :: ReferendumStatus < _0 , _1 , _2 > ,) , # [codec (index = 1)] Finished { approved : :: core :: primitive :: bool , end : _0 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ReferendumStatus < _0 , _1 , _2 > { pub end : _0 , pub proposal_hash : _1 , pub threshold : runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold , pub delay : _0 , pub tally : runtime_types :: pallet_democracy :: types :: Tally < _2 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Tally < _0 > { pub ayes : _0 , pub nays : _0 , pub turnout : _0 , } } pub mod vote { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum AccountVote < _0 > { # [codec (index = 0)] Standard { vote : runtime_types :: pallet_democracy :: vote :: Vote , balance : _0 , } , # [codec (index = 1)] Split { aye : _0 , nay : _0 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct PriorLock < _0 , _1 > (pub _0 , pub _1 ,) ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Vote (pub :: core :: primitive :: u8 ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Voting < _0 , _1 , _2 > { # [codec (index = 0)] Direct { votes : :: std :: vec :: Vec < (_2 , runtime_types :: pallet_democracy :: vote :: AccountVote < _0 > ,) > , delegations : runtime_types :: pallet_democracy :: types :: Delegations < _0 > , prior : runtime_types :: pallet_democracy :: vote :: PriorLock < _2 , _0 > , } , # [codec (index = 1)] Delegating { balance : _0 , target : _1 , conviction : runtime_types :: pallet_democracy :: conviction :: Conviction , delegations : runtime_types :: pallet_democracy :: types :: Delegations < _0 > , prior : runtime_types :: pallet_democracy :: vote :: PriorLock < _2 , _0 > , } , } } pub mod vote_threshold { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum VoteThreshold { # [codec (index = 0)] SuperMajorityApprove , # [codec (index = 1)] SuperMajorityAgainst , # [codec (index = 2)] SimpleMajority , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum PreimageStatus < _0 , _1 , _2 > { # [codec (index = 0)] Missing (_2 ,) , # [codec (index = 1)] Available { data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , provider : _0 , deposit : _1 , since : _2 , expiry : :: core :: option :: Option < _2 > , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Releases { # [codec (index = 0)] V1 , } } pub mod pallet_election_provider_multi_phase { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Submit a solution for the unsigned phase."] # [doc = ""] # [doc = "The dispatch origin fo this call must be __none__."] # [doc = ""] # [doc = "This submission is checked on the fly. Moreover, this unsigned solution is only"] # [doc = "validated when submitted to the pool from the **local** node. Effectively, this means"] # [doc = "that only active validators can submit this transaction when authoring a block (similar"] # [doc = "to an inherent)."] # [doc = ""] # [doc = "To prevent any incorrect solution (and thus wasted time/weight), this transaction will"] # [doc = "panic if the solution submitted by the validator is invalid in any way, effectively"] # [doc = "putting their authoring reward at risk."] # [doc = ""] # [doc = "No deposit or reward is associated with this submission."] submit_unsigned { raw_solution : :: std :: boxed :: Box < runtime_types :: pallet_election_provider_multi_phase :: RawSolution < runtime_types :: ternoa_runtime_common :: election_provider_multi_phase :: NposCompactSolution24 > > , witness : runtime_types :: pallet_election_provider_multi_phase :: SolutionOrSnapshotSize , } , # [codec (index = 1)] # [doc = "Set a new value for `MinimumUntrustedScore`."] # [doc = ""] # [doc = "Dispatch origin must be aligned with `T::ForceOrigin`."] # [doc = ""] # [doc = "This check can be turned off by setting the value to `None`."] set_minimum_untrusted_score { maybe_next_score : :: core :: option :: Option < runtime_types :: sp_npos_elections :: ElectionScore > , } , # [codec (index = 2)] # [doc = "Set a solution in the queue, to be handed out to the client of this pallet in the next"] # [doc = "call to `ElectionProvider::elect`."] # [doc = ""] # [doc = "This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`."] # [doc = ""] # [doc = "The solution is not checked for any feasibility and is assumed to be trustworthy, as any"] # [doc = "feasibility check itself can in principle cause the election process to fail (due to"] # [doc = "memory/weight constrains)."] set_emergency_election_result { supports : :: std :: vec :: Vec < (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , runtime_types :: sp_npos_elections :: Support < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) > , } , # [codec (index = 3)] # [doc = "Submit a solution for the signed phase."] # [doc = ""] # [doc = "The dispatch origin fo this call must be __signed__."] # [doc = ""] # [doc = "The solution is potentially queued, based on the claimed score and processed at the end"] # [doc = "of the signed phase."] # [doc = ""] # [doc = "A deposit is reserved and recorded for the solution. Based on the outcome, the solution"] # [doc = "might be rewarded, slashed, or get all or a part of the deposit back."] submit { raw_solution : :: std :: boxed :: Box < runtime_types :: pallet_election_provider_multi_phase :: RawSolution < runtime_types :: ternoa_runtime_common :: election_provider_multi_phase :: NposCompactSolution24 > > , } , # [codec (index = 4)] # [doc = "Trigger the governance fallback."] # [doc = ""] # [doc = "This can only be called when [`Phase::Emergency`] is enabled, as an alternative to"] # [doc = "calling [`Call::set_emergency_election_result`]."] governance_fallback { maybe_max_voters : :: core :: option :: Option < :: core :: primitive :: u32 > , maybe_max_targets : :: core :: option :: Option < :: core :: primitive :: u32 > , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Error of the pallet that can be returned in response to dispatches."] pub enum Error { # [codec (index = 0)] # [doc = "Submission was too early."] PreDispatchEarlySubmission , # [codec (index = 1)] # [doc = "Wrong number of winners presented."] PreDispatchWrongWinnerCount , # [codec (index = 2)] # [doc = "Submission was too weak, score-wise."] PreDispatchWeakSubmission , # [codec (index = 3)] # [doc = "The queue was full, and the solution was not better than any of the existing ones."] SignedQueueFull , # [codec (index = 4)] # [doc = "The origin failed to pay the deposit."] SignedCannotPayDeposit , # [codec (index = 5)] # [doc = "Witness data to dispatchable is invalid."] SignedInvalidWitness , # [codec (index = 6)] # [doc = "The signed submission consumes too much weight"] SignedTooMuchWeight , # [codec (index = 7)] # [doc = "OCW submitted solution for wrong round"] OcwCallWrongEra , # [codec (index = 8)] # [doc = "Snapshot metadata should exist but didn't."] MissingSnapshotMetadata , # [codec (index = 9)] # [doc = "`Self::insert_submission` returned an invalid index."] InvalidSubmissionIndex , # [codec (index = 10)] # [doc = "The call is not allowed at this point."] CallNotAllowed , # [codec (index = 11)] # [doc = "The fallback failed"] FallbackFailed , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A solution was stored with the given compute."] # [doc = ""] # [doc = "If the solution is signed, this means that it hasn't yet been processed. If the"] # [doc = "solution is unsigned, this means that it has also been processed."] # [doc = ""] # [doc = "The `bool` is `true` when a previous solution was ejected to make room for this one."] SolutionStored { compute : runtime_types :: pallet_election_provider_multi_phase :: ElectionCompute , prev_ejected : :: core :: primitive :: bool , } , # [codec (index = 1)] # [doc = "The election has been finalized, with the given computation and score."] ElectionFinalized { compute : runtime_types :: pallet_election_provider_multi_phase :: ElectionCompute , score : runtime_types :: sp_npos_elections :: ElectionScore , } , # [codec (index = 2)] # [doc = "An election failed."] # [doc = ""] # [doc = "Not much can be said about which computes failed in the process."] ElectionFailed , # [codec (index = 3)] # [doc = "An account has been rewarded for their signed submission being finalized."] Rewarded { account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , value : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "An account has been slashed for submitting an invalid signed submission."] Slashed { account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , value : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "The signed phase of the given round has started."] SignedPhaseStarted { round : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "The unsigned phase of the given round has started."] UnsignedPhaseStarted { round : :: core :: primitive :: u32 , } , } } pub mod signed { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SignedSubmission < _0 , _1 , _2 > { pub who : _0 , pub deposit : _1 , pub raw_solution : runtime_types :: pallet_election_provider_multi_phase :: RawSolution < _2 > , pub call_fee : _1 , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum ElectionCompute { # [codec (index = 0)] OnChain , # [codec (index = 1)] Signed , # [codec (index = 2)] Unsigned , # [codec (index = 3)] Fallback , # [codec (index = 4)] Emergency , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Phase < _0 > { # [codec (index = 0)] Off , # [codec (index = 1)] Signed , # [codec (index = 2)] Unsigned ((:: core :: primitive :: bool , _0 ,) ,) , # [codec (index = 3)] Emergency , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RawSolution < _0 > { pub solution : _0 , pub score : runtime_types :: sp_npos_elections :: ElectionScore , pub round : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ReadySolution < _0 > { pub supports : :: std :: vec :: Vec < (_0 , runtime_types :: sp_npos_elections :: Support < _0 > ,) > , pub score : runtime_types :: sp_npos_elections :: ElectionScore , pub compute : runtime_types :: pallet_election_provider_multi_phase :: ElectionCompute , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RoundSnapshot { pub voters : :: std :: vec :: Vec < (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u64 , runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > ,) > , pub targets : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SolutionOrSnapshotSize { # [codec (compact)] pub voters : :: core :: primitive :: u32 , # [codec (compact)] pub targets : :: core :: primitive :: u32 , } } pub mod pallet_elections_phragmen { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Vote for a set of candidates for the upcoming round of election. This can be called to"] # [doc = "set the initial votes, or update already existing votes."] # [doc = ""] # [doc = "Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is"] # [doc = "reserved. The deposit is based on the number of votes and can be updated over time."] # [doc = ""] # [doc = "The `votes` should:"] # [doc = "  - not be empty."] # [doc = "  - be less than the number of possible candidates. Note that all current members and"] # [doc = "    runners-up are also automatically candidates for the next round."] # [doc = ""] # [doc = "If `value` is more than `who`'s free balance, then the maximum of the two is used."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed."] # [doc = ""] # [doc = "### Warning"] # [doc = ""] # [doc = "It is the responsibility of the caller to **NOT** place all of their balance into the"] # [doc = "lock and keep some for further operations."] # [doc = ""] # [doc = "# <weight>"] # [doc = "We assume the maximum weight among all 3 cases: vote_equal, vote_more and vote_less."] # [doc = "# </weight>"] vote { votes : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Remove `origin` as a voter."] # [doc = ""] # [doc = "This removes the lock and returns the deposit."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed and be a voter."] remove_voter , # [codec (index = 2)] # [doc = "Submit oneself for candidacy. A fixed amount of deposit is recorded."] # [doc = ""] # [doc = "All candidates are wiped at the end of the term. They either become a member/runner-up,"] # [doc = "or leave the system while their deposit is slashed."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed."] # [doc = ""] # [doc = "### Warning"] # [doc = ""] # [doc = "Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]"] # [doc = "to get their deposit back. Losing the spot in an election will always lead to a slash."] # [doc = ""] # [doc = "# <weight>"] # [doc = "The number of current candidates must be provided as witness data."] # [doc = "# </weight>"] submit_candidacy { # [codec (compact)] candidate_count : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "Renounce one's intention to be a candidate for the next election round. 3 potential"] # [doc = "outcomes exist:"] # [doc = ""] # [doc = "- `origin` is a candidate and not elected in any set. In this case, the deposit is"] # [doc = "  unreserved, returned and origin is removed as a candidate."] # [doc = "- `origin` is a current runner-up. In this case, the deposit is unreserved, returned and"] # [doc = "  origin is removed as a runner-up."] # [doc = "- `origin` is a current member. In this case, the deposit is unreserved and origin is"] # [doc = "  removed as a member, consequently not being a candidate for the next round anymore."] # [doc = "  Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they"] # [doc = "  are immediately used. If the prime is renouncing, then no prime will exist until the"] # [doc = "  next round."] # [doc = ""] # [doc = "The dispatch origin of this call must be signed, and have one of the above roles."] # [doc = ""] # [doc = "# <weight>"] # [doc = "The type of renouncing must be provided as witness data."] # [doc = "# </weight>"] renounce_candidacy { renouncing : runtime_types :: pallet_elections_phragmen :: Renouncing , } , # [codec (index = 4)] # [doc = "Remove a particular member from the set. This is effective immediately and the bond of"] # [doc = "the outgoing member is slashed."] # [doc = ""] # [doc = "If a runner-up is available, then the best runner-up will be removed and replaces the"] # [doc = "outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is"] # [doc = "started, else, nothing happens."] # [doc = ""] # [doc = "If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,"] # [doc = "it is returned."] # [doc = ""] # [doc = "The dispatch origin of this call must be root."] # [doc = ""] # [doc = "Note that this does not affect the designated block number of the next election."] # [doc = ""] # [doc = "# <weight>"] # [doc = "If we have a replacement, we use a small weight. Else, since this is a root call and"] # [doc = "will go into phragmen, we assume full block for now."] # [doc = "# </weight>"] remove_member { who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , slash_bond : :: core :: primitive :: bool , rerun_election : :: core :: primitive :: bool , } , # [codec (index = 5)] # [doc = "Clean all voters who are defunct (i.e. they do not serve any purpose at all). The"] # [doc = "deposit of the removed voters are returned."] # [doc = ""] # [doc = "This is an root function to be used only for cleaning the state."] # [doc = ""] # [doc = "The dispatch origin of this call must be root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "The total number of voters and those that are defunct must be provided as witness data."] # [doc = "# </weight>"] clean_defunct_voters { num_voters : :: core :: primitive :: u32 , num_defunct : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Cannot vote when no candidates or members exist."] UnableToVote , # [codec (index = 1)] # [doc = "Must vote for at least one candidate."] NoVotes , # [codec (index = 2)] # [doc = "Cannot vote more than candidates."] TooManyVotes , # [codec (index = 3)] # [doc = "Cannot vote more than maximum allowed."] MaximumVotesExceeded , # [codec (index = 4)] # [doc = "Cannot vote with stake less than minimum balance."] LowBalance , # [codec (index = 5)] # [doc = "Voter can not pay voting bond."] UnableToPayBond , # [codec (index = 6)] # [doc = "Must be a voter."] MustBeVoter , # [codec (index = 7)] # [doc = "Duplicated candidate submission."] DuplicatedCandidate , # [codec (index = 8)] # [doc = "Too many candidates have been created."] TooManyCandidates , # [codec (index = 9)] # [doc = "Member cannot re-submit candidacy."] MemberSubmit , # [codec (index = 10)] # [doc = "Runner cannot re-submit candidacy."] RunnerUpSubmit , # [codec (index = 11)] # [doc = "Candidate does not have enough funds."] InsufficientCandidateFunds , # [codec (index = 12)] # [doc = "Not a member."] NotMember , # [codec (index = 13)] # [doc = "The provided count of number of candidates is incorrect."] InvalidWitnessData , # [codec (index = 14)] # [doc = "The provided count of number of votes is incorrect."] InvalidVoteCount , # [codec (index = 15)] # [doc = "The renouncing origin presented a wrong `Renouncing` parameter."] InvalidRenouncing , # [codec (index = 16)] # [doc = "Prediction regarding replacement after member removal is wrong."] InvalidReplacement , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A new term with new_members. This indicates that enough candidates existed to run"] # [doc = "the election, not that enough have has been elected. The inner value must be examined"] # [doc = "for this purpose. A `NewTerm(\\[\\])` indicates that some candidates got their bond"] # [doc = "slashed and none were elected, whilst `EmptyTerm` means that no candidates existed to"] # [doc = "begin with."] NewTerm { new_members : :: std :: vec :: Vec < (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > , } , # [codec (index = 1)] # [doc = "No (or not enough) candidates existed for this round. This is different from"] # [doc = "`NewTerm(\\[\\])`. See the description of `NewTerm`."] EmptyTerm , # [codec (index = 2)] # [doc = "Internal error happened while trying to perform election."] ElectionError , # [codec (index = 3)] # [doc = "A member has been removed. This should always be followed by either `NewTerm` or"] # [doc = "`EmptyTerm`."] MemberKicked { member : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 4)] # [doc = "Someone has renounced their candidacy."] Renounced { candidate : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 5)] # [doc = "A candidate was slashed by amount due to failing to obtain a seat as member or"] # [doc = "runner-up."] # [doc = ""] # [doc = "Note that old members and runners-up are also candidates."] CandidateSlashed { candidate : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "A seat holder was slashed by amount by being forcefully removed from the set."] SeatHolderSlashed { seat_holder : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Renouncing { # [codec (index = 0)] Member , # [codec (index = 1)] RunnerUp , # [codec (index = 2)] Candidate (# [codec (compact)] :: core :: primitive :: u32 ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SeatHolder < _0 , _1 > { pub who : _0 , pub stake : _1 , pub deposit : _1 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Voter < _0 , _1 > { pub votes : :: std :: vec :: Vec < _0 > , pub stake : _1 , pub deposit : _1 , } } pub mod pallet_grandpa { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] report_equivocation { equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: ext :: sp_core :: H256 , :: core :: primitive :: u32 > > , key_owner_proof : runtime_types :: sp_session :: MembershipProof , } , # [codec (index = 1)] # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] # [doc = ""] # [doc = "This extrinsic must be called unsigned and it is expected that only"] # [doc = "block authors will call it (validated in `ValidateUnsigned`), as such"] # [doc = "if the block author is defined it will be defined as the equivocation"] # [doc = "reporter."] report_equivocation_unsigned { equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: ext :: sp_core :: H256 , :: core :: primitive :: u32 > > , key_owner_proof : runtime_types :: sp_session :: MembershipProof , } , # [codec (index = 2)] # [doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."] # [doc = ""] # [doc = "This will trigger a forced authority set change at the beginning of the next session, to"] # [doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"] # [doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."] # [doc = "The block production rate (which may be slowed down because of finality lagging) should"] # [doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"] # [doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"] # [doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"] # [doc = "block of all validators of the new authority set."] # [doc = ""] # [doc = "Only callable by root."] note_stalled { delay : :: core :: primitive :: u32 , best_finalized_block_number : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Attempt to signal GRANDPA pause when the authority set isn't live"] # [doc = "(either paused or already pending pause)."] PauseFailed , # [codec (index = 1)] # [doc = "Attempt to signal GRANDPA resume when the authority set isn't paused"] # [doc = "(either live or already pending resume)."] ResumeFailed , # [codec (index = 2)] # [doc = "Attempt to signal GRANDPA change with one already pending."] ChangePending , # [codec (index = 3)] # [doc = "Cannot signal forced change so soon after last."] TooSoon , # [codec (index = 4)] # [doc = "A key ownership proof provided as part of an equivocation report is invalid."] InvalidKeyOwnershipProof , # [codec (index = 5)] # [doc = "An equivocation proof provided as part of an equivocation report is invalid."] InvalidEquivocationProof , # [codec (index = 6)] # [doc = "A given equivocation report is valid but already previously reported."] DuplicateOffenceReport , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "New authority set has been applied."] NewAuthorities { authority_set : :: std :: vec :: Vec < (runtime_types :: sp_finality_grandpa :: app :: Public , :: core :: primitive :: u64 ,) > , } , # [codec (index = 1)] # [doc = "Current authority set has been paused."] Paused , # [codec (index = 2)] # [doc = "Current authority set has been resumed."] Resumed , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct StoredPendingChange < _0 > { pub scheduled_at : _0 , pub delay : _0 , pub next_authorities : runtime_types :: sp_core :: bounded :: weak_bounded_vec :: WeakBoundedVec < (runtime_types :: sp_finality_grandpa :: app :: Public , :: core :: primitive :: u64 ,) > , pub forced : :: core :: option :: Option < _0 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum StoredState < _0 > { # [codec (index = 0)] Live , # [codec (index = 1)] PendingPause { scheduled_at : _0 , delay : _0 , } , # [codec (index = 2)] Paused , # [codec (index = 3)] PendingResume { scheduled_at : _0 , delay : _0 , } , } } pub mod pallet_identity { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Identity pallet declaration."] pub enum Call { # [codec (index = 0)] # [doc = "Add a registrar to the system."] # [doc = ""] # [doc = "The dispatch origin for this call must be `T::RegistrarOrigin`."] # [doc = ""] # [doc = "- `account`: the account of the registrar."] # [doc = ""] # [doc = "Emits `RegistrarAdded` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R)` where `R` registrar-count (governance-bounded and code-bounded)."] # [doc = "- One storage mutation (codec `O(R)`)."] # [doc = "- One event."] # [doc = "# </weight>"] add_registrar { account : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 1)] # [doc = "Set an account's identity information and reserve the appropriate deposit."] # [doc = ""] # [doc = "If the account already has identity information, the deposit is taken as part payment"] # [doc = "for the new deposit."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `info`: The identity information."] # [doc = ""] # [doc = "Emits `IdentitySet` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(X + X' + R)`"] # [doc = "  - where `X` additional-field-count (deposit-bounded and code-bounded)"] # [doc = "  - where `R` judgements-count (registrar-count-bounded)"] # [doc = "- One balance reserve operation."] # [doc = "- One storage mutation (codec-read `O(X' + R)`, codec-write `O(X + R)`)."] # [doc = "- One event."] # [doc = "# </weight>"] set_identity { info : :: std :: boxed :: Box < runtime_types :: pallet_identity :: types :: IdentityInfo > , } , # [codec (index = 2)] # [doc = "Set the sub-accounts of the sender."] # [doc = ""] # [doc = "Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned"] # [doc = "and an amount `SubAccountDeposit` will be reserved for each item in `subs`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "identity."] # [doc = ""] # [doc = "- `subs`: The identity's (new) sub-accounts."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(P + S)`"] # [doc = "  - where `P` old-subs-count (hard- and deposit-bounded)."] # [doc = "  - where `S` subs-count (hard- and deposit-bounded)."] # [doc = "- At most one balance operations."] # [doc = "- DB:"] # [doc = "  - `P + S` storage mutations (codec complexity `O(1)`)"] # [doc = "  - One storage read (codec complexity `O(P)`)."] # [doc = "  - One storage write (codec complexity `O(S)`)."] # [doc = "  - One storage-exists (`IdentityOf::contains_key`)."] # [doc = "# </weight>"] set_subs { subs : :: std :: vec :: Vec < (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_identity :: types :: Data ,) > , } , # [codec (index = 3)] # [doc = "Clear an account's identity info and all sub-accounts and return all deposits."] # [doc = ""] # [doc = "Payment: All reserved balances on the account are returned."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "identity."] # [doc = ""] # [doc = "Emits `IdentityCleared` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R + S + X)`"] # [doc = "  - where `R` registrar-count (governance-bounded)."] # [doc = "  - where `S` subs-count (hard- and deposit-bounded)."] # [doc = "  - where `X` additional-field-count (deposit-bounded and code-bounded)."] # [doc = "- One balance-unreserve operation."] # [doc = "- `2` storage reads and `S + 2` storage deletions."] # [doc = "- One event."] # [doc = "# </weight>"] clear_identity , # [codec (index = 4)] # [doc = "Request a judgement from a registrar."] # [doc = ""] # [doc = "Payment: At most `max_fee` will be reserved for payment to the registrar if judgement"] # [doc = "given."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a"] # [doc = "registered identity."] # [doc = ""] # [doc = "- `reg_index`: The index of the registrar whose judgement is requested."] # [doc = "- `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:"] # [doc = ""] # [doc = "```nocompile"] # [doc = "Self::registrars().get(reg_index).unwrap().fee"] # [doc = "```"] # [doc = ""] # [doc = "Emits `JudgementRequested` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R + X)`."] # [doc = "- One balance-reserve operation."] # [doc = "- Storage: 1 read `O(R)`, 1 mutate `O(X + R)`."] # [doc = "- One event."] # [doc = "# </weight>"] request_judgement { # [codec (compact)] reg_index : :: core :: primitive :: u32 , # [codec (compact)] max_fee : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "Cancel a previous request."] # [doc = ""] # [doc = "Payment: A previously reserved deposit is returned on success."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a"] # [doc = "registered identity."] # [doc = ""] # [doc = "- `reg_index`: The index of the registrar whose judgement is no longer requested."] # [doc = ""] # [doc = "Emits `JudgementUnrequested` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R + X)`."] # [doc = "- One balance-reserve operation."] # [doc = "- One storage mutation `O(R + X)`."] # [doc = "- One event"] # [doc = "# </weight>"] cancel_request { reg_index : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "Set the fee required for a judgement to be requested from a registrar."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must be the account"] # [doc = "of the registrar whose index is `index`."] # [doc = ""] # [doc = "- `index`: the index of the registrar whose fee is to be set."] # [doc = "- `fee`: the new fee."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R)`."] # [doc = "- One storage mutation `O(R)`."] # [doc = "- Benchmark: 7.315 + R * 0.329 s (min squares analysis)"] # [doc = "# </weight>"] set_fee { # [codec (compact)] index : :: core :: primitive :: u32 , # [codec (compact)] fee : :: core :: primitive :: u128 , } , # [codec (index = 7)] # [doc = "Change the account associated with a registrar."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must be the account"] # [doc = "of the registrar whose index is `index`."] # [doc = ""] # [doc = "- `index`: the index of the registrar whose fee is to be set."] # [doc = "- `new`: the new account ID."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R)`."] # [doc = "- One storage mutation `O(R)`."] # [doc = "- Benchmark: 8.823 + R * 0.32 s (min squares analysis)"] # [doc = "# </weight>"] set_account_id { # [codec (compact)] index : :: core :: primitive :: u32 , new : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 8)] # [doc = "Set the field information for a registrar."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must be the account"] # [doc = "of the registrar whose index is `index`."] # [doc = ""] # [doc = "- `index`: the index of the registrar whose fee is to be set."] # [doc = "- `fields`: the fields that the registrar concerns themselves with."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R)`."] # [doc = "- One storage mutation `O(R)`."] # [doc = "- Benchmark: 7.464 + R * 0.325 s (min squares analysis)"] # [doc = "# </weight>"] set_fields { # [codec (compact)] index : :: core :: primitive :: u32 , fields : runtime_types :: pallet_identity :: types :: BitFlags < runtime_types :: pallet_identity :: types :: IdentityField > , } , # [codec (index = 9)] # [doc = "Provide a judgement for an account's identity."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must be the account"] # [doc = "of the registrar whose index is `reg_index`."] # [doc = ""] # [doc = "- `reg_index`: the index of the registrar whose judgement is being made."] # [doc = "- `target`: the account whose identity the judgement is upon. This must be an account"] # [doc = "  with a registered identity."] # [doc = "- `judgement`: the judgement of the registrar of index `reg_index` about `target`."] # [doc = "- `identity`: The hash of the [`IdentityInfo`] for that the judgement is provided."] # [doc = ""] # [doc = "Emits `JudgementGiven` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R + X)`."] # [doc = "- One balance-transfer operation."] # [doc = "- Up to one account-lookup operation."] # [doc = "- Storage: 1 read `O(R)`, 1 mutate `O(R + X)`."] # [doc = "- One event."] # [doc = "# </weight>"] provide_judgement { # [codec (compact)] reg_index : :: core :: primitive :: u32 , target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , judgement : runtime_types :: pallet_identity :: types :: Judgement < :: core :: primitive :: u128 > , identity : :: subxt :: ext :: sp_core :: H256 , } , # [codec (index = 10)] # [doc = "Remove an account's identity and sub-account information and slash the deposits."] # [doc = ""] # [doc = "Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by"] # [doc = "`Slash`. Verification request deposits are not returned; they should be cancelled"] # [doc = "manually using `cancel_request`."] # [doc = ""] # [doc = "The dispatch origin for this call must match `T::ForceOrigin`."] # [doc = ""] # [doc = "- `target`: the account whose identity the judgement is upon. This must be an account"] # [doc = "  with a registered identity."] # [doc = ""] # [doc = "Emits `IdentityKilled` if successful."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(R + S + X)`."] # [doc = "- One balance-reserve operation."] # [doc = "- `S + 2` storage mutations."] # [doc = "- One event."] # [doc = "# </weight>"] kill_identity { target : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 11)] # [doc = "Add the given account to the sender's subs."] # [doc = ""] # [doc = "Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated"] # [doc = "to the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "sub identity of `sub`."] add_sub { sub : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , data : runtime_types :: pallet_identity :: types :: Data , } , # [codec (index = 12)] # [doc = "Alter the associated name of the given sub-account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "sub identity of `sub`."] rename_sub { sub : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , data : runtime_types :: pallet_identity :: types :: Data , } , # [codec (index = 13)] # [doc = "Remove the given account from the sender's subs."] # [doc = ""] # [doc = "Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated"] # [doc = "to the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "sub identity of `sub`."] remove_sub { sub : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 14)] # [doc = "Remove the sender as a sub-account."] # [doc = ""] # [doc = "Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated"] # [doc = "to the sender (*not* the original depositor)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "super-identity."] # [doc = ""] # [doc = "NOTE: This should not normally be used, but is provided in the case that the non-"] # [doc = "controller of an account is maliciously registered as a sub-account."] quit_sub , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Too many subs-accounts."] TooManySubAccounts , # [codec (index = 1)] # [doc = "Account isn't found."] NotFound , # [codec (index = 2)] # [doc = "Account isn't named."] NotNamed , # [codec (index = 3)] # [doc = "Empty index."] EmptyIndex , # [codec (index = 4)] # [doc = "Fee is changed."] FeeChanged , # [codec (index = 5)] # [doc = "No identity found."] NoIdentity , # [codec (index = 6)] # [doc = "Sticky judgement."] StickyJudgement , # [codec (index = 7)] # [doc = "Judgement given."] JudgementGiven , # [codec (index = 8)] # [doc = "Invalid judgement."] InvalidJudgement , # [codec (index = 9)] # [doc = "The index is invalid."] InvalidIndex , # [codec (index = 10)] # [doc = "The target is invalid."] InvalidTarget , # [codec (index = 11)] # [doc = "Too many additional fields."] TooManyFields , # [codec (index = 12)] # [doc = "Maximum amount of registrars reached. Cannot add any more."] TooManyRegistrars , # [codec (index = 13)] # [doc = "Account ID is already named."] AlreadyClaimed , # [codec (index = 14)] # [doc = "Sender is not a sub-account."] NotSub , # [codec (index = 15)] # [doc = "Sub-account isn't owned by sender."] NotOwned , # [codec (index = 16)] # [doc = "The provided judgement was for a different identity."] JudgementForDifferentIdentity , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A name was set or reset (which will remove all judgements)."] IdentitySet { who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 1)] # [doc = "A name was cleared, and the given balance returned."] IdentityCleared { who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , deposit : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "A name was removed and the given balance slashed."] IdentityKilled { who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , deposit : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "A judgement was asked from a registrar."] JudgementRequested { who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , registrar_index : :: core :: primitive :: u32 , } , # [codec (index = 4)] # [doc = "A judgement request was retracted."] JudgementUnrequested { who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , registrar_index : :: core :: primitive :: u32 , } , # [codec (index = 5)] # [doc = "A judgement was given by a registrar."] JudgementGiven { target : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , registrar_index : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "A registrar was added."] RegistrarAdded { registrar_index : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "A sub-identity was added to an identity and the deposit paid."] SubIdentityAdded { sub : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , main : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , deposit : :: core :: primitive :: u128 , } , # [codec (index = 8)] # [doc = "A sub-identity was removed from an identity and the deposit freed."] SubIdentityRemoved { sub : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , main : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , deposit : :: core :: primitive :: u128 , } , # [codec (index = 9)] # [doc = "A sub-identity was cleared, and the given deposit repatriated from the"] # [doc = "main identity account to the sub-identity account."] SubIdentityRevoked { sub : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , main : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , deposit : :: core :: primitive :: u128 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct BitFlags < _0 > (pub :: core :: primitive :: u64 , # [codec (skip)] pub :: core :: marker :: PhantomData < _0 >) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Data { # [codec (index = 0)] None , # [codec (index = 1)] Raw0 ([:: core :: primitive :: u8 ; 0usize] ,) , # [codec (index = 2)] Raw1 ([:: core :: primitive :: u8 ; 1usize] ,) , # [codec (index = 3)] Raw2 ([:: core :: primitive :: u8 ; 2usize] ,) , # [codec (index = 4)] Raw3 ([:: core :: primitive :: u8 ; 3usize] ,) , # [codec (index = 5)] Raw4 ([:: core :: primitive :: u8 ; 4usize] ,) , # [codec (index = 6)] Raw5 ([:: core :: primitive :: u8 ; 5usize] ,) , # [codec (index = 7)] Raw6 ([:: core :: primitive :: u8 ; 6usize] ,) , # [codec (index = 8)] Raw7 ([:: core :: primitive :: u8 ; 7usize] ,) , # [codec (index = 9)] Raw8 ([:: core :: primitive :: u8 ; 8usize] ,) , # [codec (index = 10)] Raw9 ([:: core :: primitive :: u8 ; 9usize] ,) , # [codec (index = 11)] Raw10 ([:: core :: primitive :: u8 ; 10usize] ,) , # [codec (index = 12)] Raw11 ([:: core :: primitive :: u8 ; 11usize] ,) , # [codec (index = 13)] Raw12 ([:: core :: primitive :: u8 ; 12usize] ,) , # [codec (index = 14)] Raw13 ([:: core :: primitive :: u8 ; 13usize] ,) , # [codec (index = 15)] Raw14 ([:: core :: primitive :: u8 ; 14usize] ,) , # [codec (index = 16)] Raw15 ([:: core :: primitive :: u8 ; 15usize] ,) , # [codec (index = 17)] Raw16 ([:: core :: primitive :: u8 ; 16usize] ,) , # [codec (index = 18)] Raw17 ([:: core :: primitive :: u8 ; 17usize] ,) , # [codec (index = 19)] Raw18 ([:: core :: primitive :: u8 ; 18usize] ,) , # [codec (index = 20)] Raw19 ([:: core :: primitive :: u8 ; 19usize] ,) , # [codec (index = 21)] Raw20 ([:: core :: primitive :: u8 ; 20usize] ,) , # [codec (index = 22)] Raw21 ([:: core :: primitive :: u8 ; 21usize] ,) , # [codec (index = 23)] Raw22 ([:: core :: primitive :: u8 ; 22usize] ,) , # [codec (index = 24)] Raw23 ([:: core :: primitive :: u8 ; 23usize] ,) , # [codec (index = 25)] Raw24 ([:: core :: primitive :: u8 ; 24usize] ,) , # [codec (index = 26)] Raw25 ([:: core :: primitive :: u8 ; 25usize] ,) , # [codec (index = 27)] Raw26 ([:: core :: primitive :: u8 ; 26usize] ,) , # [codec (index = 28)] Raw27 ([:: core :: primitive :: u8 ; 27usize] ,) , # [codec (index = 29)] Raw28 ([:: core :: primitive :: u8 ; 28usize] ,) , # [codec (index = 30)] Raw29 ([:: core :: primitive :: u8 ; 29usize] ,) , # [codec (index = 31)] Raw30 ([:: core :: primitive :: u8 ; 30usize] ,) , # [codec (index = 32)] Raw31 ([:: core :: primitive :: u8 ; 31usize] ,) , # [codec (index = 33)] Raw32 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 34)] BlakeTwo256 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 35)] Sha256 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 36)] Keccak256 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 37)] ShaThree256 ([:: core :: primitive :: u8 ; 32usize] ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum IdentityField { # [codec (index = 1)] Display , # [codec (index = 2)] Legal , # [codec (index = 4)] Web , # [codec (index = 8)] Riot , # [codec (index = 16)] Email , # [codec (index = 32)] PgpFingerprint , # [codec (index = 64)] Image , # [codec (index = 128)] Twitter , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct IdentityInfo { pub additional : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < (runtime_types :: pallet_identity :: types :: Data , runtime_types :: pallet_identity :: types :: Data ,) > , pub display : runtime_types :: pallet_identity :: types :: Data , pub legal : runtime_types :: pallet_identity :: types :: Data , pub web : runtime_types :: pallet_identity :: types :: Data , pub riot : runtime_types :: pallet_identity :: types :: Data , pub email : runtime_types :: pallet_identity :: types :: Data , pub pgp_fingerprint : :: core :: option :: Option < [:: core :: primitive :: u8 ; 20usize] > , pub image : runtime_types :: pallet_identity :: types :: Data , pub twitter : runtime_types :: pallet_identity :: types :: Data , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Judgement < _0 > { # [codec (index = 0)] Unknown , # [codec (index = 1)] FeePaid (_0 ,) , # [codec (index = 2)] Reasonable , # [codec (index = 3)] KnownGood , # [codec (index = 4)] OutOfDate , # [codec (index = 5)] LowQuality , # [codec (index = 6)] Erroneous , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RegistrarInfo < _0 , _1 > { pub account : _1 , pub fee : _0 , pub fields : runtime_types :: pallet_identity :: types :: BitFlags < runtime_types :: pallet_identity :: types :: IdentityField > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Registration < _0 > { pub judgements : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < (:: core :: primitive :: u32 , runtime_types :: pallet_identity :: types :: Judgement < _0 > ,) > , pub deposit : _0 , pub info : runtime_types :: pallet_identity :: types :: IdentityInfo , } } } pub mod pallet_im_online { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "# <weight>"] # [doc = "- Complexity: `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is"] # [doc = "  length of `heartbeat.network_state.external_address`"] # [doc = "  - `O(K)`: decoding of length `K`"] # [doc = "  - `O(E)`: decoding/encoding of length `E`"] # [doc = "- DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,"] # [doc = "  `ReceivedHeartbeats`"] # [doc = "- DbWrites: `ReceivedHeartbeats`"] # [doc = "# </weight>"] heartbeat { heartbeat : runtime_types :: pallet_im_online :: Heartbeat < :: core :: primitive :: u32 > , signature : runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Signature , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Non existent public key."] InvalidKey , # [codec (index = 1)] # [doc = "Duplicated heartbeat."] DuplicatedHeartbeat , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A new heartbeat was received from `AuthorityId`."] HeartbeatReceived { authority_id : runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Public , } , # [codec (index = 1)] # [doc = "At the end of the session, no offence was committed."] AllGood , # [codec (index = 2)] # [doc = "At the end of the session, at least one validator was found to be offline."] SomeOffline { offline : :: std :: vec :: Vec < (:: subxt :: ext :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_staking :: Exposure < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > ,) > , } , } } pub mod sr25519 { use super :: runtime_types ; pub mod app_sr25519 { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Public (pub runtime_types :: sp_core :: sr25519 :: Public ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Signature (pub runtime_types :: sp_core :: sr25519 :: Signature ,) ; } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct BoundedOpaqueNetworkState { pub peer_id : runtime_types :: sp_core :: bounded :: weak_bounded_vec :: WeakBoundedVec < :: core :: primitive :: u8 > , pub external_addresses : runtime_types :: sp_core :: bounded :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: sp_core :: bounded :: weak_bounded_vec :: WeakBoundedVec < :: core :: primitive :: u8 > > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Heartbeat < _0 > { pub block_number : _0 , pub network_state : runtime_types :: sp_core :: offchain :: OpaqueNetworkState , pub session_index : _0 , pub authority_index : _0 , pub validators_len : _0 , } } pub mod pallet_membership { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Add a member `who` to the set."] # [doc = ""] # [doc = "May only be called from `T::AddOrigin`."] add_member { who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 1)] # [doc = "Remove a member `who` from the set."] # [doc = ""] # [doc = "May only be called from `T::RemoveOrigin`."] remove_member { who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 2)] # [doc = "Swap out one member `remove` for another `add`."] # [doc = ""] # [doc = "May only be called from `T::SwapOrigin`."] # [doc = ""] # [doc = "Prime membership is *not* passed from `remove` to `add`, if extant."] swap_member { remove : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , add : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 3)] # [doc = "Change the membership to a new set, disregarding the existing membership. Be nice and"] # [doc = "pass `members` pre-sorted."] # [doc = ""] # [doc = "May only be called from `T::ResetOrigin`."] reset_members { members : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 4)] # [doc = "Swap out the sending member for some other key `new`."] # [doc = ""] # [doc = "May only be called from `Signed` origin of a current member."] # [doc = ""] # [doc = "Prime membership is passed from the origin account to `new`, if extant."] change_key { new : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 5)] # [doc = "Set the prime member. Must be a current member."] # [doc = ""] # [doc = "May only be called from `T::PrimeOrigin`."] set_prime { who : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 6)] # [doc = "Remove the prime member if it exists."] # [doc = ""] # [doc = "May only be called from `T::PrimeOrigin`."] clear_prime , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Already a member."] AlreadyMember , # [codec (index = 1)] # [doc = "Not a member."] NotMember , # [codec (index = 2)] # [doc = "Too many members."] TooManyMembers , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "The given member was added; see the transaction for who."] MemberAdded , # [codec (index = 1)] # [doc = "The given member was removed; see the transaction for who."] MemberRemoved , # [codec (index = 2)] # [doc = "Two members were swapped; see the transaction for who."] MembersSwapped , # [codec (index = 3)] # [doc = "The membership was reset; see the transaction for who the new set is."] MembersReset , # [codec (index = 4)] # [doc = "One of the members' keys changed."] KeyChanged , # [codec (index = 5)] # [doc = "Phantom member, never used."] Dummy , } } } pub mod pallet_multisig { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Immediately dispatch a multi-signature call using a single approval from the caller."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `other_signatories`: The accounts (other than the sender) who are part of the"] # [doc = "multi-signature, but do not participate in the approval process."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result."] # [doc = ""] # [doc = "# <weight>"] # [doc = "O(Z + C) where Z is the length of the call and C its execution weight."] # [doc = "-------------------------------"] # [doc = "- DB Weight: None"] # [doc = "- Plus Call Weight"] # [doc = "# </weight>"] as_multi_threshold_1 { other_signatories : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , call : :: std :: boxed :: Box < runtime_types :: alphanet_runtime :: RuntimeCall > , } , # [codec (index = 1)] # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "If there are enough, then dispatch the call."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "NOTE: Unless this is the final approval, you will generally want to use"] # [doc = "`approve_as_multi` instead, since it only requires a hash of the call."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise"] # [doc = "on success, result is `Ok` and the result from the interior call, if it was executed,"] # [doc = "may be found in the deposited `MultisigExecuted` event."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(S + Z + Call)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- The weight of the `call`."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] # [doc = "-------------------------------"] # [doc = "- DB Weight:"] # [doc = "    - Reads: Multisig Storage, [Caller Account], Calls (if `store_call`)"] # [doc = "    - Writes: Multisig Storage, [Caller Account], Calls (if `store_call`)"] # [doc = "- Plus Call Weight"] # [doc = "# </weight>"] as_multi { threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , call : :: subxt :: utils :: WrapperKeepOpaque < runtime_types :: alphanet_runtime :: RuntimeCall > , store_call : :: core :: primitive :: bool , max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } , # [codec (index = 2)] # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "NOTE: If this is the final approval, you will want to use `as_multi` instead."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] # [doc = "----------------------------------"] # [doc = "- DB Weight:"] # [doc = "    - Read: Multisig Storage, [Caller Account]"] # [doc = "    - Write: Multisig Storage, [Caller Account]"] # [doc = "# </weight>"] approve_as_multi { threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , call_hash : [:: core :: primitive :: u8 ; 32usize] , max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } , # [codec (index = 3)] # [doc = "Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously"] # [doc = "for this operation will be unreserved on success."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `timepoint`: The timepoint (block number and transaction index) of the first approval"] # [doc = "transaction for this dispatch."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- One event."] # [doc = "- I/O: 1 read `O(S)`, one remove."] # [doc = "- Storage: removes one item."] # [doc = "----------------------------------"] # [doc = "- DB Weight:"] # [doc = "    - Read: Multisig Storage, [Caller Account], Refund Account, Calls"] # [doc = "    - Write: Multisig Storage, [Caller Account], Refund Account, Calls"] # [doc = "# </weight>"] cancel_as_multi { threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Threshold must be 2 or greater."] MinimumThreshold , # [codec (index = 1)] # [doc = "Call is already approved by this signatory."] AlreadyApproved , # [codec (index = 2)] # [doc = "Call doesn't need any (more) approvals."] NoApprovalsNeeded , # [codec (index = 3)] # [doc = "There are too few signatories in the list."] TooFewSignatories , # [codec (index = 4)] # [doc = "There are too many signatories in the list."] TooManySignatories , # [codec (index = 5)] # [doc = "The signatories were provided out of order; they should be ordered."] SignatoriesOutOfOrder , # [codec (index = 6)] # [doc = "The sender was contained in the other signatories; it shouldn't be."] SenderInSignatories , # [codec (index = 7)] # [doc = "Multisig operation not found when attempting to cancel."] NotFound , # [codec (index = 8)] # [doc = "Only the account that originally created the multisig is able to cancel it."] NotOwner , # [codec (index = 9)] # [doc = "No timepoint was given, yet the multisig operation is already underway."] NoTimepoint , # [codec (index = 10)] # [doc = "A different timepoint was given to the multisig operation that is underway."] WrongTimepoint , # [codec (index = 11)] # [doc = "A timepoint was given, yet no multisig operation is underway."] UnexpectedTimepoint , # [codec (index = 12)] # [doc = "The maximum weight information provided was too low."] MaxWeightTooLow , # [codec (index = 13)] # [doc = "The data to be stored is already stored."] AlreadyStored , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A new multisig operation has begun."] NewMultisig { approving : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , multisig : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , # [codec (index = 1)] # [doc = "A multisig operation has been approved by someone."] MultisigApproval { approving : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , multisig : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , # [codec (index = 2)] # [doc = "A multisig operation has been executed."] MultisigExecuted { approving : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , multisig : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , call_hash : [:: core :: primitive :: u8 ; 32usize] , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 3)] # [doc = "A multisig operation has been cancelled."] MultisigCancelled { cancelling : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , multisig : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Multisig < _0 , _1 , _2 > { pub when : runtime_types :: pallet_multisig :: Timepoint < _0 > , pub deposit : _1 , pub depositor : _2 , pub approvals : :: std :: vec :: Vec < _2 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Timepoint < _0 > { pub height : _0 , pub index : _0 , } } pub mod pallet_offences { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Events type."] pub enum Event { # [codec (index = 0)] # [doc = "There is an offence reported of the given `kind` happened at the `session_index` and"] # [doc = "(kind-specific) time slot. This event is not deposited for duplicate slashes."] # [doc = "\\[kind, timeslot\\]."] Offence { kind : [:: core :: primitive :: u8 ; 16usize] , timeslot : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } } } pub mod pallet_preimage { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Register a preimage on-chain."] # [doc = ""] # [doc = "If the preimage was previously requested, no fees or deposits are taken for providing"] # [doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."] note_preimage { bytes : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] # [doc = "Clear an unrequested preimage from the runtime storage."] unnote_preimage { hash : :: subxt :: ext :: sp_core :: H256 , } , # [codec (index = 2)] # [doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."] # [doc = ""] # [doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"] # [doc = "a user may have paid, and take the control of the preimage out of their hands."] request_preimage { hash : :: subxt :: ext :: sp_core :: H256 , } , # [codec (index = 3)] # [doc = "Clear a previously made request for a preimage."] # [doc = ""] # [doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."] unrequest_preimage { hash : :: subxt :: ext :: sp_core :: H256 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Preimage is too large to store on-chain."] TooLarge , # [codec (index = 1)] # [doc = "Preimage has already been noted on-chain."] AlreadyNoted , # [codec (index = 2)] # [doc = "The user is not authorized to perform this action."] NotAuthorized , # [codec (index = 3)] # [doc = "The preimage cannot be removed since it has not yet been noted."] NotNoted , # [codec (index = 4)] # [doc = "A preimage may not be removed when there are outstanding requests."] Requested , # [codec (index = 5)] # [doc = "The preimage request cannot be removed since no outstanding requests exist."] NotRequested , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A preimage has been noted."] Noted { hash : :: subxt :: ext :: sp_core :: H256 , } , # [codec (index = 1)] # [doc = "A preimage has been requested."] Requested { hash : :: subxt :: ext :: sp_core :: H256 , } , # [codec (index = 2)] # [doc = "A preimage has ben cleared."] Cleared { hash : :: subxt :: ext :: sp_core :: H256 , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum RequestStatus < _0 , _1 > { # [codec (index = 0)] Unrequested (:: core :: option :: Option < (_0 , _1 ,) > ,) , # [codec (index = 1)] Requested (:: core :: primitive :: u32 ,) , } } pub mod pallet_scheduler { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Anonymously schedule a task."] schedule { when : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: std :: boxed :: Box < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: alphanet_runtime :: RuntimeCall , :: subxt :: ext :: sp_core :: H256 > > , } , # [codec (index = 1)] # [doc = "Cancel an anonymously scheduled task."] cancel { when : :: core :: primitive :: u32 , index : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Schedule a named task."] schedule_named { id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , when : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: std :: boxed :: Box < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: alphanet_runtime :: RuntimeCall , :: subxt :: ext :: sp_core :: H256 > > , } , # [codec (index = 3)] # [doc = "Cancel a named scheduled task."] cancel_named { id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 4)] # [doc = "Anonymously schedule a task after a delay."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Same as [`schedule`]."] # [doc = "# </weight>"] schedule_after { after : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: std :: boxed :: Box < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: alphanet_runtime :: RuntimeCall , :: subxt :: ext :: sp_core :: H256 > > , } , # [codec (index = 5)] # [doc = "Schedule a named task after a delay."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Same as [`schedule_named`](Self::schedule_named)."] # [doc = "# </weight>"] schedule_named_after { id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , after : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: std :: boxed :: Box < runtime_types :: frame_support :: traits :: schedule :: MaybeHashed < runtime_types :: alphanet_runtime :: RuntimeCall , :: subxt :: ext :: sp_core :: H256 > > , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Failed to schedule a call"] FailedToSchedule , # [codec (index = 1)] # [doc = "Cannot find the scheduled call."] NotFound , # [codec (index = 2)] # [doc = "Given target block number is in the past."] TargetBlockNumberInPast , # [codec (index = 3)] # [doc = "Reschedule failed because it does not change scheduled time."] RescheduleNoChange , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Events type."] pub enum Event { # [codec (index = 0)] # [doc = "Scheduled some task."] Scheduled { when : :: core :: primitive :: u32 , index : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Canceled some task."] Canceled { when : :: core :: primitive :: u32 , index : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Dispatched some task."] Dispatched { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 3)] # [doc = "The call for the provided hash was not found so the task has been aborted."] CallLookupFailed { task : (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , id : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , error : runtime_types :: frame_support :: traits :: schedule :: LookupError , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ScheduledV3 < _0 , _1 , _2 , _3 > { pub maybe_id : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , pub priority : :: core :: primitive :: u8 , pub call : _0 , pub maybe_periodic : :: core :: option :: Option < (_1 , _1 ,) > , pub origin : _2 , # [codec (skip)] pub __subxt_unused_type_params : :: core :: marker :: PhantomData < _3 > } } pub mod pallet_session { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Sets the session key(s) of the function caller to `keys`."] # [doc = "Allows an account to set its session key prior to becoming a validator."] # [doc = "This doesn't take effect until the next session."] # [doc = ""] # [doc = "The dispatch origin of this function must be signed."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: `O(1)`. Actual cost depends on the number of length of"] # [doc = "  `T::Keys::key_ids()` which is fixed."] # [doc = "- DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`"] # [doc = "- DbWrites: `origin account`, `NextKeys`"] # [doc = "- DbReads per key id: `KeyOwner`"] # [doc = "- DbWrites per key id: `KeyOwner`"] # [doc = "# </weight>"] set_keys { keys : runtime_types :: alphanet_runtime :: pallets :: SessionKeys , proof : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] # [doc = "Removes any session key(s) of the function caller."] # [doc = ""] # [doc = "This doesn't take effect until the next session."] # [doc = ""] # [doc = "The dispatch origin of this function must be Signed and the account must be either be"] # [doc = "convertible to a validator ID using the chain's typical addressing system (this usually"] # [doc = "means being a controller account) or directly convertible into a validator ID (which"] # [doc = "usually means being a stash account)."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: `O(1)` in number of key types. Actual cost depends on the number of length"] # [doc = "  of `T::Keys::key_ids()` which is fixed."] # [doc = "- DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`"] # [doc = "- DbWrites: `NextKeys`, `origin account`"] # [doc = "- DbWrites per key id: `KeyOwner`"] # [doc = "# </weight>"] purge_keys , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Error for the session pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Invalid ownership proof."] InvalidProof , # [codec (index = 1)] # [doc = "No associated validator ID for account."] NoAssociatedValidatorId , # [codec (index = 2)] # [doc = "Registered duplicate key."] DuplicatedKey , # [codec (index = 3)] # [doc = "No keys are associated with this account."] NoKeys , # [codec (index = 4)] # [doc = "Key setting account is not live, so it's impossible to associate keys."] NoAccount , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "New session has happened. Note that the argument is the session index, not the"] # [doc = "block number as the type might suggest."] NewSession { session_index : :: core :: primitive :: u32 , } , } } } pub mod pallet_staking { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Take the origin account as a stash and lock up `value` of its balance. `controller` will"] # [doc = "be the account that controls it."] # [doc = ""] # [doc = "`value` must be more than the `minimum_balance` specified by `T::Currency`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the stash account."] # [doc = ""] # [doc = "Emits `Bonded`."] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Moderate complexity."] # [doc = "- O(1)."] # [doc = "- Three extra DB entries."] # [doc = ""] # [doc = "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned"] # [doc = "unless the `origin` falls below _existential deposit_ and gets removed as dust."] # [doc = "------------------"] # [doc = "# </weight>"] bond { controller : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , # [codec (compact)] value : :: core :: primitive :: u128 , payee : runtime_types :: pallet_staking :: RewardDestination < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 1)] # [doc = "Add some extra amount that have appeared in the stash `free_balance` into the balance up"] # [doc = "for staking."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."] # [doc = ""] # [doc = "Use this if there are additional funds in your stash account that you wish to bond."] # [doc = "Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose"] # [doc = "any limitation on the amount that can be added."] # [doc = ""] # [doc = "Emits `Bonded`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Insignificant complexity."] # [doc = "- O(1)."] # [doc = "# </weight>"] bond_extra { # [codec (compact)] max_additional : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Schedule a portion of the stash to be unlocked ready for transfer out after the bond"] # [doc = "period ends. If this leaves an amount actively bonded less than"] # [doc = "T::Currency::minimum_balance(), then it is increased to the full amount."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "Once the unlock period is done, you can call `withdraw_unbonded` to actually move"] # [doc = "the funds out of management ready for transfer."] # [doc = ""] # [doc = "No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)"] # [doc = "can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need"] # [doc = "to be called first to remove some of the chunks (if possible)."] # [doc = ""] # [doc = "If a user encounters the `InsufficientBond` error when calling this extrinsic,"] # [doc = "they should call `chill` first in order to free up their bonded funds."] # [doc = ""] # [doc = "Emits `Unbonded`."] # [doc = ""] # [doc = "See also [`Call::withdraw_unbonded`]."] unbond { # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "Remove any unlocked chunks from the `unlocking` queue from our management."] # [doc = ""] # [doc = "This essentially frees up that balance to be used by the stash account to do"] # [doc = "whatever it wants."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller."] # [doc = ""] # [doc = "Emits `Withdrawn`."] # [doc = ""] # [doc = "See also [`Call::unbond`]."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Complexity O(S) where S is the number of slashing spans to remove"] # [doc = "NOTE: Weight annotation is the kill scenario, we refund otherwise."] # [doc = "# </weight>"] withdraw_unbonded { num_slashing_spans : :: core :: primitive :: u32 , } , # [codec (index = 4)] # [doc = "Declare the desire to validate for the origin controller."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] validate { prefs : runtime_types :: pallet_staking :: ValidatorPrefs , } , # [codec (index = 5)] # [doc = "Declare the desire to nominate `targets` for the origin controller."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- The transaction's complexity is proportional to the size of `targets` (N)"] # [doc = "which is capped at CompactAssignments::LIMIT (T::MaxNominations)."] # [doc = "- Both the reads and writes follow a similar pattern."] # [doc = "# </weight>"] nominate { targets : :: std :: vec :: Vec < :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > > , } , # [codec (index = 6)] # [doc = "Declare no desire to either validate or nominate."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Insignificant complexity."] # [doc = "- Contains one read."] # [doc = "- Writes are limited to the `origin` account key."] # [doc = "# </weight>"] chill , # [codec (index = 7)] # [doc = "(Re-)set the payment target for a controller."] # [doc = ""] # [doc = "Effects will be felt instantly (as soon as this function is completed successfully)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Insignificant complexity."] # [doc = "- Contains a limited number of reads."] # [doc = "- Writes are limited to the `origin` account key."] # [doc = "---------"] # [doc = "- Weight: O(1)"] # [doc = "- DB Weight:"] # [doc = "    - Read: Ledger"] # [doc = "    - Write: Payee"] # [doc = "# </weight>"] set_payee { payee : runtime_types :: pallet_staking :: RewardDestination < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 8)] # [doc = "(Re-)set the controller of a stash."] # [doc = ""] # [doc = "Effects will be felt instantly (as soon as this function is completed successfully)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Independent of the arguments. Insignificant complexity."] # [doc = "- Contains a limited number of reads."] # [doc = "- Writes are limited to the `origin` account key."] # [doc = "----------"] # [doc = "Weight: O(1)"] # [doc = "DB Weight:"] # [doc = "- Read: Bonded, Ledger New Controller, Ledger Old Controller"] # [doc = "- Write: Bonded, Ledger New Controller, Ledger Old Controller"] # [doc = "# </weight>"] set_controller { controller : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 9)] # [doc = "Sets the ideal number of validators."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Weight: O(1)"] # [doc = "Write: Validator Count"] # [doc = "# </weight>"] set_validator_count { # [codec (compact)] new : :: core :: primitive :: u32 , } , # [codec (index = 10)] # [doc = "Increments the ideal number of validators."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Same as [`Self::set_validator_count`]."] # [doc = "# </weight>"] increase_validator_count { # [codec (compact)] additional : :: core :: primitive :: u32 , } , # [codec (index = 11)] # [doc = "Scale up the ideal number of validators by a factor."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# <weight>"] # [doc = "Same as [`Self::set_validator_count`]."] # [doc = "# </weight>"] scale_validator_count { factor : runtime_types :: sp_arithmetic :: per_things :: Percent , } , # [codec (index = 12)] # [doc = "Force there to be no new eras indefinitely."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# Warning"] # [doc = ""] # [doc = "The election process starts multiple blocks before the end of the era."] # [doc = "Thus the election process may be ongoing when this is called. In this case the"] # [doc = "election will continue until the next era is triggered."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- No arguments."] # [doc = "- Weight: O(1)"] # [doc = "- Write: ForceEra"] # [doc = "# </weight>"] force_no_eras , # [codec (index = 13)] # [doc = "Force there to be a new era at the end of the next session. After this, it will be"] # [doc = "reset to normal (non-forced) behaviour."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# Warning"] # [doc = ""] # [doc = "The election process starts multiple blocks before the end of the era."] # [doc = "If this is called just before a new era is triggered, the election process may not"] # [doc = "have enough blocks to get a result."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- No arguments."] # [doc = "- Weight: O(1)"] # [doc = "- Write ForceEra"] # [doc = "# </weight>"] force_new_era , # [codec (index = 14)] # [doc = "Set the validators who cannot be slashed (if any)."] # [doc = ""] # [doc = "The dispatch origin must be Root."] set_invulnerables { invulnerables : :: std :: vec :: Vec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 15)] # [doc = "Force a current staker to become completely unstaked, immediately."] # [doc = ""] # [doc = "The dispatch origin must be Root."] force_unstake { stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , num_slashing_spans : :: core :: primitive :: u32 , } , # [codec (index = 16)] # [doc = "Force there to be a new era at the end of sessions indefinitely."] # [doc = ""] # [doc = "The dispatch origin must be Root."] # [doc = ""] # [doc = "# Warning"] # [doc = ""] # [doc = "The election process starts multiple blocks before the end of the era."] # [doc = "If this is called just before a new era is triggered, the election process may not"] # [doc = "have enough blocks to get a result."] force_new_era_always , # [codec (index = 17)] # [doc = "Cancel enactment of a deferred slash."] # [doc = ""] # [doc = "Can be called by the `T::SlashCancelOrigin`."] # [doc = ""] # [doc = "Parameters: era and indices of the slashes for that era to kill."] cancel_deferred_slash { era : :: core :: primitive :: u32 , slash_indices : :: std :: vec :: Vec < :: core :: primitive :: u32 > , } , # [codec (index = 18)] # [doc = "Pay out all the stakers behind a single validator for a single era."] # [doc = ""] # [doc = "- `validator_stash` is the stash account of the validator. Their nominators, up to"] # [doc = "  `T::MaxNominatorRewardedPerValidator`, will also receive their rewards."] # [doc = "- `era` may be any era between `[current_era - history_depth; current_era]`."] # [doc = ""] # [doc = "The origin of this call must be _Signed_. Any account can call this function, even if"] # [doc = "it is not one of the stakers."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Time complexity: at most O(MaxNominatorRewardedPerValidator)."] # [doc = "- Contains a limited number of reads and writes."] # [doc = "-----------"] # [doc = "N is the Number of payouts for the validator (including the validator)"] # [doc = "Weight:"] # [doc = "- Reward Destination Staked: O(N)"] # [doc = "- Reward Destination Controller (Creating): O(N)"] # [doc = ""] # [doc = "  NOTE: weights are assuming that payouts are made to alive stash account (Staked)."] # [doc = "  Paying even a dead controller is cheaper weight-wise. We don't do any refunds here."] # [doc = "# </weight>"] payout_stakers { validator_stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , era : :: core :: primitive :: u32 , } , # [codec (index = 19)] # [doc = "Rebond a portion of the stash scheduled to be unlocked."] # [doc = ""] # [doc = "The dispatch origin must be signed by the controller."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Time complexity: O(L), where L is unlocking chunks"] # [doc = "- Bounded by `MaxUnlockingChunks`."] # [doc = "- Storage changes: Can't increase storage, only decrease it."] # [doc = "# </weight>"] rebond { # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 20)] # [doc = "Remove all data structures concerning a staker/stash once it is at a state where it can"] # [doc = "be considered `dust` in the staking system. The requirements are:"] # [doc = ""] # [doc = "1. the `total_balance` of the stash is below existential deposit."] # [doc = "2. or, the `ledger.total` of the stash is below existential deposit."] # [doc = ""] # [doc = "The former can happen in cases like a slash; the latter when a fully unbonded account"] # [doc = "is still receiving staking rewards in `RewardDestination::Staked`."] # [doc = ""] # [doc = "It can be called by anyone, as long as `stash` meets the above requirements."] # [doc = ""] # [doc = "Refunds the transaction fees upon successful execution."] reap_stash { stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , num_slashing_spans : :: core :: primitive :: u32 , } , # [codec (index = 21)] # [doc = "Remove the given nominations from the calling validator."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."] # [doc = ""] # [doc = "- `who`: A list of nominator stash accounts who are nominating this validator which"] # [doc = "  should no longer be nominating this validator."] # [doc = ""] # [doc = "Note: Making this call only makes sense if you first set the validator preferences to"] # [doc = "block any further nominations."] kick { who : :: std :: vec :: Vec < :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > > , } , # [codec (index = 22)] # [doc = "Update the various staking configurations ."] # [doc = ""] # [doc = "* `min_nominator_bond`: The minimum active bond needed to be a nominator."] # [doc = "* `min_validator_bond`: The minimum active bond needed to be a validator."] # [doc = "* `max_nominator_count`: The max number of users who can be a nominator at once. When"] # [doc = "  set to `None`, no limit is enforced."] # [doc = "* `max_validator_count`: The max number of users who can be a validator at once. When"] # [doc = "  set to `None`, no limit is enforced."] # [doc = "* `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which"] # [doc = "  should be filled in order for the `chill_other` transaction to work."] # [doc = "* `min_commission`: The minimum amount of commission that each validators must maintain."] # [doc = "  This is checked only upon calling `validate`. Existing validators are not affected."] # [doc = ""] # [doc = "RuntimeOrigin must be Root to call this function."] # [doc = ""] # [doc = "NOTE: Existing nominators and validators will not be affected by this update."] # [doc = "to kick people under the new limits, `chill_other` should be called."] set_staking_configs { min_nominator_bond : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u128 > , min_validator_bond : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u128 > , max_nominator_count : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u32 > , max_validator_count : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < :: core :: primitive :: u32 > , chill_threshold : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < runtime_types :: sp_arithmetic :: per_things :: Percent > , min_commission : runtime_types :: pallet_staking :: pallet :: pallet :: ConfigOp < runtime_types :: sp_arithmetic :: per_things :: Perbill > , } , # [codec (index = 23)] # [doc = "Declare a `controller` to stop participating as either a validator or nominator."] # [doc = ""] # [doc = "Effects will be felt at the beginning of the next era."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_, but can be called by anyone."] # [doc = ""] # [doc = "If the caller is the same as the controller being targeted, then no further checks are"] # [doc = "enforced, and this function behaves just like `chill`."] # [doc = ""] # [doc = "If the caller is different than the controller being targeted, the following conditions"] # [doc = "must be met:"] # [doc = ""] # [doc = "* `controller` must belong to a nominator who has become non-decodable,"] # [doc = ""] # [doc = "Or:"] # [doc = ""] # [doc = "* A `ChillThreshold` must be set and checked which defines how close to the max"] # [doc = "  nominators or validators we must reach before users can start chilling one-another."] # [doc = "* A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine"] # [doc = "  how close we are to the threshold."] # [doc = "* A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines"] # [doc = "  if this is a person that should be chilled because they have not met the threshold"] # [doc = "  bond required."] # [doc = ""] # [doc = "This can be helpful if bond requirements are updated, and we need to remove old users"] # [doc = "who do not satisfy these requirements."] chill_other { controller : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 24)] # [doc = "Force a validator to have at least the minimum commission. This will not affect a"] # [doc = "validator who already has a commission greater than or equal to the minimum. Any account"] # [doc = "can call this."] force_apply_min_commission { validator_stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum ConfigOp < _0 > { # [codec (index = 0)] Noop , # [codec (index = 1)] Set (_0 ,) , # [codec (index = 2)] Remove , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Not a controller account."] NotController , # [codec (index = 1)] # [doc = "Not a stash account."] NotStash , # [codec (index = 2)] # [doc = "Stash is already bonded."] AlreadyBonded , # [codec (index = 3)] # [doc = "Controller is already paired."] AlreadyPaired , # [codec (index = 4)] # [doc = "Targets cannot be empty."] EmptyTargets , # [codec (index = 5)] # [doc = "Duplicate index."] DuplicateIndex , # [codec (index = 6)] # [doc = "Slash record index out of bounds."] InvalidSlashIndex , # [codec (index = 7)] # [doc = "Cannot have a validator or nominator role, with value less than the minimum defined by"] # [doc = "governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the"] # [doc = "intention, `chill` first to remove one's role as validator/nominator."] InsufficientBond , # [codec (index = 8)] # [doc = "Can not schedule more unlock chunks."] NoMoreChunks , # [codec (index = 9)] # [doc = "Can not rebond without unlocking chunks."] NoUnlockChunk , # [codec (index = 10)] # [doc = "Attempting to target a stash that still has funds."] FundedTarget , # [codec (index = 11)] # [doc = "Invalid era to reward."] InvalidEraToReward , # [codec (index = 12)] # [doc = "Invalid number of nominations."] InvalidNumberOfNominations , # [codec (index = 13)] # [doc = "Items are not sorted and unique."] NotSortedAndUnique , # [codec (index = 14)] # [doc = "Rewards for this era have already been claimed for this validator."] AlreadyClaimed , # [codec (index = 15)] # [doc = "Incorrect previous history depth input provided."] IncorrectHistoryDepth , # [codec (index = 16)] # [doc = "Incorrect number of slashing spans provided."] IncorrectSlashingSpans , # [codec (index = 17)] # [doc = "Internal state has become somehow corrupted and the operation cannot continue."] BadState , # [codec (index = 18)] # [doc = "Too many nomination targets supplied."] TooManyTargets , # [codec (index = 19)] # [doc = "A nomination target was supplied that was blocked or otherwise not a validator."] BadTarget , # [codec (index = 20)] # [doc = "The user has enough bond and thus cannot be chilled forcefully by an external person."] CannotChillOther , # [codec (index = 21)] # [doc = "There are too many nominators in the system. Governance needs to adjust the staking"] # [doc = "settings to keep things safe for the runtime."] TooManyNominators , # [codec (index = 22)] # [doc = "There are too many validators in the system. Governance needs to adjust the staking"] # [doc = "settings to keep things safe for the runtime."] TooManyValidators , # [codec (index = 23)] # [doc = "Commission is too low. Must be at least `MinCommission`."] CommissionTooLow , # [codec (index = 24)] # [doc = "Some bound is not met."] BoundNotMet , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "The era payout has been set; the first balance is the validator-payout; the second is"] # [doc = "the remainder from the maximum amount of reward."] EraPaid { era_index : :: core :: primitive :: u32 , validator_payout : :: core :: primitive :: u128 , remainder : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "The nominator has been rewarded by this amount."] Rewarded { stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "One staker (and potentially its nominators) has been slashed by the given amount."] Slashed { staker : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "An old slashing report from a prior era was discarded because it could"] # [doc = "not be processed."] OldSlashingReportDiscarded { session_index : :: core :: primitive :: u32 , } , # [codec (index = 4)] # [doc = "A new set of stakers was elected."] StakersElected , # [codec (index = 5)] # [doc = "An account has bonded this amount. \\[stash, amount\\]"] # [doc = ""] # [doc = "NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,"] # [doc = "it will not be emitted for staking rewards when they are added to stake."] Bonded { stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "An account has unbonded this amount."] Unbonded { stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 7)] # [doc = "An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`"] # [doc = "from the unlocking queue."] Withdrawn { stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 8)] # [doc = "A nominator has been kicked from a validator."] Kicked { nominator : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 9)] # [doc = "The election failed. No new era is planned."] StakingElectionFailed , # [codec (index = 10)] # [doc = "An account has stopped participating as either a validator or nominator."] Chilled { stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 11)] # [doc = "The stakers' rewards are getting paid."] PayoutStarted { era_index : :: core :: primitive :: u32 , validator_stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 12)] # [doc = "A validator has set their preferences."] ValidatorPrefsSet { stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , prefs : runtime_types :: pallet_staking :: ValidatorPrefs , } , } } } pub mod slashing { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SlashingSpans { pub span_index : :: core :: primitive :: u32 , pub last_start : :: core :: primitive :: u32 , pub last_nonzero_slash : :: core :: primitive :: u32 , pub prior : :: std :: vec :: Vec < :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SpanRecord < _0 > { pub slashed : _0 , pub paid_out : _0 , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ActiveEraInfo { pub index : :: core :: primitive :: u32 , pub start : :: core :: option :: Option < :: core :: primitive :: u64 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct EraRewardPoints < _0 > { pub total : :: core :: primitive :: u32 , pub individual : :: subxt :: utils :: KeyedVec < _0 , :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Exposure < _0 , _1 > { # [codec (compact)] pub total : _1 , # [codec (compact)] pub own : _1 , pub others : :: std :: vec :: Vec < runtime_types :: pallet_staking :: IndividualExposure < _0 , _1 > > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Forcing { # [codec (index = 0)] NotForcing , # [codec (index = 1)] ForceNew , # [codec (index = 2)] ForceNone , # [codec (index = 3)] ForceAlways , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct IndividualExposure < _0 , _1 > { pub who : _0 , # [codec (compact)] pub value : _1 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Nominations { pub targets : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , pub submitted_in : :: core :: primitive :: u32 , pub suppressed : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Releases { # [codec (index = 0)] V1_0_0Ancient , # [codec (index = 1)] V2_0_0 , # [codec (index = 2)] V3_0_0 , # [codec (index = 3)] V4_0_0 , # [codec (index = 4)] V5_0_0 , # [codec (index = 5)] V6_0_0 , # [codec (index = 6)] V7_0_0 , # [codec (index = 7)] V8_0_0 , # [codec (index = 8)] V9_0_0 , # [codec (index = 9)] V10_0_0 , # [codec (index = 10)] V11_0_0 , # [codec (index = 11)] V12_0_0 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum RewardDestination < _0 > { # [codec (index = 0)] Staked , # [codec (index = 1)] Stash , # [codec (index = 2)] Controller , # [codec (index = 3)] Account (_0 ,) , # [codec (index = 4)] None , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct StakingLedger { pub stash : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , # [codec (compact)] pub total : :: core :: primitive :: u128 , # [codec (compact)] pub active : :: core :: primitive :: u128 , pub unlocking : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < runtime_types :: pallet_staking :: UnlockChunk < :: core :: primitive :: u128 > > , pub claimed_rewards : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct UnappliedSlash < _0 , _1 > { pub validator : _0 , pub own : _1 , pub others : :: std :: vec :: Vec < (_0 , _1 ,) > , pub reporters : :: std :: vec :: Vec < _0 > , pub payout : _1 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct UnlockChunk < _0 > { # [codec (compact)] pub value : _0 , # [codec (compact)] pub era : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ValidatorPrefs { # [codec (compact)] pub commission : runtime_types :: sp_arithmetic :: per_things :: Perbill , pub blocked : :: core :: primitive :: bool , } } pub mod pallet_timestamp { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Set the current time."] # [doc = ""] # [doc = "This call should be invoked exactly once per block. It will panic at the finalization"] # [doc = "phase, if this call hasn't been invoked by that time."] # [doc = ""] # [doc = "The timestamp should be greater than the previous one by the amount specified by"] # [doc = "`MinimumPeriod`."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Inherent`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"] # [doc = "- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in"] # [doc = "  `on_finalize`)"] # [doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."] # [doc = "# </weight>"] set { # [codec (compact)] now : :: core :: primitive :: u64 , } , } } } pub mod pallet_transaction_payment { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,"] # [doc = "has been paid by `who`."] TransactionFeePaid { who : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , actual_fee : :: core :: primitive :: u128 , tip : :: core :: primitive :: u128 , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ChargeTransactionPayment (# [codec (compact)] pub :: core :: primitive :: u128 ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Releases { # [codec (index = 0)] V1Ancient , # [codec (index = 1)] V2 , } } pub mod pallet_treasury { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Put forward a suggestion for spending. A deposit proportional to the value"] # [doc = "is reserved and slashed if the proposal is rejected. It is returned once the"] # [doc = "proposal is awarded."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(1)"] # [doc = "- DbReads: `ProposalCount`, `origin account`"] # [doc = "- DbWrites: `ProposalCount`, `Proposals`, `origin account`"] # [doc = "# </weight>"] propose_spend { # [codec (compact)] value : :: core :: primitive :: u128 , beneficiary : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 1)] # [doc = "Reject a proposed spend. The original deposit will be slashed."] # [doc = ""] # [doc = "May only be called from `T::RejectOrigin`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(1)"] # [doc = "- DbReads: `Proposals`, `rejected proposer account`"] # [doc = "- DbWrites: `Proposals`, `rejected proposer account`"] # [doc = "# </weight>"] reject_proposal { # [codec (compact)] proposal_id : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Approve a proposal. At a later time, the proposal will be allocated to the beneficiary"] # [doc = "and the original deposit will be returned."] # [doc = ""] # [doc = "May only be called from `T::ApproveOrigin`."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(1)."] # [doc = "- DbReads: `Proposals`, `Approvals`"] # [doc = "- DbWrite: `Approvals`"] # [doc = "# </weight>"] approve_proposal { # [codec (compact)] proposal_id : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "Propose and approve a spend of treasury funds."] # [doc = ""] # [doc = "- `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`."] # [doc = "- `amount`: The amount to be transferred from the treasury to the `beneficiary`."] # [doc = "- `beneficiary`: The destination account for the transfer."] # [doc = ""] # [doc = "NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the"] # [doc = "beneficiary."] spend { # [codec (compact)] amount : :: core :: primitive :: u128 , beneficiary : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 4)] # [doc = "Force a previously approved proposal to be removed from the approval queue."] # [doc = "The original deposit will no longer be returned."] # [doc = ""] # [doc = "May only be called from `T::RejectOrigin`."] # [doc = "- `proposal_id`: The index of a proposal"] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(A) where `A` is the number of approvals"] # [doc = "- Db reads and writes: `Approvals`"] # [doc = "# </weight>"] # [doc = ""] # [doc = "Errors:"] # [doc = "- `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,"] # [doc = "i.e., the proposal has not been approved. This could also mean the proposal does not"] # [doc = "exist altogether, thus there is no way it would have been approved in the first place."] remove_approval { # [codec (compact)] proposal_id : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Error for the treasury pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Proposer's balance is too low."] InsufficientProposersBalance , # [codec (index = 1)] # [doc = "No proposal or bounty at that index."] InvalidIndex , # [codec (index = 2)] # [doc = "Too many approvals in the queue."] TooManyApprovals , # [codec (index = 3)] # [doc = "The spend origin is valid but the amount it is allowed to spend is lower than the"] # [doc = "amount to be spent."] InsufficientPermission , # [codec (index = 4)] # [doc = "Proposal has not been approved."] ProposalNotApproved , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "New proposal."] Proposed { proposal_index : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "We have ended a spend period and will now allocate funds."] Spending { budget_remaining : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Some funds have been allocated."] Awarded { proposal_index : :: core :: primitive :: u32 , award : :: core :: primitive :: u128 , account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 3)] # [doc = "A proposal was rejected; funds were slashed."] Rejected { proposal_index : :: core :: primitive :: u32 , slashed : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "Some of our funds have been burnt."] Burnt { burnt_funds : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "Spending has finished; this is the amount that rolls over until next spend."] Rollover { rollover_balance : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "Some funds have been deposited."] Deposit { value : :: core :: primitive :: u128 , } , # [codec (index = 7)] # [doc = "A new spend proposal has been approved."] SpendApproved { proposal_index : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 , beneficiary : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Proposal < _0 , _1 > { pub proposer : _0 , pub value : _1 , pub beneficiary : _0 , pub bond : _1 , } } pub mod pallet_utility { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Send a batch of dispatch calls."] # [doc = ""] # [doc = "May be called from any origin."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then call are dispatch without checking origin filter. (This includes"] # [doc = "bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(C) where C is the number of calls to be batched."] # [doc = "# </weight>"] # [doc = ""] # [doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"] # [doc = "event is deposited. If a call failed and the batch was interrupted, then the"] # [doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"] # [doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"] # [doc = "event is deposited."] batch { calls : :: std :: vec :: Vec < runtime_types :: alphanet_runtime :: RuntimeCall > , } , # [codec (index = 1)] # [doc = "Send a call through an indexed pseudonym of the sender."] # [doc = ""] # [doc = "Filter from origin are passed along. The call will be dispatched with an origin which"] # [doc = "use the same filter as the origin of this call."] # [doc = ""] # [doc = "NOTE: If you need to ensure that any account-based filtering is not honored (i.e."] # [doc = "because you expect `proxy` to have been used prior in the call stack and you do not want"] # [doc = "the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`"] # [doc = "in the Multisig pallet instead."] # [doc = ""] # [doc = "NOTE: Prior to version *12, this was called `as_limited_sub`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] as_derivative { index : :: core :: primitive :: u16 , call : :: std :: boxed :: Box < runtime_types :: alphanet_runtime :: RuntimeCall > , } , # [codec (index = 2)] # [doc = "Send a batch of dispatch calls and atomically execute them."] # [doc = "The whole transaction will rollback and fail if any of the calls failed."] # [doc = ""] # [doc = "May be called from any origin."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then call are dispatch without checking origin filter. (This includes"] # [doc = "bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(C) where C is the number of calls to be batched."] # [doc = "# </weight>"] batch_all { calls : :: std :: vec :: Vec < runtime_types :: alphanet_runtime :: RuntimeCall > , } , # [codec (index = 3)] # [doc = "Dispatches a function call with a provided origin."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- O(1)."] # [doc = "- Limited storage reads."] # [doc = "- One DB write (event)."] # [doc = "- Weight of derivative `call` execution + T::WeightInfo::dispatch_as()."] # [doc = "# </weight>"] dispatch_as { as_origin : :: std :: boxed :: Box < runtime_types :: alphanet_runtime :: OriginCaller > , call : :: std :: boxed :: Box < runtime_types :: alphanet_runtime :: RuntimeCall > , } , # [codec (index = 4)] # [doc = "Send a batch of dispatch calls."] # [doc = "Unlike `batch`, it allows errors and won't interrupt."] # [doc = ""] # [doc = "May be called from any origin."] # [doc = ""] # [doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"] # [doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."] # [doc = ""] # [doc = "If origin is root then call are dispatch without checking origin filter. (This includes"] # [doc = "bypassing `frame_system::Config::BaseCallFilter`)."] # [doc = ""] # [doc = "# <weight>"] # [doc = "- Complexity: O(C) where C is the number of calls to be batched."] # [doc = "# </weight>"] force_batch { calls : :: std :: vec :: Vec < runtime_types :: alphanet_runtime :: RuntimeCall > , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Too many calls batched."] TooManyCalls , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "Batch of dispatches did not complete fully. Index of first failing dispatch given, as"] # [doc = "well as the error."] BatchInterrupted { index : :: core :: primitive :: u32 , error : runtime_types :: sp_runtime :: DispatchError , } , # [codec (index = 1)] # [doc = "Batch of dispatches completed fully with no error."] BatchCompleted , # [codec (index = 2)] # [doc = "Batch of dispatches completed but has errors."] BatchCompletedWithErrors , # [codec (index = 3)] # [doc = "A single item within a Batch of dispatches has completed with no error."] ItemCompleted , # [codec (index = 4)] # [doc = "A single item within a Batch of dispatches has completed with error."] ItemFailed { error : runtime_types :: sp_runtime :: DispatchError , } , # [codec (index = 5)] # [doc = "A call was dispatched."] DispatchedAs { result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , } } } pub mod primitive_types { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct H256 (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct U256 (pub [:: core :: primitive :: u64 ; 4usize] ,) ; } pub mod sp_arithmetic { use super :: runtime_types ; pub mod fixed_point { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct FixedU128 (pub :: core :: primitive :: u128 ,) ; } pub mod per_things { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct PerU16 (pub :: core :: primitive :: u16 ,) ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Perbill (pub :: core :: primitive :: u32 ,) ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Percent (pub :: core :: primitive :: u8 ,) ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Permill (pub :: core :: primitive :: u32 ,) ; } } pub mod sp_authority_discovery { use super :: runtime_types ; pub mod app { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Public (pub runtime_types :: sp_core :: sr25519 :: Public ,) ; } } pub mod sp_consensus_babe { use super :: runtime_types ; pub mod app { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Public (pub runtime_types :: sp_core :: sr25519 :: Public ,) ; } pub mod digests { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum NextConfigDescriptor { # [codec (index = 1)] V1 { c : (:: core :: primitive :: u64 , :: core :: primitive :: u64 ,) , allowed_slots : runtime_types :: sp_consensus_babe :: AllowedSlots , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum PreDigest { # [codec (index = 1)] Primary (runtime_types :: sp_consensus_babe :: digests :: PrimaryPreDigest ,) , # [codec (index = 2)] SecondaryPlain (runtime_types :: sp_consensus_babe :: digests :: SecondaryPlainPreDigest ,) , # [codec (index = 3)] SecondaryVRF (runtime_types :: sp_consensus_babe :: digests :: SecondaryVRFPreDigest ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct PrimaryPreDigest { pub authority_index : :: core :: primitive :: u32 , pub slot : runtime_types :: sp_consensus_slots :: Slot , pub vrf_output : [:: core :: primitive :: u8 ; 32usize] , pub vrf_proof : [:: core :: primitive :: u8 ; 64usize] , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SecondaryPlainPreDigest { pub authority_index : :: core :: primitive :: u32 , pub slot : runtime_types :: sp_consensus_slots :: Slot , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SecondaryVRFPreDigest { pub authority_index : :: core :: primitive :: u32 , pub slot : runtime_types :: sp_consensus_slots :: Slot , pub vrf_output : [:: core :: primitive :: u8 ; 32usize] , pub vrf_proof : [:: core :: primitive :: u8 ; 64usize] , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum AllowedSlots { # [codec (index = 0)] PrimarySlots , # [codec (index = 1)] PrimaryAndSecondaryPlainSlots , # [codec (index = 2)] PrimaryAndSecondaryVRFSlots , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct BabeEpochConfiguration { pub c : (:: core :: primitive :: u64 , :: core :: primitive :: u64 ,) , pub allowed_slots : runtime_types :: sp_consensus_babe :: AllowedSlots , } } pub mod sp_consensus_slots { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct EquivocationProof < _0 , _1 > { pub offender : _1 , pub slot : runtime_types :: sp_consensus_slots :: Slot , pub first_header : _0 , pub second_header : _0 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Slot (pub :: core :: primitive :: u64 ,) ; } pub mod sp_core { use super :: runtime_types ; pub mod bounded { use super :: runtime_types ; pub mod bounded_btree_map { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct BoundedBTreeMap < _0 , _1 > (pub :: subxt :: utils :: KeyedVec < _0 , _1 > ,) ; } pub mod bounded_vec { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct BoundedVec < _0 > (pub :: std :: vec :: Vec < _0 > ,) ; } pub mod weak_bounded_vec { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct WeakBoundedVec < _0 > (pub :: std :: vec :: Vec < _0 > ,) ; } } pub mod crypto { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AccountId32 (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct KeyTypeId (pub [:: core :: primitive :: u8 ; 4usize] ,) ; } pub mod ecdsa { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Signature (pub [:: core :: primitive :: u8 ; 65usize] ,) ; } pub mod ed25519 { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Public (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Signature (pub [:: core :: primitive :: u8 ; 64usize] ,) ; } pub mod offchain { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct OpaqueMultiaddr (pub :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct OpaqueNetworkState { pub peer_id : runtime_types :: sp_core :: OpaquePeerId , pub external_addresses : :: std :: vec :: Vec < runtime_types :: sp_core :: offchain :: OpaqueMultiaddr > , } } pub mod sr25519 { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Public (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Signature (pub [:: core :: primitive :: u8 ; 64usize] ,) ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct OpaquePeerId (pub :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Void { } } pub mod sp_finality_grandpa { use super :: runtime_types ; pub mod app { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Public (pub runtime_types :: sp_core :: ed25519 :: Public ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Signature (pub runtime_types :: sp_core :: ed25519 :: Signature ,) ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Equivocation < _0 , _1 > { # [codec (index = 0)] Prevote (runtime_types :: finality_grandpa :: Equivocation < runtime_types :: sp_finality_grandpa :: app :: Public , runtime_types :: finality_grandpa :: Prevote < _0 , _1 > , runtime_types :: sp_finality_grandpa :: app :: Signature > ,) , # [codec (index = 1)] Precommit (runtime_types :: finality_grandpa :: Equivocation < runtime_types :: sp_finality_grandpa :: app :: Public , runtime_types :: finality_grandpa :: Precommit < _0 , _1 > , runtime_types :: sp_finality_grandpa :: app :: Signature > ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct EquivocationProof < _0 , _1 > { pub set_id : :: core :: primitive :: u64 , pub equivocation : runtime_types :: sp_finality_grandpa :: Equivocation < _0 , _1 > , } } pub mod sp_npos_elections { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ElectionScore { pub minimal_stake : :: core :: primitive :: u128 , pub sum_stake : :: core :: primitive :: u128 , pub sum_stake_squared : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Support < _0 > { pub total : :: core :: primitive :: u128 , pub voters : :: std :: vec :: Vec < (_0 , :: core :: primitive :: u128 ,) > , } } pub mod sp_runtime { use super :: runtime_types ; pub mod generic { use super :: runtime_types ; pub mod digest { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Digest { pub logs : :: std :: vec :: Vec < runtime_types :: sp_runtime :: generic :: digest :: DigestItem > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum DigestItem { # [codec (index = 6)] PreRuntime ([:: core :: primitive :: u8 ; 4usize] , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 4)] Consensus ([:: core :: primitive :: u8 ; 4usize] , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 5)] Seal ([:: core :: primitive :: u8 ; 4usize] , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 0)] Other (:: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 8)] RuntimeEnvironmentUpdated , } } pub mod era { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Era { # [codec (index = 0)] Immortal , # [codec (index = 1)] Mortal1 (:: core :: primitive :: u8 ,) , # [codec (index = 2)] Mortal2 (:: core :: primitive :: u8 ,) , # [codec (index = 3)] Mortal3 (:: core :: primitive :: u8 ,) , # [codec (index = 4)] Mortal4 (:: core :: primitive :: u8 ,) , # [codec (index = 5)] Mortal5 (:: core :: primitive :: u8 ,) , # [codec (index = 6)] Mortal6 (:: core :: primitive :: u8 ,) , # [codec (index = 7)] Mortal7 (:: core :: primitive :: u8 ,) , # [codec (index = 8)] Mortal8 (:: core :: primitive :: u8 ,) , # [codec (index = 9)] Mortal9 (:: core :: primitive :: u8 ,) , # [codec (index = 10)] Mortal10 (:: core :: primitive :: u8 ,) , # [codec (index = 11)] Mortal11 (:: core :: primitive :: u8 ,) , # [codec (index = 12)] Mortal12 (:: core :: primitive :: u8 ,) , # [codec (index = 13)] Mortal13 (:: core :: primitive :: u8 ,) , # [codec (index = 14)] Mortal14 (:: core :: primitive :: u8 ,) , # [codec (index = 15)] Mortal15 (:: core :: primitive :: u8 ,) , # [codec (index = 16)] Mortal16 (:: core :: primitive :: u8 ,) , # [codec (index = 17)] Mortal17 (:: core :: primitive :: u8 ,) , # [codec (index = 18)] Mortal18 (:: core :: primitive :: u8 ,) , # [codec (index = 19)] Mortal19 (:: core :: primitive :: u8 ,) , # [codec (index = 20)] Mortal20 (:: core :: primitive :: u8 ,) , # [codec (index = 21)] Mortal21 (:: core :: primitive :: u8 ,) , # [codec (index = 22)] Mortal22 (:: core :: primitive :: u8 ,) , # [codec (index = 23)] Mortal23 (:: core :: primitive :: u8 ,) , # [codec (index = 24)] Mortal24 (:: core :: primitive :: u8 ,) , # [codec (index = 25)] Mortal25 (:: core :: primitive :: u8 ,) , # [codec (index = 26)] Mortal26 (:: core :: primitive :: u8 ,) , # [codec (index = 27)] Mortal27 (:: core :: primitive :: u8 ,) , # [codec (index = 28)] Mortal28 (:: core :: primitive :: u8 ,) , # [codec (index = 29)] Mortal29 (:: core :: primitive :: u8 ,) , # [codec (index = 30)] Mortal30 (:: core :: primitive :: u8 ,) , # [codec (index = 31)] Mortal31 (:: core :: primitive :: u8 ,) , # [codec (index = 32)] Mortal32 (:: core :: primitive :: u8 ,) , # [codec (index = 33)] Mortal33 (:: core :: primitive :: u8 ,) , # [codec (index = 34)] Mortal34 (:: core :: primitive :: u8 ,) , # [codec (index = 35)] Mortal35 (:: core :: primitive :: u8 ,) , # [codec (index = 36)] Mortal36 (:: core :: primitive :: u8 ,) , # [codec (index = 37)] Mortal37 (:: core :: primitive :: u8 ,) , # [codec (index = 38)] Mortal38 (:: core :: primitive :: u8 ,) , # [codec (index = 39)] Mortal39 (:: core :: primitive :: u8 ,) , # [codec (index = 40)] Mortal40 (:: core :: primitive :: u8 ,) , # [codec (index = 41)] Mortal41 (:: core :: primitive :: u8 ,) , # [codec (index = 42)] Mortal42 (:: core :: primitive :: u8 ,) , # [codec (index = 43)] Mortal43 (:: core :: primitive :: u8 ,) , # [codec (index = 44)] Mortal44 (:: core :: primitive :: u8 ,) , # [codec (index = 45)] Mortal45 (:: core :: primitive :: u8 ,) , # [codec (index = 46)] Mortal46 (:: core :: primitive :: u8 ,) , # [codec (index = 47)] Mortal47 (:: core :: primitive :: u8 ,) , # [codec (index = 48)] Mortal48 (:: core :: primitive :: u8 ,) , # [codec (index = 49)] Mortal49 (:: core :: primitive :: u8 ,) , # [codec (index = 50)] Mortal50 (:: core :: primitive :: u8 ,) , # [codec (index = 51)] Mortal51 (:: core :: primitive :: u8 ,) , # [codec (index = 52)] Mortal52 (:: core :: primitive :: u8 ,) , # [codec (index = 53)] Mortal53 (:: core :: primitive :: u8 ,) , # [codec (index = 54)] Mortal54 (:: core :: primitive :: u8 ,) , # [codec (index = 55)] Mortal55 (:: core :: primitive :: u8 ,) , # [codec (index = 56)] Mortal56 (:: core :: primitive :: u8 ,) , # [codec (index = 57)] Mortal57 (:: core :: primitive :: u8 ,) , # [codec (index = 58)] Mortal58 (:: core :: primitive :: u8 ,) , # [codec (index = 59)] Mortal59 (:: core :: primitive :: u8 ,) , # [codec (index = 60)] Mortal60 (:: core :: primitive :: u8 ,) , # [codec (index = 61)] Mortal61 (:: core :: primitive :: u8 ,) , # [codec (index = 62)] Mortal62 (:: core :: primitive :: u8 ,) , # [codec (index = 63)] Mortal63 (:: core :: primitive :: u8 ,) , # [codec (index = 64)] Mortal64 (:: core :: primitive :: u8 ,) , # [codec (index = 65)] Mortal65 (:: core :: primitive :: u8 ,) , # [codec (index = 66)] Mortal66 (:: core :: primitive :: u8 ,) , # [codec (index = 67)] Mortal67 (:: core :: primitive :: u8 ,) , # [codec (index = 68)] Mortal68 (:: core :: primitive :: u8 ,) , # [codec (index = 69)] Mortal69 (:: core :: primitive :: u8 ,) , # [codec (index = 70)] Mortal70 (:: core :: primitive :: u8 ,) , # [codec (index = 71)] Mortal71 (:: core :: primitive :: u8 ,) , # [codec (index = 72)] Mortal72 (:: core :: primitive :: u8 ,) , # [codec (index = 73)] Mortal73 (:: core :: primitive :: u8 ,) , # [codec (index = 74)] Mortal74 (:: core :: primitive :: u8 ,) , # [codec (index = 75)] Mortal75 (:: core :: primitive :: u8 ,) , # [codec (index = 76)] Mortal76 (:: core :: primitive :: u8 ,) , # [codec (index = 77)] Mortal77 (:: core :: primitive :: u8 ,) , # [codec (index = 78)] Mortal78 (:: core :: primitive :: u8 ,) , # [codec (index = 79)] Mortal79 (:: core :: primitive :: u8 ,) , # [codec (index = 80)] Mortal80 (:: core :: primitive :: u8 ,) , # [codec (index = 81)] Mortal81 (:: core :: primitive :: u8 ,) , # [codec (index = 82)] Mortal82 (:: core :: primitive :: u8 ,) , # [codec (index = 83)] Mortal83 (:: core :: primitive :: u8 ,) , # [codec (index = 84)] Mortal84 (:: core :: primitive :: u8 ,) , # [codec (index = 85)] Mortal85 (:: core :: primitive :: u8 ,) , # [codec (index = 86)] Mortal86 (:: core :: primitive :: u8 ,) , # [codec (index = 87)] Mortal87 (:: core :: primitive :: u8 ,) , # [codec (index = 88)] Mortal88 (:: core :: primitive :: u8 ,) , # [codec (index = 89)] Mortal89 (:: core :: primitive :: u8 ,) , # [codec (index = 90)] Mortal90 (:: core :: primitive :: u8 ,) , # [codec (index = 91)] Mortal91 (:: core :: primitive :: u8 ,) , # [codec (index = 92)] Mortal92 (:: core :: primitive :: u8 ,) , # [codec (index = 93)] Mortal93 (:: core :: primitive :: u8 ,) , # [codec (index = 94)] Mortal94 (:: core :: primitive :: u8 ,) , # [codec (index = 95)] Mortal95 (:: core :: primitive :: u8 ,) , # [codec (index = 96)] Mortal96 (:: core :: primitive :: u8 ,) , # [codec (index = 97)] Mortal97 (:: core :: primitive :: u8 ,) , # [codec (index = 98)] Mortal98 (:: core :: primitive :: u8 ,) , # [codec (index = 99)] Mortal99 (:: core :: primitive :: u8 ,) , # [codec (index = 100)] Mortal100 (:: core :: primitive :: u8 ,) , # [codec (index = 101)] Mortal101 (:: core :: primitive :: u8 ,) , # [codec (index = 102)] Mortal102 (:: core :: primitive :: u8 ,) , # [codec (index = 103)] Mortal103 (:: core :: primitive :: u8 ,) , # [codec (index = 104)] Mortal104 (:: core :: primitive :: u8 ,) , # [codec (index = 105)] Mortal105 (:: core :: primitive :: u8 ,) , # [codec (index = 106)] Mortal106 (:: core :: primitive :: u8 ,) , # [codec (index = 107)] Mortal107 (:: core :: primitive :: u8 ,) , # [codec (index = 108)] Mortal108 (:: core :: primitive :: u8 ,) , # [codec (index = 109)] Mortal109 (:: core :: primitive :: u8 ,) , # [codec (index = 110)] Mortal110 (:: core :: primitive :: u8 ,) , # [codec (index = 111)] Mortal111 (:: core :: primitive :: u8 ,) , # [codec (index = 112)] Mortal112 (:: core :: primitive :: u8 ,) , # [codec (index = 113)] Mortal113 (:: core :: primitive :: u8 ,) , # [codec (index = 114)] Mortal114 (:: core :: primitive :: u8 ,) , # [codec (index = 115)] Mortal115 (:: core :: primitive :: u8 ,) , # [codec (index = 116)] Mortal116 (:: core :: primitive :: u8 ,) , # [codec (index = 117)] Mortal117 (:: core :: primitive :: u8 ,) , # [codec (index = 118)] Mortal118 (:: core :: primitive :: u8 ,) , # [codec (index = 119)] Mortal119 (:: core :: primitive :: u8 ,) , # [codec (index = 120)] Mortal120 (:: core :: primitive :: u8 ,) , # [codec (index = 121)] Mortal121 (:: core :: primitive :: u8 ,) , # [codec (index = 122)] Mortal122 (:: core :: primitive :: u8 ,) , # [codec (index = 123)] Mortal123 (:: core :: primitive :: u8 ,) , # [codec (index = 124)] Mortal124 (:: core :: primitive :: u8 ,) , # [codec (index = 125)] Mortal125 (:: core :: primitive :: u8 ,) , # [codec (index = 126)] Mortal126 (:: core :: primitive :: u8 ,) , # [codec (index = 127)] Mortal127 (:: core :: primitive :: u8 ,) , # [codec (index = 128)] Mortal128 (:: core :: primitive :: u8 ,) , # [codec (index = 129)] Mortal129 (:: core :: primitive :: u8 ,) , # [codec (index = 130)] Mortal130 (:: core :: primitive :: u8 ,) , # [codec (index = 131)] Mortal131 (:: core :: primitive :: u8 ,) , # [codec (index = 132)] Mortal132 (:: core :: primitive :: u8 ,) , # [codec (index = 133)] Mortal133 (:: core :: primitive :: u8 ,) , # [codec (index = 134)] Mortal134 (:: core :: primitive :: u8 ,) , # [codec (index = 135)] Mortal135 (:: core :: primitive :: u8 ,) , # [codec (index = 136)] Mortal136 (:: core :: primitive :: u8 ,) , # [codec (index = 137)] Mortal137 (:: core :: primitive :: u8 ,) , # [codec (index = 138)] Mortal138 (:: core :: primitive :: u8 ,) , # [codec (index = 139)] Mortal139 (:: core :: primitive :: u8 ,) , # [codec (index = 140)] Mortal140 (:: core :: primitive :: u8 ,) , # [codec (index = 141)] Mortal141 (:: core :: primitive :: u8 ,) , # [codec (index = 142)] Mortal142 (:: core :: primitive :: u8 ,) , # [codec (index = 143)] Mortal143 (:: core :: primitive :: u8 ,) , # [codec (index = 144)] Mortal144 (:: core :: primitive :: u8 ,) , # [codec (index = 145)] Mortal145 (:: core :: primitive :: u8 ,) , # [codec (index = 146)] Mortal146 (:: core :: primitive :: u8 ,) , # [codec (index = 147)] Mortal147 (:: core :: primitive :: u8 ,) , # [codec (index = 148)] Mortal148 (:: core :: primitive :: u8 ,) , # [codec (index = 149)] Mortal149 (:: core :: primitive :: u8 ,) , # [codec (index = 150)] Mortal150 (:: core :: primitive :: u8 ,) , # [codec (index = 151)] Mortal151 (:: core :: primitive :: u8 ,) , # [codec (index = 152)] Mortal152 (:: core :: primitive :: u8 ,) , # [codec (index = 153)] Mortal153 (:: core :: primitive :: u8 ,) , # [codec (index = 154)] Mortal154 (:: core :: primitive :: u8 ,) , # [codec (index = 155)] Mortal155 (:: core :: primitive :: u8 ,) , # [codec (index = 156)] Mortal156 (:: core :: primitive :: u8 ,) , # [codec (index = 157)] Mortal157 (:: core :: primitive :: u8 ,) , # [codec (index = 158)] Mortal158 (:: core :: primitive :: u8 ,) , # [codec (index = 159)] Mortal159 (:: core :: primitive :: u8 ,) , # [codec (index = 160)] Mortal160 (:: core :: primitive :: u8 ,) , # [codec (index = 161)] Mortal161 (:: core :: primitive :: u8 ,) , # [codec (index = 162)] Mortal162 (:: core :: primitive :: u8 ,) , # [codec (index = 163)] Mortal163 (:: core :: primitive :: u8 ,) , # [codec (index = 164)] Mortal164 (:: core :: primitive :: u8 ,) , # [codec (index = 165)] Mortal165 (:: core :: primitive :: u8 ,) , # [codec (index = 166)] Mortal166 (:: core :: primitive :: u8 ,) , # [codec (index = 167)] Mortal167 (:: core :: primitive :: u8 ,) , # [codec (index = 168)] Mortal168 (:: core :: primitive :: u8 ,) , # [codec (index = 169)] Mortal169 (:: core :: primitive :: u8 ,) , # [codec (index = 170)] Mortal170 (:: core :: primitive :: u8 ,) , # [codec (index = 171)] Mortal171 (:: core :: primitive :: u8 ,) , # [codec (index = 172)] Mortal172 (:: core :: primitive :: u8 ,) , # [codec (index = 173)] Mortal173 (:: core :: primitive :: u8 ,) , # [codec (index = 174)] Mortal174 (:: core :: primitive :: u8 ,) , # [codec (index = 175)] Mortal175 (:: core :: primitive :: u8 ,) , # [codec (index = 176)] Mortal176 (:: core :: primitive :: u8 ,) , # [codec (index = 177)] Mortal177 (:: core :: primitive :: u8 ,) , # [codec (index = 178)] Mortal178 (:: core :: primitive :: u8 ,) , # [codec (index = 179)] Mortal179 (:: core :: primitive :: u8 ,) , # [codec (index = 180)] Mortal180 (:: core :: primitive :: u8 ,) , # [codec (index = 181)] Mortal181 (:: core :: primitive :: u8 ,) , # [codec (index = 182)] Mortal182 (:: core :: primitive :: u8 ,) , # [codec (index = 183)] Mortal183 (:: core :: primitive :: u8 ,) , # [codec (index = 184)] Mortal184 (:: core :: primitive :: u8 ,) , # [codec (index = 185)] Mortal185 (:: core :: primitive :: u8 ,) , # [codec (index = 186)] Mortal186 (:: core :: primitive :: u8 ,) , # [codec (index = 187)] Mortal187 (:: core :: primitive :: u8 ,) , # [codec (index = 188)] Mortal188 (:: core :: primitive :: u8 ,) , # [codec (index = 189)] Mortal189 (:: core :: primitive :: u8 ,) , # [codec (index = 190)] Mortal190 (:: core :: primitive :: u8 ,) , # [codec (index = 191)] Mortal191 (:: core :: primitive :: u8 ,) , # [codec (index = 192)] Mortal192 (:: core :: primitive :: u8 ,) , # [codec (index = 193)] Mortal193 (:: core :: primitive :: u8 ,) , # [codec (index = 194)] Mortal194 (:: core :: primitive :: u8 ,) , # [codec (index = 195)] Mortal195 (:: core :: primitive :: u8 ,) , # [codec (index = 196)] Mortal196 (:: core :: primitive :: u8 ,) , # [codec (index = 197)] Mortal197 (:: core :: primitive :: u8 ,) , # [codec (index = 198)] Mortal198 (:: core :: primitive :: u8 ,) , # [codec (index = 199)] Mortal199 (:: core :: primitive :: u8 ,) , # [codec (index = 200)] Mortal200 (:: core :: primitive :: u8 ,) , # [codec (index = 201)] Mortal201 (:: core :: primitive :: u8 ,) , # [codec (index = 202)] Mortal202 (:: core :: primitive :: u8 ,) , # [codec (index = 203)] Mortal203 (:: core :: primitive :: u8 ,) , # [codec (index = 204)] Mortal204 (:: core :: primitive :: u8 ,) , # [codec (index = 205)] Mortal205 (:: core :: primitive :: u8 ,) , # [codec (index = 206)] Mortal206 (:: core :: primitive :: u8 ,) , # [codec (index = 207)] Mortal207 (:: core :: primitive :: u8 ,) , # [codec (index = 208)] Mortal208 (:: core :: primitive :: u8 ,) , # [codec (index = 209)] Mortal209 (:: core :: primitive :: u8 ,) , # [codec (index = 210)] Mortal210 (:: core :: primitive :: u8 ,) , # [codec (index = 211)] Mortal211 (:: core :: primitive :: u8 ,) , # [codec (index = 212)] Mortal212 (:: core :: primitive :: u8 ,) , # [codec (index = 213)] Mortal213 (:: core :: primitive :: u8 ,) , # [codec (index = 214)] Mortal214 (:: core :: primitive :: u8 ,) , # [codec (index = 215)] Mortal215 (:: core :: primitive :: u8 ,) , # [codec (index = 216)] Mortal216 (:: core :: primitive :: u8 ,) , # [codec (index = 217)] Mortal217 (:: core :: primitive :: u8 ,) , # [codec (index = 218)] Mortal218 (:: core :: primitive :: u8 ,) , # [codec (index = 219)] Mortal219 (:: core :: primitive :: u8 ,) , # [codec (index = 220)] Mortal220 (:: core :: primitive :: u8 ,) , # [codec (index = 221)] Mortal221 (:: core :: primitive :: u8 ,) , # [codec (index = 222)] Mortal222 (:: core :: primitive :: u8 ,) , # [codec (index = 223)] Mortal223 (:: core :: primitive :: u8 ,) , # [codec (index = 224)] Mortal224 (:: core :: primitive :: u8 ,) , # [codec (index = 225)] Mortal225 (:: core :: primitive :: u8 ,) , # [codec (index = 226)] Mortal226 (:: core :: primitive :: u8 ,) , # [codec (index = 227)] Mortal227 (:: core :: primitive :: u8 ,) , # [codec (index = 228)] Mortal228 (:: core :: primitive :: u8 ,) , # [codec (index = 229)] Mortal229 (:: core :: primitive :: u8 ,) , # [codec (index = 230)] Mortal230 (:: core :: primitive :: u8 ,) , # [codec (index = 231)] Mortal231 (:: core :: primitive :: u8 ,) , # [codec (index = 232)] Mortal232 (:: core :: primitive :: u8 ,) , # [codec (index = 233)] Mortal233 (:: core :: primitive :: u8 ,) , # [codec (index = 234)] Mortal234 (:: core :: primitive :: u8 ,) , # [codec (index = 235)] Mortal235 (:: core :: primitive :: u8 ,) , # [codec (index = 236)] Mortal236 (:: core :: primitive :: u8 ,) , # [codec (index = 237)] Mortal237 (:: core :: primitive :: u8 ,) , # [codec (index = 238)] Mortal238 (:: core :: primitive :: u8 ,) , # [codec (index = 239)] Mortal239 (:: core :: primitive :: u8 ,) , # [codec (index = 240)] Mortal240 (:: core :: primitive :: u8 ,) , # [codec (index = 241)] Mortal241 (:: core :: primitive :: u8 ,) , # [codec (index = 242)] Mortal242 (:: core :: primitive :: u8 ,) , # [codec (index = 243)] Mortal243 (:: core :: primitive :: u8 ,) , # [codec (index = 244)] Mortal244 (:: core :: primitive :: u8 ,) , # [codec (index = 245)] Mortal245 (:: core :: primitive :: u8 ,) , # [codec (index = 246)] Mortal246 (:: core :: primitive :: u8 ,) , # [codec (index = 247)] Mortal247 (:: core :: primitive :: u8 ,) , # [codec (index = 248)] Mortal248 (:: core :: primitive :: u8 ,) , # [codec (index = 249)] Mortal249 (:: core :: primitive :: u8 ,) , # [codec (index = 250)] Mortal250 (:: core :: primitive :: u8 ,) , # [codec (index = 251)] Mortal251 (:: core :: primitive :: u8 ,) , # [codec (index = 252)] Mortal252 (:: core :: primitive :: u8 ,) , # [codec (index = 253)] Mortal253 (:: core :: primitive :: u8 ,) , # [codec (index = 254)] Mortal254 (:: core :: primitive :: u8 ,) , # [codec (index = 255)] Mortal255 (:: core :: primitive :: u8 ,) , } } pub mod header { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Header < _0 , _1 > { pub parent_hash : :: subxt :: ext :: sp_core :: H256 , # [codec (compact)] pub number : _0 , pub state_root : :: subxt :: ext :: sp_core :: H256 , pub extrinsics_root : :: subxt :: ext :: sp_core :: H256 , pub digest : runtime_types :: sp_runtime :: generic :: digest :: Digest , # [codec (skip)] pub __subxt_unused_type_params : :: core :: marker :: PhantomData < _1 > } } pub mod unchecked_extrinsic { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct UncheckedExtrinsic < _0 , _1 , _2 , _3 > (pub :: std :: vec :: Vec < :: core :: primitive :: u8 > , # [codec (skip)] pub :: core :: marker :: PhantomData < (_1 , _0 , _2 , _3) >) ; } } pub mod multiaddress { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum MultiAddress < _0 , _1 > { # [codec (index = 0)] Id (_0 ,) , # [codec (index = 1)] Index (# [codec (compact)] _1 ,) , # [codec (index = 2)] Raw (:: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 3)] Address32 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 4)] Address20 ([:: core :: primitive :: u8 ; 20usize] ,) , } } pub mod traits { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct BlakeTwo256 ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum ArithmeticError { # [codec (index = 0)] Underflow , # [codec (index = 1)] Overflow , # [codec (index = 2)] DivisionByZero , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum DispatchError { # [codec (index = 0)] Other , # [codec (index = 1)] CannotLookup , # [codec (index = 2)] BadOrigin , # [codec (index = 3)] Module (runtime_types :: sp_runtime :: ModuleError ,) , # [codec (index = 4)] ConsumerRemaining , # [codec (index = 5)] NoProviders , # [codec (index = 6)] TooManyConsumers , # [codec (index = 7)] Token (runtime_types :: sp_runtime :: TokenError ,) , # [codec (index = 8)] Arithmetic (runtime_types :: sp_runtime :: ArithmeticError ,) , # [codec (index = 9)] Transactional (runtime_types :: sp_runtime :: TransactionalError ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct ModuleError { pub index : :: core :: primitive :: u8 , pub error : [:: core :: primitive :: u8 ; 4usize] , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum MultiSignature { # [codec (index = 0)] Ed25519 (runtime_types :: sp_core :: ed25519 :: Signature ,) , # [codec (index = 1)] Sr25519 (runtime_types :: sp_core :: sr25519 :: Signature ,) , # [codec (index = 2)] Ecdsa (runtime_types :: sp_core :: ecdsa :: Signature ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum TokenError { # [codec (index = 0)] NoFunds , # [codec (index = 1)] WouldDie , # [codec (index = 2)] BelowMinimum , # [codec (index = 3)] CannotCreate , # [codec (index = 4)] UnknownAsset , # [codec (index = 5)] Frozen , # [codec (index = 6)] Unsupported , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum TransactionalError { # [codec (index = 0)] LimitReached , # [codec (index = 1)] NoLayer , } } pub mod sp_session { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct MembershipProof { pub session : :: core :: primitive :: u32 , pub trie_nodes : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , pub validator_count : :: core :: primitive :: u32 , } } pub mod sp_staking { use super :: runtime_types ; pub mod offence { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct OffenceDetails < _0 , _1 > { pub offender : _1 , pub reporters : :: std :: vec :: Vec < _0 > , } } } pub mod sp_version { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RuntimeVersion { pub spec_name : :: std :: string :: String , pub impl_name : :: std :: string :: String , pub authoring_version : :: core :: primitive :: u32 , pub spec_version : :: core :: primitive :: u32 , pub impl_version : :: core :: primitive :: u32 , pub apis : :: std :: vec :: Vec < ([:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u32 ,) > , pub transaction_version : :: core :: primitive :: u32 , pub state_version : :: core :: primitive :: u8 , } } pub mod sp_weights { use super :: runtime_types ; pub mod weight_v2 { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Weight { # [codec (compact)] pub ref_time : :: core :: primitive :: u64 , # [codec (compact)] pub proof_size : :: core :: primitive :: u64 , } } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct OldWeight (pub :: core :: primitive :: u64 ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RuntimeDbWeight { pub read : :: core :: primitive :: u64 , pub write : :: core :: primitive :: u64 , } } pub mod ternoa_auction { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] create_auction { nft_id : :: core :: primitive :: u32 , marketplace_id : :: core :: primitive :: u32 , start_block : :: core :: primitive :: u32 , end_block : :: core :: primitive :: u32 , start_price : :: core :: primitive :: u128 , buy_it_price : :: core :: option :: Option < :: core :: primitive :: u128 > , } , # [codec (index = 1)] cancel_auction { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 2)] end_auction { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 3)] add_bid { nft_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 4)] remove_bid { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 5)] buy_it_now { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 6)] claim , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Operation not allowed because the auction has not started yet."] AuctionNotStarted , # [codec (index = 1)] # [doc = "Operation not allowed because the auction does not exists."] AuctionDoesNotExist , # [codec (index = 2)] # [doc = "Buy-It-Now option is not available."] AuctionDoesNotSupportBuyItNow , # [codec (index = 3)] # [doc = "Auction start block cannot be lower than current block."] AuctionCannotStartInThePast , # [codec (index = 4)] # [doc = "Auction end block cannot be lower than start block."] AuctionCannotEndBeforeItHasStarted , # [codec (index = 5)] # [doc = "Auction duration exceeds the maximum allowed duration."] AuctionDurationIsTooLong , # [codec (index = 6)] # [doc = "Auction duration is lower than the minimum allowed duration."] AuctionDurationIsTooShort , # [codec (index = 7)] # [doc = "Auction start block cannot be exceed the maximum allowed start delay."] AuctionStartIsTooFarAway , # [codec (index = 8)] # [doc = "Buy-it-now price cannot be lower or equal tah the auction start price."] BuyItPriceCannotBeLessOrEqualThanStartPrice , # [codec (index = 9)] # [doc = "The specified bid does not exist."] BidDoesNotExist , # [codec (index = 10)] # [doc = "Auction owner cannot add a bid to his own auction."] CannotAddBidToYourOwnAuctions , # [codec (index = 11)] # [doc = "Auction owner cannot use buy it now feature to his own auction."] CannotBuyItNowToYourOwnAuctions , # [codec (index = 12)] # [doc = "Auction cannot be canceled if the auction has started."] CannotCancelAuctionInProgress , # [codec (index = 13)] # [doc = "Cannot add a bid that is less than the current highest bid."] CannotBidLessThanTheHighestBid , # [codec (index = 14)] # [doc = "Cannot add a bid that is less than the current starting price."] CannotBidLessThanTheStartingPrice , # [codec (index = 15)] # [doc = "Cannot pay the buy-it-now price if a higher bid exists."] CannotBuyItWhenABidIsHigherThanBuyItPrice , # [codec (index = 16)] # [doc = "Cannot remove bid if the auction is soon to end."] CannotRemoveBidAtTheEndOfAuction , # [codec (index = 17)] # [doc = "Cannot end the auction if it was not extended."] CannotEndAuctionThatWasNotExtended , # [codec (index = 18)] # [doc = "Cannot auction NFTs that are listed for sale."] CannotListListedNFTs , # [codec (index = 19)] # [doc = "Cannot auction capsules."] CannotListCapsulesNFTs , # [codec (index = 20)] # [doc = "Cannot auction NFTs that are not owned by the caller."] CannotListNotOwnedNFTs , # [codec (index = 21)] # [doc = "Cannot auction delegated NFTs."] CannotListDelegatedNFTs , # [codec (index = 22)] # [doc = "Cannot auction non-created soulbound NFTs."] CannotListNotCreatedSoulboundNFTs , # [codec (index = 23)] # [doc = "Cannot auction rented NFTs."] CannotListRentedNFTs , # [codec (index = 24)] # [doc = "Cannot claim if the claim does not exist."] ClaimDoesNotExist , # [codec (index = 25)] # [doc = "Cannot auction NFTs that do not exit."] NFTNotFound , # [codec (index = 26)] # [doc = "Operation not allowed because the caller is not the owner of the auction."] NotTheAuctionCreator , # [codec (index = 27)] # [doc = "Unknown Marketplace found. This should never happen."] MarketplaceNotFound , # [codec (index = 28)] # [doc = "The Maximum amount of auctions that can be active at the same time has been reached."] MaximumAuctionsLimitReached , # [codec (index = 29)] # [doc = "The Maximum amount of bids for an auction."] MaximumBidLimitReached , # [codec (index = 30)] # [doc = "Operation is not permitted because price cannot cover marketplace fee."] PriceCannotCoverMarketplaceFee , # [codec (index = 31)] # [doc = "Not Allowed To List On MP"] NotAllowedToList , # [codec (index = 32)] # [doc = "Cannot end auction without bids"] CannotEndAuctionWithoutBids , # [codec (index = 33)] # [doc = "Cannot list because the NFT secret is not synced."] CannotListNotSyncedSecretNFTs , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A new auction was created."] AuctionCreated { nft_id : :: core :: primitive :: u32 , marketplace_id : :: core :: primitive :: u32 , creator : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , start_price : :: core :: primitive :: u128 , buy_it_price : :: core :: option :: Option < :: core :: primitive :: u128 > , start_block : :: core :: primitive :: u32 , end_block : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "An existing auction was cancelled."] AuctionCancelled { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "An auction has completed and no more bids can be placed."] AuctionCompleted { nft_id : :: core :: primitive :: u32 , new_owner : :: core :: option :: Option < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , paid_amount : :: core :: option :: Option < :: core :: primitive :: u128 > , marketplace_cut : :: core :: option :: Option < :: core :: primitive :: u128 > , royalty_cut : :: core :: option :: Option < :: core :: primitive :: u128 > , auctioneer_cut : :: core :: option :: Option < :: core :: primitive :: u128 > , } , # [codec (index = 3)] # [doc = "A new bid was created."] BidAdded { nft_id : :: core :: primitive :: u32 , bidder : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "An existing bid was removed."] BidRemoved { nft_id : :: core :: primitive :: u32 , bidder : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "An existing bid was updated."] BidUpdated { nft_id : :: core :: primitive :: u32 , bidder : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "An existing bid was dropped."] BidDropped { nft_id : :: core :: primitive :: u32 , bidder : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 7)] # [doc = "Balance claimed."] BalanceClaimed { account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , amount : :: core :: primitive :: u128 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct AuctionData < _0 , _1 , _2 > { pub creator : _0 , pub start_block : _1 , pub end_block : _1 , pub start_price : _2 , pub buy_it_price : :: core :: option :: Option < _2 > , pub bidders : runtime_types :: ternoa_auction :: types :: BidderList < _0 , _2 > , pub marketplace_id : _1 , pub is_extended : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct BidderList < _0 , _1 > { pub list : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < (_0 , _1 ,) > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct DeadlineList < _0 > (pub runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < (_0 , _0 ,) > ,) ; } } pub mod ternoa_bridge { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Sets the vote threshold for proposals."] # [doc = ""] # [doc = "This threshold is used to determine how many votes are required"] # [doc = "before a proposal is executed."] set_threshold { threshold : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Enables a chain ID as a source or destination for a bridge deposit."] add_chain { chain_id : :: core :: primitive :: u8 , } , # [codec (index = 2)] # [doc = "Update the set of relayers."] set_relayers { relayers : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 3)] # [doc = "Update the set of relayers."] set_deposit_nonce { chain_id : :: core :: primitive :: u8 , nonce : :: core :: primitive :: u64 , } , # [codec (index = 4)] # [doc = "Commits a vote in favour or against the provided proposal."] # [doc = ""] # [doc = "If a proposal with the given nonce and source chain ID does not already exist, it will"] # [doc = "be created with an initial vote in favour from the caller."] vote_for_proposal { chain_id : :: core :: primitive :: u8 , nonce : :: core :: primitive :: u64 , recipient : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , amount : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "Deposit some amount of the native token to some recipient on a (whitelisted)"] # [doc = "destination chain."] deposit { amount : :: core :: primitive :: u128 , recipient : :: std :: vec :: Vec < :: core :: primitive :: u8 > , dest_id : :: core :: primitive :: u8 , } , # [codec (index = 6)] # [doc = "Update the bridge fee value"] set_bridge_fee { bridge_fee : :: core :: primitive :: u128 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Chain has already been enabled."] CannotAddSelfToAllowedChainList , # [codec (index = 1)] # [doc = "Chain has already been enabled."] ChainAlreadyWhitelisted , # [codec (index = 2)] # [doc = "Provided chain does not exist."] ChainNotFound , # [codec (index = 3)] # [doc = "Interactions with this chain is not permitted."] ChainNotAllowed , # [codec (index = 4)] # [doc = "Insufficient balance for deposit."] InsufficientBalance , # [codec (index = 5)] # [doc = "Vote limit has already been reached."] MaximumVoteLimitExceeded , # [codec (index = 6)] # [doc = "Protected operation, must be performed by relayer."] MustBeRelayer , # [codec (index = 7)] # [doc = "New nonce needs to be bigger."] NewNonceTooLow , # [codec (index = 8)] # [doc = "Proposal has either failed or succeeded."] ProposalAlreadyCompleted , # [codec (index = 9)] # [doc = "Lifetime of proposal has been exceeded."] ProposalExpired , # [codec (index = 10)] # [doc = "Relayer has already submitted some vote for this proposal."] RelayerAlreadyVoted , # [codec (index = 11)] # [doc = "Relayer threshold cannot be 0."] ThresholdCannotBeZero , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "Bridge fee changed"] BridgeFeeUpdated { fee : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Make a deposit from Native to ERC20"] DepositMade { chain_id : :: core :: primitive :: u8 , nonce : :: core :: primitive :: u64 , amount : runtime_types :: primitive_types :: U256 , recipient : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 2)] # [doc = "Deposit Nonce Updated"] DepositNonceUpdated { chain_id : :: core :: primitive :: u8 , nonce : :: core :: primitive :: u64 , } , # [codec (index = 3)] # [doc = "Chain allowed to be used"] ChainAllowed { chain_id : :: core :: primitive :: u8 , } , # [codec (index = 4)] # [doc = "Voting successful for a proposal"] ProposalApproved { chain_id : :: core :: primitive :: u8 , nonce : :: core :: primitive :: u64 , } , # [codec (index = 5)] # [doc = "Vote threshold has changed"] RelayerThresholdUpdated { threshold : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "Vote submitted in favour of proposal"] RelayerVoted { chain_id : :: core :: primitive :: u8 , nonce : :: core :: primitive :: u64 , account : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 7)] # [doc = "Relayers has been updated"] RelayersUpdated { relayers : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Proposal < _0 , _1 > { pub votes : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < _0 > , pub status : runtime_types :: ternoa_bridge :: types :: ProposalStatus , pub expiry : _1 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum ProposalStatus { # [codec (index = 0)] Initiated , # [codec (index = 1)] Approved , } } } pub mod ternoa_mandate { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] mandate { call : :: std :: boxed :: Box < runtime_types :: alphanet_runtime :: RuntimeCall > , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A root operation was executed, show result"] RootOp { result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , } } } pub mod ternoa_marketplace { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Create a new marketplace with the provided details. An ID will be auto"] # [doc = "generated and logged as an event, The caller of this function"] # [doc = "will become the owner of the new marketplace."] create_marketplace { kind : runtime_types :: ternoa_pallets_primitives :: marketplace :: MarketplaceType , } , # [codec (index = 1)] # [doc = "Transfer the ownership of the marketplace to the recipient. Must be called by the"] # [doc = "owner of the marketplace."] set_marketplace_owner { marketplace_id : :: core :: primitive :: u32 , recipient : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 2)] # [doc = "Change the kind of the marketplace, can be private or public."] # [doc = "Must be called by the owner of the marketplace."] set_marketplace_kind { marketplace_id : :: core :: primitive :: u32 , kind : runtime_types :: ternoa_pallets_primitives :: marketplace :: MarketplaceType , } , # [codec (index = 3)] # [doc = "Set the configuration parameters of the marketplace (eg. commission_fee, listing_fee,"] # [doc = "account_list, offchain_data). Must be called by the owner of the marketplace."] set_marketplace_configuration { marketplace_id : :: core :: primitive :: u32 , commission_fee : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: ternoa_pallets_primitives :: common :: CompoundFee < :: core :: primitive :: u128 > > , listing_fee : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: ternoa_pallets_primitives :: common :: CompoundFee < :: core :: primitive :: u128 > > , account_list : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , offchain_data : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > , collection_list : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > > , } , # [codec (index = 4)] # [doc = "Sets the marketplace mint fee. Can only be called by Root."] set_marketplace_mint_fee { fee : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "Put an NFT on sale on a marketplace."] list_nft { nft_id : :: core :: primitive :: u32 , marketplace_id : :: core :: primitive :: u32 , price : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "Remove an NFT from sale."] unlist_nft { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "Buy a listed nft"] buy_nft { nft_id : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Not Allowed To List On MP"] NotAllowedToList , # [codec (index = 1)] # [doc = "Cannot list delegated NFTs."] CannotListDelegatedNFTs , # [codec (index = 2)] # [doc = "Cannot list capsule NFTs."] CannotListCapsuleNFTs , # [codec (index = 3)] # [doc = "Cannot list soulbound NFTs that was not created from owner."] CannotListNotCreatedSoulboundNFTs , # [codec (index = 4)] # [doc = "Cannot buy owned NFT"] CannotBuyOwnedNFT , # [codec (index = 5)] # [doc = "Sender is already the marketplace owner"] CannotTransferMarketplaceToYourself , # [codec (index = 6)] # [doc = "NFT already listed"] CannotListAlreadytListedNFTs , # [codec (index = 7)] # [doc = "The selected price is too low for commission fee"] PriceCannotCoverMarketplaceFee , # [codec (index = 8)] # [doc = "Marketplace not found"] MarketplaceNotFound , # [codec (index = 9)] # [doc = "NFT not found"] NFTNotFound , # [codec (index = 10)] # [doc = "This function can only be called by the owner of the NFT."] NotTheNFTOwner , # [codec (index = 11)] # [doc = "This function can only be called by the owner of the marketplace."] NotTheMarketplaceOwner , # [codec (index = 12)] # [doc = "NFT is not for sale"] NFTNotForSale , # [codec (index = 13)] # [doc = "Marketplaces data are full"] MarketpalceIdOverflow , # [codec (index = 14)] # [doc = "Math operations errors"] InternalMathError , # [codec (index = 15)] # [doc = "Not enough balance for the operation"] NotEnoughBalanceToBuy , # [codec (index = 16)] # [doc = "Cannot list because the NFT secret is not synced."] CannotListNotSyncedSecretNFTs , # [codec (index = 17)] # [doc = "Cannot list rented NFTs."] CannotListRentedNFTs , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "Marketplace created"] MarketplaceCreated { marketplace_id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , kind : runtime_types :: ternoa_pallets_primitives :: marketplace :: MarketplaceType , } , # [codec (index = 1)] # [doc = "Marketplace owner set"] MarketplaceOwnerSet { marketplace_id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 2)] # [doc = "Marketplace kind set"] MarketplaceKindSet { marketplace_id : :: core :: primitive :: u32 , kind : runtime_types :: ternoa_pallets_primitives :: marketplace :: MarketplaceType , } , # [codec (index = 3)] # [doc = "Marketplace config set"] MarketplaceConfigSet { marketplace_id : :: core :: primitive :: u32 , commission_fee : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: ternoa_pallets_primitives :: common :: CompoundFee < :: core :: primitive :: u128 > > , listing_fee : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: ternoa_pallets_primitives :: common :: CompoundFee < :: core :: primitive :: u128 > > , account_list : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , offchain_data : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > , collection_list : runtime_types :: ternoa_pallets_primitives :: common :: ConfigOp < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > > , } , # [codec (index = 4)] # [doc = "Marketplace mint fee set"] MarketplaceMintFeeSet { fee : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "NFT listed"] NFTListed { nft_id : :: core :: primitive :: u32 , marketplace_id : :: core :: primitive :: u32 , price : :: core :: primitive :: u128 , commission_fee : :: core :: option :: Option < runtime_types :: ternoa_pallets_primitives :: common :: CompoundFee < :: core :: primitive :: u128 > > , } , # [codec (index = 6)] # [doc = "NFT unlisted"] NFTUnlisted { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "NFT sold"] NFTSold { nft_id : :: core :: primitive :: u32 , marketplace_id : :: core :: primitive :: u32 , buyer : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , listed_price : :: core :: primitive :: u128 , marketplace_cut : :: core :: primitive :: u128 , royalty_cut : :: core :: primitive :: u128 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Sale < _0 , _1 > { pub account_id : _0 , pub marketplace_id : :: core :: primitive :: u32 , pub price : _1 , pub commission_fee : :: core :: option :: Option < runtime_types :: ternoa_pallets_primitives :: common :: CompoundFee < _1 > > , } } } pub mod ternoa_nft { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Create a new NFT with the provided details. An ID will be auto"] # [doc = "generated and logged as an event, The caller of this function"] # [doc = "will become the owner of the new NFT."] create_nft { offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , royalty : runtime_types :: sp_arithmetic :: per_things :: Permill , collection_id : :: core :: option :: Option < :: core :: primitive :: u32 > , is_soulbound : :: core :: primitive :: bool , } , # [codec (index = 1)] # [doc = "Remove an NFT from the storage. This operation is irreversible which means"] # [doc = "once the NFT is removed (burned) from the storage there is no way to"] # [doc = "get it back."] # [doc = "Must be called by the owner of the NFT."] burn_nft { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Transfer an NFT from an account to another one. Must be called by the"] # [doc = "owner of the NFT."] transfer_nft { nft_id : :: core :: primitive :: u32 , recipient : :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > , } , # [codec (index = 3)] # [doc = "Delegate an NFT to a recipient, does not change ownership."] # [doc = "Must be called by NFT owner."] delegate_nft { nft_id : :: core :: primitive :: u32 , recipient : :: core :: option :: Option < :: subxt :: ext :: sp_runtime :: MultiAddress < :: subxt :: ext :: sp_core :: crypto :: AccountId32 , () > > , } , # [codec (index = 4)] # [doc = "Set the royalty of an NFT."] # [doc = "Can only be called if the NFT is owned and has been created by the caller."] set_royalty { nft_id : :: core :: primitive :: u32 , royalty : runtime_types :: sp_arithmetic :: per_things :: Permill , } , # [codec (index = 5)] # [doc = "Set the fee for minting an NFT if the caller is root."] set_nft_mint_fee { fee : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "Create a new collection with the provided details. An ID will be auto"] # [doc = "generated and logged as an event, the caller of this function"] # [doc = "will become the owner of the new collection."] create_collection { offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , limit : :: core :: option :: Option < :: core :: primitive :: u32 > , } , # [codec (index = 7)] # [doc = "Remove a collection from the storage. This operation is irreversible which means"] # [doc = "once the collection is removed (burned) from the storage there is no way to"] # [doc = "get it back."] # [doc = "Must be called by the owner of the collection and collection must be empty."] burn_collection { collection_id : :: core :: primitive :: u32 , } , # [codec (index = 8)] # [doc = "Makes the collection closed. This means that it is not anymore"] # [doc = "possible to add new NFTs to the collection."] # [doc = "Can only be called by owner of the collection."] close_collection { collection_id : :: core :: primitive :: u32 , } , # [codec (index = 9)] # [doc = "Set the maximum amount of nfts in the collection."] # [doc = "Caller must be owner of collection, nfts in that collection must be lower or equal to"] # [doc = "new limit."] limit_collection { collection_id : :: core :: primitive :: u32 , limit : :: core :: primitive :: u32 , } , # [codec (index = 10)] # [doc = "Add an NFT to a collection."] # [doc = "Can only be called by owner of the collection, NFT"] # [doc = "must not be in collection and collection must not be closed or has reached limit."] add_nft_to_collection { nft_id : :: core :: primitive :: u32 , collection_id : :: core :: primitive :: u32 , } , # [codec (index = 11)] # [doc = "Add a secret to a basic NFT."] # [doc = "Must be called by NFT owner."] add_secret { nft_id : :: core :: primitive :: u32 , offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , } , # [codec (index = 12)] # [doc = "Create a new secret NFT with the provided details. An ID will be auto"] # [doc = "generated and logged as an event, The caller of this function"] # [doc = "will become the owner of the new NFT."] create_secret_nft { offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , secret_offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , royalty : runtime_types :: sp_arithmetic :: per_things :: Permill , collection_id : :: core :: option :: Option < :: core :: primitive :: u32 > , is_soulbound : :: core :: primitive :: bool , } , # [codec (index = 13)] # [doc = "Extrinsic called by TEE enclaves to indicate that a shard was received."] # [doc = "Must be called by registered enclaves."] add_secret_shard { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 14)] # [doc = "Set the fee for minting a secret NFT if the caller is root."] set_secret_nft_mint_fee { fee : :: core :: primitive :: u128 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Operation not allowed because the NFT is listed for sale."] CannotTransferListedNFTs , # [codec (index = 1)] # [doc = "Operation not allowed because the NFT is listed for sale."] CannotBurnListedNFTs , # [codec (index = 2)] # [doc = "Operation not allowed because the NFT is listed for sale."] CannotDelegateListedNFTs , # [codec (index = 3)] # [doc = "Operation not allowed because the NFT is listed for sale."] CannotSetRoyaltyForListedNFTs , # [codec (index = 4)] # [doc = "Operation is not allowed because the NFT is delegated."] CannotTransferDelegatedNFTs , # [codec (index = 5)] # [doc = "Operation is not allowed because the NFT secret is not synced."] CannotTransferNotSyncedSecretNFTs , # [codec (index = 6)] # [doc = "Operation is not allowed because the NFT is delegated."] CannotBurnDelegatedNFTs , # [codec (index = 7)] # [doc = "Operation is not allowed because the NFT is delegated."] CannotSetRoyaltyForDelegatedNFTs , # [codec (index = 8)] # [doc = "Operation is not allowed because the NFT is a capsule."] CannotTransferCapsuleNFTs , # [codec (index = 9)] # [doc = "Operation is not allowed because the NFT is a capsule."] CannotBurnCapsuleNFTs , # [codec (index = 10)] # [doc = "Operation is not allowed because the NFT is a capsule."] CannotDelegateCapsuleNFTs , # [codec (index = 11)] # [doc = "Operation is not allowed because the NFT is  and signer is not the creator."] CannotTransferNotCreatedSoulboundNFTs , # [codec (index = 12)] # [doc = "Operation is not allowed because the NFT is a capsule."] CannotSetRoyaltyForCapsuleNFTs , # [codec (index = 13)] # [doc = "Operation is not allowed because the NFT is owned by the caller."] CannotTransferNFTsToYourself , # [codec (index = 14)] # [doc = "Operation is not allowed because the NFT is rented"] CannotTransferRentedNFTs , # [codec (index = 15)] # [doc = "Operation is not allowed because the NFT is rented"] CannotBurnRentedNFTs , # [codec (index = 16)] # [doc = "Operation is not allowed because the NFT is rented"] CannotSetRoyaltyForRentedNFTs , # [codec (index = 17)] # [doc = "Operation is not allowed because the NFT is rented"] CannotDelegateRentedNFTs , # [codec (index = 18)] # [doc = "Operation is not allowed because the collection limit is too low."] CollectionLimitExceededMaximumAllowed , # [codec (index = 19)] # [doc = "No NFT was found with that NFT id."] NFTNotFound , # [codec (index = 20)] # [doc = "NFT id not found in collection nft list."] NFTNotFoundInCollection , # [codec (index = 21)] # [doc = "NFT already belong to a collection."] NFTBelongToACollection , # [codec (index = 22)] # [doc = "This function can only be called by the owner of the NFT."] NotTheNFTOwner , # [codec (index = 23)] # [doc = "This function can only be called by the creator of the NFT."] NotTheNFTCreator , # [codec (index = 24)] # [doc = "This function can only be called by the owner of the collection."] NotTheCollectionOwner , # [codec (index = 25)] # [doc = "No Collection was found with that NFT id."] CollectionNotFound , # [codec (index = 26)] # [doc = "Operation is not allowed because the collection is closed."] CollectionIsClosed , # [codec (index = 27)] # [doc = "Collection nft list has reached the selected limit."] CollectionHasReachedLimit , # [codec (index = 28)] # [doc = "Operation is not allowed because the collection is not empty."] CollectionIsNotEmpty , # [codec (index = 29)] # [doc = "Operation is not permitted because the collection's limit is already set."] CollectionLimitAlreadySet , # [codec (index = 30)] # [doc = "Operation is not permitted because the nfts number in the collection are greater than"] # [doc = "the new limit."] CollectionHasTooManyNFTs , # [codec (index = 31)] # [doc = "Operation is not permitted because collection nfts is full."] CannotAddMoreNFTsToCollection , # [codec (index = 32)] # [doc = "Operation is not permitted because caller is not a registered TEE enclave."] NotARegisteredEnclave , # [codec (index = 33)] # [doc = "Operation is not permitted because NFT is not a secret."] NFTIsNotSecret , # [codec (index = 34)] # [doc = "Operation is not permitted because NFT secret is already synced."] NFTAlreadySynced , # [codec (index = 35)] # [doc = "Operation is not permitted because NFT has already received all shards."] NFTHasReceivedAllShards , # [codec (index = 36)] # [doc = "Operation is not permitted because Enclave has already added its shard."] EnclaveAlreadyAddedShard , # [codec (index = 37)] # [doc = "Insufficient balance"] InsufficientBalance , # [codec (index = 38)] # [doc = "Operation is not permitted because the NFT is listed."] CannotAddSecretToListedNFTs , # [codec (index = 39)] # [doc = "Operation is not permitted because the NFT is a capsule."] CannotAddSecretToCapsuleNFTs , # [codec (index = 40)] # [doc = "Operation is not permitted because the NFT is already a secret."] CannotAddSecretToSecretNFTs , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A new NFT was created."] NFTCreated { nft_id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , royalty : runtime_types :: sp_arithmetic :: per_things :: Permill , collection_id : :: core :: option :: Option < :: core :: primitive :: u32 > , is_soulbound : :: core :: primitive :: bool , mint_fee : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "An NFT was burned."] NFTBurned { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "An NFT was transferred to someone else."] NFTTransferred { nft_id : :: core :: primitive :: u32 , sender : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , recipient : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 3)] # [doc = "An NFT was delegated to someone else."] NFTDelegated { nft_id : :: core :: primitive :: u32 , recipient : :: core :: option :: Option < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 4)] # [doc = "Royalty has been changed for an NFT."] NFTRoyaltySet { nft_id : :: core :: primitive :: u32 , royalty : runtime_types :: sp_arithmetic :: per_things :: Permill , } , # [codec (index = 5)] # [doc = "NFT mint fee changed."] NFTMintFeeSet { fee : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "A collection was created."] CollectionCreated { collection_id : :: core :: primitive :: u32 , owner : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , limit : :: core :: option :: Option < :: core :: primitive :: u32 > , } , # [codec (index = 7)] # [doc = "A collection was burned."] CollectionBurned { collection_id : :: core :: primitive :: u32 , } , # [codec (index = 8)] # [doc = "A collection was closed."] CollectionClosed { collection_id : :: core :: primitive :: u32 , } , # [codec (index = 9)] # [doc = "A collection has limit set."] CollectionLimited { collection_id : :: core :: primitive :: u32 , limit : :: core :: primitive :: u32 , } , # [codec (index = 10)] # [doc = "An NFT has been added to a collection."] NFTAddedToCollection { nft_id : :: core :: primitive :: u32 , collection_id : :: core :: primitive :: u32 , } , # [codec (index = 11)] # [doc = "A secret was added to a basic NFT."] SecretAddedToNFT { nft_id : :: core :: primitive :: u32 , offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , } , # [codec (index = 12)] # [doc = "A shard was added for a secret NFT."] ShardAdded { nft_id : :: core :: primitive :: u32 , enclave : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 13)] # [doc = "A secret NFT has finished syncing shards."] SecretNFTSynced { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 14)] # [doc = "Secret NFT mint fee changed."] SecretNFTMintFeeSet { fee : :: core :: primitive :: u128 , } , } } } pub mod ternoa_pallets_primitives { use super :: runtime_types ; pub mod common { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum CompoundFee < _0 > { # [codec (index = 0)] Flat (_0 ,) , # [codec (index = 1)] Percentage (runtime_types :: sp_arithmetic :: per_things :: Permill ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum ConfigOp < _0 > { # [codec (index = 0)] Noop , # [codec (index = 1)] Set (_0 ,) , # [codec (index = 2)] Remove , } } pub mod marketplace { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct MarketplaceData < _0 , _1 > { pub owner : _0 , pub kind : runtime_types :: ternoa_pallets_primitives :: marketplace :: MarketplaceType , pub commission_fee : :: core :: option :: Option < runtime_types :: ternoa_pallets_primitives :: common :: CompoundFee < _1 > > , pub listing_fee : :: core :: option :: Option < runtime_types :: ternoa_pallets_primitives :: common :: CompoundFee < _1 > > , pub account_list : :: core :: option :: Option < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < _0 > > , pub offchain_data : :: core :: option :: Option < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > > , pub collection_list : :: core :: option :: Option < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum MarketplaceType { # [codec (index = 0)] Public , # [codec (index = 1)] Private , } } pub mod nfts { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Collection < _0 > { pub owner : _0 , pub offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , pub nfts : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > , pub limit : :: core :: option :: Option < :: core :: primitive :: u32 > , pub is_closed : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct NFTData < _0 > { pub owner : _0 , pub creator : _0 , pub offchain_data : runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , pub collection_id : :: core :: option :: Option < :: core :: primitive :: u32 > , pub royalty : runtime_types :: sp_arithmetic :: per_things :: Permill , pub state : runtime_types :: ternoa_pallets_primitives :: nfts :: NFTState , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct NFTState { pub is_capsule : :: core :: primitive :: bool , pub is_listed : :: core :: primitive :: bool , pub is_secret : :: core :: primitive :: bool , pub is_delegated : :: core :: primitive :: bool , pub is_soulbound : :: core :: primitive :: bool , pub is_syncing : :: core :: primitive :: bool , pub is_rented : :: core :: primitive :: bool , } } } pub mod ternoa_rent { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Create a new rent contract with the provided details."] create_contract { nft_id : :: core :: primitive :: u32 , duration : runtime_types :: ternoa_rent :: types :: DurationInput < :: core :: primitive :: u32 > , acceptance_type : runtime_types :: ternoa_rent :: types :: AcceptanceType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , renter_can_revoke : :: core :: primitive :: bool , rent_fee : runtime_types :: ternoa_rent :: types :: RentFee < :: core :: primitive :: u128 > , renter_cancellation_fee : runtime_types :: ternoa_rent :: types :: CancellationFee < :: core :: primitive :: u128 > , rentee_cancellation_fee : runtime_types :: ternoa_rent :: types :: CancellationFee < :: core :: primitive :: u128 > , } , # [codec (index = 1)] # [doc = "Cancel a contract that is not running."] cancel_contract { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Revoke a running contract."] revoke_contract { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "Rent an NFT."] rent { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 4)] # [doc = "Make a offer."] make_rent_offer { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 5)] # [doc = "Accept a rent offer for manual acceptance contract."] accept_rent_offer { nft_id : :: core :: primitive :: u32 , rentee : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 6)] # [doc = "Retract a rent offer for manual acceptance contract."] retract_rent_offer { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "Change the subscription terms for subscription contracts."] change_subscription_terms { nft_id : :: core :: primitive :: u32 , rent_fee : :: core :: primitive :: u128 , period : :: core :: primitive :: u32 , max_duration : :: core :: option :: Option < :: core :: primitive :: u32 > , is_changeable : :: core :: primitive :: bool , } , # [codec (index = 8)] # [doc = "Accept the new contract terms."] accept_subscription_terms { nft_id : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "NFT was not found."] NFTNotFound , # [codec (index = 1)] # [doc = "Rented NFT was not found."] RentNFTNotFound , # [codec (index = 2)] # [doc = "Cancellation NFT was not found."] CancellationNFTNotFound , # [codec (index = 3)] # [doc = "The caller is not the renter or rentee."] NotAContractParticipant , # [codec (index = 4)] # [doc = "Cannot revoke a non running contract."] CannotRevokeNonRunningContract , # [codec (index = 5)] # [doc = "Cannot cancel a running contract."] CannotCancelRunningContract , # [codec (index = 6)] # [doc = "Contract is not allowed to be canceled by renter."] ContractCannotBeCanceledByRenter , # [codec (index = 7)] # [doc = "Contract does not support automatic rent."] ContractDoesNotSupportAutomaticRent , # [codec (index = 8)] # [doc = "Contract does not allow for offers to be made."] ContractDoesNotSupportOffers , # [codec (index = 9)] # [doc = "The caller is not whitelisted."] NotWhitelisted , # [codec (index = 10)] # [doc = "The caller does not own the rent NFT."] CallerDoesNotOwnRentNFT , # [codec (index = 11)] # [doc = "The caller does not own the cancellation NFT."] CallerDoesNotOwnCancellationNFT , # [codec (index = 12)] # [doc = "Rentee does not own the rent NFT."] RenteeDoesNotOwnTheRentNFT , # [codec (index = 13)] # [doc = "Rentee does not own the cancellation NFT."] RenteeDoesNotOwnTheCancellationNFT , # [codec (index = 14)] # [doc = "Not Enough funds for rent fee."] NotEnoughFundsForRentFee , # [codec (index = 15)] # [doc = "Not Enough funds for cancellation fee."] NotEnoughFundsForCancellationFee , # [codec (index = 16)] # [doc = "Not enough funds for cancellation fee + rent fee."] NotEnoughFundsForFees , # [codec (index = 17)] # [doc = "The caller is not the contract owner."] NotTheContractOwner , # [codec (index = 18)] # [doc = "The caller is not the contract rentee."] NotTheContractRentee , # [codec (index = 19)] # [doc = "Contract NFT is not in a valid state."] ContractNFTNotInAValidState , # [codec (index = 20)] # [doc = "Rent NFT is not in a valid state."] RentNFTNotInValidState , # [codec (index = 21)] # [doc = "Cancellation NFT is not in a valid state."] CancellationNFTNotInValidState , # [codec (index = 22)] # [doc = "The caller is not the owner of the contract NFT."] NotTheNFTOwner , # [codec (index = 23)] # [doc = "The chain cannot accept new NFT contracts. Maximum limit reached."] MaxSimultaneousContractReached , # [codec (index = 24)] # [doc = "The contract was not found."] ContractNotFound , # [codec (index = 25)] # [doc = "Cannot Rent your own contract."] CannotRentOwnContract , # [codec (index = 26)] # [doc = "The contract cannot accept new offers. Maximum limit reached."] MaximumOffersReached , # [codec (index = 27)] # [doc = "Operation is not permitted because contract terms are already accepted."] ContractTermsAlreadyAccepted , # [codec (index = 28)] # [doc = "No offers were found for that contract."] NoOffersForThisContract , # [codec (index = 29)] # [doc = "No offers were found for that address."] NoOfferFromThisAddress , # [codec (index = 30)] # [doc = "Duration and revocation mismatch."] DurationAndRentFeeMismatch , # [codec (index = 31)] # [doc = "Duration and cancellation mismatch."] DurationAndCancellationFeeMismatch , # [codec (index = 32)] # [doc = "Cannot adjust subscription Terms."] CannotAdjustSubscriptionTerms , # [codec (index = 33)] # [doc = "Contract is not running."] ContractIsNotRunning , # [codec (index = 34)] # [doc = "Duration exceeds maximum limit"] DurationExceedsMaximumLimit , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "Contract Created."] ContractCreated { nft_id : :: core :: primitive :: u32 , renter : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , duration : runtime_types :: ternoa_rent :: types :: Duration < :: core :: primitive :: u32 > , acceptance_type : runtime_types :: ternoa_rent :: types :: AcceptanceType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > > , renter_can_revoke : :: core :: primitive :: bool , rent_fee : runtime_types :: ternoa_rent :: types :: RentFee < :: core :: primitive :: u128 > , renter_cancellation_fee : runtime_types :: ternoa_rent :: types :: CancellationFee < :: core :: primitive :: u128 > , rentee_cancellation_fee : runtime_types :: ternoa_rent :: types :: CancellationFee < :: core :: primitive :: u128 > , } , # [codec (index = 1)] # [doc = "Contract was accepted and has started."] ContractStarted { nft_id : :: core :: primitive :: u32 , rentee : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 2)] # [doc = "Contract was revoked by either renter or rentee."] ContractRevoked { nft_id : :: core :: primitive :: u32 , revoked_by : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 3)] # [doc = "An offer was made for manual acceptance rent contract."] ContractOfferCreated { nft_id : :: core :: primitive :: u32 , rentee : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 4)] # [doc = "An offer was retracted for manual acceptance rent contract."] ContractOfferRetracted { nft_id : :: core :: primitive :: u32 , rentee : :: subxt :: ext :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 5)] # [doc = "A contract subscription's terms were changed by renter."] ContractSubscriptionTermsChanged { nft_id : :: core :: primitive :: u32 , period : :: core :: primitive :: u32 , max_duration : :: core :: primitive :: u32 , is_changeable : :: core :: primitive :: bool , rent_fee : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "A contract new subscription's terms were accpeted by rentee."] ContractSubscriptionTermsAccepted { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "A contract has ended."] ContractEnded { nft_id : :: core :: primitive :: u32 , revoked_by : :: core :: option :: Option < :: subxt :: ext :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 8)] # [doc = "A contract's subscription period has started."] ContractSubscriptionPeriodStarted { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 9)] # [doc = "A contract available for sale was expired before its acceptance."] ContractExpired { nft_id : :: core :: primitive :: u32 , } , # [codec (index = 10)] # [doc = "Contract was canceled."] ContractCanceled { nft_id : :: core :: primitive :: u32 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum AcceptanceType < _0 > { # [codec (index = 0)] AutoAcceptance (:: core :: option :: Option < _0 > ,) , # [codec (index = 1)] ManualAcceptance (:: core :: option :: Option < _0 > ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum CancellationFee < _0 > { # [codec (index = 0)] None , # [codec (index = 1)] FixedTokens (_0 ,) , # [codec (index = 2)] FlexibleTokens (_0 ,) , # [codec (index = 3)] NFT (:: core :: primitive :: u32 ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum Duration < _0 > { # [codec (index = 0)] Fixed (_0 ,) , # [codec (index = 1)] Subscription (runtime_types :: ternoa_rent :: types :: Subscription < _0 > ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum DurationInput < _0 > { # [codec (index = 0)] Fixed (_0 ,) , # [codec (index = 1)] Subscription (runtime_types :: ternoa_rent :: types :: SubscriptionInput < _0 > ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Queue < _0 > (pub runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < (_0 , _0 ,) > ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RentContractData < _0 , _1 , _2 > { pub start_block : :: core :: option :: Option < _1 > , pub renter : _0 , pub rentee : :: core :: option :: Option < _0 > , pub duration : runtime_types :: ternoa_rent :: types :: Duration < _1 > , pub acceptance_type : runtime_types :: ternoa_rent :: types :: AcceptanceType < runtime_types :: sp_core :: bounded :: bounded_vec :: BoundedVec < _0 > > , pub renter_can_revoke : :: core :: primitive :: bool , pub rent_fee : runtime_types :: ternoa_rent :: types :: RentFee < _2 > , pub renter_cancellation_fee : runtime_types :: ternoa_rent :: types :: CancellationFee < _2 > , pub rentee_cancellation_fee : runtime_types :: ternoa_rent :: types :: CancellationFee < _2 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub enum RentFee < _0 > { # [codec (index = 0)] Tokens (_0 ,) , # [codec (index = 1)] NFT (:: core :: primitive :: u32 ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct RentingQueues < _0 > { pub fixed_queue : runtime_types :: ternoa_rent :: types :: Queue < _0 > , pub subscription_queue : runtime_types :: ternoa_rent :: types :: Queue < _0 > , pub available_queue : runtime_types :: ternoa_rent :: types :: Queue < _0 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct Subscription < _0 > { pub period_length : _0 , pub max_duration : _0 , pub is_changeable : :: core :: primitive :: bool , pub new_terms : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct SubscriptionInput < _0 > { pub period_length : _0 , pub max_duration : :: core :: option :: Option < _0 > , pub is_changeable : :: core :: primitive :: bool , } } } pub mod ternoa_runtime_common { use super :: runtime_types ; pub mod election_provider_multi_phase { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct NposCompactSolution24 { pub votes1 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes2 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes3 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 2usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes4 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 3usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes5 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 4usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes6 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 5usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes7 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 6usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes8 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 7usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes9 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 8usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes10 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 9usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes11 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 10usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes12 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 11usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes13 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 12usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes14 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 13usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes15 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 14usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes16 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 15usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes17 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 16usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes18 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 17usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes19 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 18usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes20 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 19usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes21 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 20usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes22 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 21usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes23 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 22usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , pub votes24 : :: std :: vec :: Vec < (:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u32 > , [(:: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > , :: subxt :: ext :: codec :: Compact < runtime_types :: sp_arithmetic :: per_things :: PerU16 > ,) ; 23usize] , :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u16 > ,) > , } } } pub mod ternoa_staking_rewards { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] set_session_extra_reward_payout { # [codec (compact)] value : :: core :: primitive :: u128 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] SessionExtraRewardPayoutChanged { value : :: core :: primitive :: u128 , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , Debug)] pub struct StakingRewardsData < _0 > { pub session_era_payout : _0 , pub session_extra_reward_payout : _0 , } } } # [doc = r" The default error type returned when there is a runtime issue,"] # [doc = r" exposed here for ease of use."] pub type DispatchError = runtime_types :: sp_runtime :: DispatchError ; pub fn constants () -> ConstantsApi { ConstantsApi } pub fn storage () -> StorageApi { StorageApi } pub fn tx () -> TransactionApi { TransactionApi } pub struct ConstantsApi ; impl ConstantsApi { pub fn system (& self) -> system :: constants :: ConstantsApi { system :: constants :: ConstantsApi } pub fn scheduler (& self) -> scheduler :: constants :: ConstantsApi { scheduler :: constants :: ConstantsApi } pub fn babe (& self) -> babe :: constants :: ConstantsApi { babe :: constants :: ConstantsApi } pub fn timestamp (& self) -> timestamp :: constants :: ConstantsApi { timestamp :: constants :: ConstantsApi } pub fn balances (& self) -> balances :: constants :: ConstantsApi { balances :: constants :: ConstantsApi } pub fn transaction_payment (& self) -> transaction_payment :: constants :: ConstantsApi { transaction_payment :: constants :: ConstantsApi } pub fn authorship (& self) -> authorship :: constants :: ConstantsApi { authorship :: constants :: ConstantsApi } pub fn grandpa (& self) -> grandpa :: constants :: ConstantsApi { grandpa :: constants :: ConstantsApi } pub fn im_online (& self) -> im_online :: constants :: ConstantsApi { im_online :: constants :: ConstantsApi } pub fn phragmen_election (& self) -> phragmen_election :: constants :: ConstantsApi { phragmen_election :: constants :: ConstantsApi } pub fn democracy (& self) -> democracy :: constants :: ConstantsApi { democracy :: constants :: ConstantsApi } pub fn staking (& self) -> staking :: constants :: ConstantsApi { staking :: constants :: ConstantsApi } pub fn staking_rewards (& self) -> staking_rewards :: constants :: ConstantsApi { staking_rewards :: constants :: ConstantsApi } pub fn election_provider_multi_phase (& self) -> election_provider_multi_phase :: constants :: ConstantsApi { election_provider_multi_phase :: constants :: ConstantsApi } pub fn bags_list (& self) -> bags_list :: constants :: ConstantsApi { bags_list :: constants :: ConstantsApi } pub fn treasury (& self) -> treasury :: constants :: ConstantsApi { treasury :: constants :: ConstantsApi } pub fn utility (& self) -> utility :: constants :: ConstantsApi { utility :: constants :: ConstantsApi } pub fn bridge (& self) -> bridge :: constants :: ConstantsApi { bridge :: constants :: ConstantsApi } pub fn multisig (& self) -> multisig :: constants :: ConstantsApi { multisig :: constants :: ConstantsApi } pub fn identity (& self) -> identity :: constants :: ConstantsApi { identity :: constants :: ConstantsApi } pub fn nft (& self) -> nft :: constants :: ConstantsApi { nft :: constants :: ConstantsApi } pub fn marketplace (& self) -> marketplace :: constants :: ConstantsApi { marketplace :: constants :: ConstantsApi } pub fn assets (& self) -> assets :: constants :: ConstantsApi { assets :: constants :: ConstantsApi } pub fn auction (& self) -> auction :: constants :: ConstantsApi { auction :: constants :: ConstantsApi } pub fn rent (& self) -> rent :: constants :: ConstantsApi { rent :: constants :: ConstantsApi } } pub struct StorageApi ; impl StorageApi { pub fn system (& self) -> system :: storage :: StorageApi { system :: storage :: StorageApi } pub fn scheduler (& self) -> scheduler :: storage :: StorageApi { scheduler :: storage :: StorageApi } pub fn babe (& self) -> babe :: storage :: StorageApi { babe :: storage :: StorageApi } pub fn timestamp (& self) -> timestamp :: storage :: StorageApi { timestamp :: storage :: StorageApi } pub fn balances (& self) -> balances :: storage :: StorageApi { balances :: storage :: StorageApi } pub fn transaction_payment (& self) -> transaction_payment :: storage :: StorageApi { transaction_payment :: storage :: StorageApi } pub fn authorship (& self) -> authorship :: storage :: StorageApi { authorship :: storage :: StorageApi } pub fn offences (& self) -> offences :: storage :: StorageApi { offences :: storage :: StorageApi } pub fn historical (& self) -> historical :: storage :: StorageApi { historical :: storage :: StorageApi } pub fn session (& self) -> session :: storage :: StorageApi { session :: storage :: StorageApi } pub fn grandpa (& self) -> grandpa :: storage :: StorageApi { grandpa :: storage :: StorageApi } pub fn im_online (& self) -> im_online :: storage :: StorageApi { im_online :: storage :: StorageApi } pub fn authority_discovery (& self) -> authority_discovery :: storage :: StorageApi { authority_discovery :: storage :: StorageApi } pub fn council (& self) -> council :: storage :: StorageApi { council :: storage :: StorageApi } pub fn phragmen_election (& self) -> phragmen_election :: storage :: StorageApi { phragmen_election :: storage :: StorageApi } pub fn democracy (& self) -> democracy :: storage :: StorageApi { democracy :: storage :: StorageApi } pub fn staking (& self) -> staking :: storage :: StorageApi { staking :: storage :: StorageApi } pub fn staking_rewards (& self) -> staking_rewards :: storage :: StorageApi { staking_rewards :: storage :: StorageApi } pub fn election_provider_multi_phase (& self) -> election_provider_multi_phase :: storage :: StorageApi { election_provider_multi_phase :: storage :: StorageApi } pub fn bags_list (& self) -> bags_list :: storage :: StorageApi { bags_list :: storage :: StorageApi } pub fn technical_committee (& self) -> technical_committee :: storage :: StorageApi { technical_committee :: storage :: StorageApi } pub fn technical_membership (& self) -> technical_membership :: storage :: StorageApi { technical_membership :: storage :: StorageApi } pub fn treasury (& self) -> treasury :: storage :: StorageApi { treasury :: storage :: StorageApi } pub fn preimage (& self) -> preimage :: storage :: StorageApi { preimage :: storage :: StorageApi } pub fn bridge (& self) -> bridge :: storage :: StorageApi { bridge :: storage :: StorageApi } pub fn multisig (& self) -> multisig :: storage :: StorageApi { multisig :: storage :: StorageApi } pub fn identity (& self) -> identity :: storage :: StorageApi { identity :: storage :: StorageApi } pub fn nft (& self) -> nft :: storage :: StorageApi { nft :: storage :: StorageApi } pub fn marketplace (& self) -> marketplace :: storage :: StorageApi { marketplace :: storage :: StorageApi } pub fn assets (& self) -> assets :: storage :: StorageApi { assets :: storage :: StorageApi } pub fn auction (& self) -> auction :: storage :: StorageApi { auction :: storage :: StorageApi } pub fn rent (& self) -> rent :: storage :: StorageApi { rent :: storage :: StorageApi } } pub struct TransactionApi ; impl TransactionApi { pub fn system (& self) -> system :: calls :: TransactionApi { system :: calls :: TransactionApi } pub fn scheduler (& self) -> scheduler :: calls :: TransactionApi { scheduler :: calls :: TransactionApi } pub fn babe (& self) -> babe :: calls :: TransactionApi { babe :: calls :: TransactionApi } pub fn timestamp (& self) -> timestamp :: calls :: TransactionApi { timestamp :: calls :: TransactionApi } pub fn balances (& self) -> balances :: calls :: TransactionApi { balances :: calls :: TransactionApi } pub fn authorship (& self) -> authorship :: calls :: TransactionApi { authorship :: calls :: TransactionApi } pub fn session (& self) -> session :: calls :: TransactionApi { session :: calls :: TransactionApi } pub fn grandpa (& self) -> grandpa :: calls :: TransactionApi { grandpa :: calls :: TransactionApi } pub fn im_online (& self) -> im_online :: calls :: TransactionApi { im_online :: calls :: TransactionApi } pub fn council (& self) -> council :: calls :: TransactionApi { council :: calls :: TransactionApi } pub fn phragmen_election (& self) -> phragmen_election :: calls :: TransactionApi { phragmen_election :: calls :: TransactionApi } pub fn democracy (& self) -> democracy :: calls :: TransactionApi { democracy :: calls :: TransactionApi } pub fn staking (& self) -> staking :: calls :: TransactionApi { staking :: calls :: TransactionApi } pub fn staking_rewards (& self) -> staking_rewards :: calls :: TransactionApi { staking_rewards :: calls :: TransactionApi } pub fn election_provider_multi_phase (& self) -> election_provider_multi_phase :: calls :: TransactionApi { election_provider_multi_phase :: calls :: TransactionApi } pub fn bags_list (& self) -> bags_list :: calls :: TransactionApi { bags_list :: calls :: TransactionApi } pub fn technical_committee (& self) -> technical_committee :: calls :: TransactionApi { technical_committee :: calls :: TransactionApi } pub fn technical_membership (& self) -> technical_membership :: calls :: TransactionApi { technical_membership :: calls :: TransactionApi } pub fn mandate (& self) -> mandate :: calls :: TransactionApi { mandate :: calls :: TransactionApi } pub fn treasury (& self) -> treasury :: calls :: TransactionApi { treasury :: calls :: TransactionApi } pub fn utility (& self) -> utility :: calls :: TransactionApi { utility :: calls :: TransactionApi } pub fn preimage (& self) -> preimage :: calls :: TransactionApi { preimage :: calls :: TransactionApi } pub fn bridge (& self) -> bridge :: calls :: TransactionApi { bridge :: calls :: TransactionApi } pub fn multisig (& self) -> multisig :: calls :: TransactionApi { multisig :: calls :: TransactionApi } pub fn identity (& self) -> identity :: calls :: TransactionApi { identity :: calls :: TransactionApi } pub fn nft (& self) -> nft :: calls :: TransactionApi { nft :: calls :: TransactionApi } pub fn marketplace (& self) -> marketplace :: calls :: TransactionApi { marketplace :: calls :: TransactionApi } pub fn assets (& self) -> assets :: calls :: TransactionApi { assets :: calls :: TransactionApi } pub fn auction (& self) -> auction :: calls :: TransactionApi { auction :: calls :: TransactionApi } pub fn rent (& self) -> rent :: calls :: TransactionApi { rent :: calls :: TransactionApi } } # [doc = r" check whether the Client you are using is aligned with the statically generated codegen."] pub fn validate_codegen < T : :: subxt :: Config , C : :: subxt :: client :: OfflineClientT < T >> (client : & C) -> Result < () , :: subxt :: error :: MetadataError > { let runtime_metadata_hash = client . metadata () . metadata_hash (& PALLETS) ; if runtime_metadata_hash != [167u8 , 67u8 , 84u8 , 114u8 , 209u8 , 108u8 , 15u8 , 146u8 , 112u8 , 242u8 , 164u8 , 205u8 , 21u8 , 119u8 , 204u8 , 4u8 , 85u8 , 20u8 , 165u8 , 235u8 , 97u8 , 137u8 , 146u8 , 136u8 , 40u8 , 110u8 , 133u8 , 210u8 , 122u8 , 23u8 , 45u8 , 92u8 ,] { Err (:: subxt :: error :: MetadataError :: IncompatibleMetadata) } else { Ok (()) } } }
